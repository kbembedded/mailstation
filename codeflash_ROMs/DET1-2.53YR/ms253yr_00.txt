;; Mailstation Version 2.53yr ROM comments
;;
;; These comments originated from a disassembly of version 2.54, pages 0-3,
;; posted to badcluster by Rogblake.
;;
;; Version 2.53yr is almost the same as 2.54, mainly the ram addresses
;; are different.
;;
;; Look at Address #0036 to see what rom version is currently loaded.
;; There might be a few places where the code does not
;; match these comments, depending on the version.
;; For the most part, addresses in the comments are for v2.54.
;;
;; Most of the comments I added were entered via wordpad on a copy of Rogblakes
;; disassembly.  I used double semicolons for most of what I added, and left
;; Rogblake's comments with single semi's.
;;
;; Since then, both his and my comments have been extracted to .cmnt files
;; that are merged "on the fly" by the debugger.  That's why so many of them
;; are wider than the DOS console.  The arrow keys will scroll horizontal,
;; as well as up and down.

; Disassembly of the file "C:\Projects\mailstation\ms254_1.rom"
; Created with dZ80 v1.31  on Friday, 19 of April 2002 at 07:13 PM.

               ORG  #0000
0000:0000 00     nop         ;; RST 0 target  One explanation I can think of for
0000:0001 00     nop         ;;               all the skipped bytes is that this
0000:0002 00     nop         ;;               is the area where restarts land.
0000:0003 00     nop        
0000:0004 00     nop        
0000:0005 00     nop        
0000:0006 00     nop        
0000:0007 00     nop        
0000:0008 00     nop         ;; RST #08 target
0000:0009 00     nop        
0000:000A 00     nop        
0000:000B 00     nop        
0000:000C 00     nop        
0000:000D 00     nop        
0000:000E 00     nop        
0000:000F 00     nop        
0000:0010 00     nop         ;; RST #10 target
0000:0011 00     nop        
0000:0012 00     nop        
0000:0013 00     nop        
0000:0014 00     nop        
0000:0015 00     nop        
0000:0016 00     nop        
0000:0017 00     nop        
0000:0018 00     nop         ;; RST #18 target
0000:0019 00     nop        
0000:001A 00     nop        
0000:001B 00     nop        
0000:001C 00     nop        
0000:001D 00     nop        
0000:001E 00     nop        
0000:001F 00     nop        
0000:0020 00     nop         ;; RST #20 target
;; **any** RST #00 - RST #20 will bring control back here.
;; Don't know if used, but good to know it *could* happen.

;; This is the "cold boot".  Not that there is a warm boot.  Actually, this sorta
;; is both.  At least a few bytes are preserved (not cleared in init code) and the
;; values are used the next "boot", though it seems incredibly lame to trust these
;; values on powerup, (or after a brief power interruption).
;; Ram is powered, even when the power is off (if batteries good!).
0000:0021 F3     di          
0000:0022 31F0FF ld sp,stack  ;; OK, there's ram in the c000-ffff slot after reset,
0000:0025 ED56   im 1        ;;   but is it ever banked out???  (it appears not)
0000:0027 CD7038 call Init   ; Init  ;; clears most of ram, among other things.
;;
0000:002A 210040 ld hl,4000  ; More init/check for flash reprog (18000)
0000:002D C35400 jp MoreInit     ; JP $18000
;; RST #28 target is inside above code.

;; This is after a JP, so it must be called, jumped to, or restarted.
;; Set HL before calling!
;; RST #30 target
0000:0030 112D00 ld de,002D  ; Main? (2D = B4000. but what's in HL?)
0000:0033 C3AE19 jp Thru_Stargate     ;; wormhole to page #2D:hhll.  I suspect that this might be here,
;;                            ;; and not in sequence with the other wormholes, so it can be
;;                            ;; called via RST #30.  (but I haven't seen any use of it yet.)

          version_at:
0000:0036 5302   defw 0253   ; Version #

;; INT (maskable interrupt vectors here)
;; RST #38 target
;; (debugger uses RST #38 for breakpoints, so isr needs to be borrowed.  Or use diff rst.)
0000:0038 F3     di          
0000:0039 C38618 jp interrupt_svc     ; Keyboard handler/interrupt ;; and modem, callid, rtc, etc isr's.


;; Coderom bank selection.  Pages are 16k each.
;; #19ae puts page spec by DE in slot #4000-7fff
;; These are "wormholes" to the other pages of coderom.
;; The ;comments call them banks.  This bank number is what is
;; written to page select register P5 ("slot4000page").
;; HL needs to be pointed at an address within #4000-7FFF prior to jumping.
          pg01
0000:003C 110100 ld de,0001  ; Bank 1 (04000)
0000:003F C3AE19 jp Thru_Stargate    

          pg02
0000:0042 110200 ld de,0002  ; Bank 2 (08000)
0000:0045 C3AE19 jp Thru_Stargate    

          pg03
0000:0048 110300 ld de,0003  ; Bank 3 (0C000)
0000:004B C3AE19 jp Thru_Stargate    

;; page 4 is font and icon data,
;; not code, so no wormhole needed.

          pg05
0000:004E 110500 ld de,0005  ; Bank 5 (14000)
0000:0051 C3AE19 jp Thru_Stargate    

          pg06
0000:0054 110600 ld de,0006  ; Bank 6 (18000)
0000:0057 C3AE19 jp Thru_Stargate    

          pg07
0000:005A 110700 ld de,0007  ; Bank 7 (1C000)
0000:005D C3AE19 jp Thru_Stargate    

          pg08
0000:0060 110800 ld de,0008  ; Bank 8 (20000)
0000:0063 C3AE19 jp Thru_Stargate    

;; nonmaskable interupt vectors to fixed address #0066.
;; handled by same isr  as maskable int's.
;;
0000:0066 00     nop         ; NMI
0000:0067 C38618 jp interrupt_svc     ; Keyboard handler

          pg09
0000:006A 110900 ld de,0009  ; Bank 9 (24000)
0000:006D C3AE19 jp Thru_Stargate    

          pg0A
0000:0070 110A00 ld de,000A  ; Bank 10 (28000)
0000:0073 C3AE19 jp Thru_Stargate    

          pg0B
0000:0076 110B00 ld de,000B  ; Bank 11 (2C000)
0000:0079 C3AE19 jp Thru_Stargate    

          pg0C
0000:007C 110C00 ld de,000C  ; Bank 12 (30000)
0000:007F C3AE19 jp Thru_Stargate    

          pg0D
0000:0082 110D00 ld de,000D  ; Bank 13 (34000)
0000:0085 C3AE19 jp Thru_Stargate    

          pg0E
0000:0088 110E00 ld de,000E  ; Bank 14 (38000)
0000:008B C3AE19 jp Thru_Stargate    

;; page 0F, entire page is a string table.

0000:008E 111000 ld de,0010  ; Bank 16 (40000)
0000:0091 C3AE19 jp Thru_Stargate    

          pg11
0000:0094 111100 ld de,0011  ; Bank 17 (44000)
0000:0097 C3AE19 jp Thru_Stargate    
0000:009A 111200 ld de,0012  ; Bank 18 (48000)
0000:009D C3AE19 jp Thru_Stargate    

          pg13
0000:00A0 111300 ld de,0013  ; Bank 19 (4C000)
0000:00A3 C3AE19 jp Thru_Stargate    

          pg14
0000:00A6 111400 ld de,0014  ; Bank 20 (50000)
0000:00A9 C3AE19 jp Thru_Stargate    

0000:00AC 111500 ld de,0015  ; Bank 21 (54000)
0000:00AF C3AE19 jp Thru_Stargate    

          pg16
0000:00B2 111600 ld de,0016  ; Bank 22 (58000)
0000:00B5 C3AE19 jp Thru_Stargate    

0000:00B8 111700 ld de,0017  ; Bank 23 (5C000)
0000:00BB C3AE19 jp Thru_Stargate    
0000:00BE 111800 ld de,0018  ; Bank 24 (60000)
0000:00C1 C3AE19 jp Thru_Stargate    

          pg19
0000:00C4 111900 ld de,0019  ; Bank 25 (64000)
0000:00C7 C3AE19 jp Thru_Stargate    

0000:00CA 111A00 ld de,001A  ; Bank 26 (68000)
0000:00CD C3AE19 jp Thru_Stargate    

          pg1B
0000:00D0 111B00 ld de,001B  ; Bank 27 (6C000)
0000:00D3 C3AE19 jp Thru_Stargate    

          pg1C
0000:00D6 111C00 ld de,001C  ; Bank 28 (70000)
0000:00D9 C3AE19 jp Thru_Stargate    

;; pages #1D-2C (29-44) do not have handles, so they might not be code
;; like these others are???  Could be data???  OR compressed code???
;; OR, maybe just code accessed as "files"???????
;;
;;                                  ;; page #2D accessed via RST #30 ????
;;
0000:00DC 112E00 ld de,002E  ; Bank 46 (B8000)
0000:00DF C3AE19 jp Thru_Stargate    
0000:00E2 112F00 ld de,002F  ; Bank 47 (BC000)
0000:00E5 C3AE19 jp Thru_Stargate    

          pg30
0000:00E8 113000 ld de,0030  ; Bank 48 (C0000)
0000:00EB C3AE19 jp Thru_Stargate    

          pg31
0000:00EE 113100 ld de,0031  ; Bank 49 (C4000)
0000:00F1 C3AE19 jp Thru_Stargate    

          pg32
0000:00F4 113200 ld de,0032  ; Bank 50 (C8000)
0000:00F7 C3AE19 jp Thru_Stargate    

          pg33
0000:00FA 113300 ld de,0033  ; Bank 51 (CC000)
0000:00FD C3AE19 jp Thru_Stargate    

;; page #34 thru #3F, no handles





          HL=0?
0000:0100 7C     ld a,h      
0000:0101 B5     or l        
0000:0102 2817   jr z,011B   ; HL=0? Return 1
0000:0104 1808   jr 010E     ; Else return 0

          HL=DE?
0000:0106 7D     ld a,l      ; HL=DE? -> Return 1
0000:0107 93     sub e      
0000:0108 2004   jr nz,010E  ;;they're different, ret 0, false
0000:010A 7C     ld a,h      
0000:010B 92     sub d      
0000:010C 280D   jr z,011B   ;; they're the same, ret 1 , true
0000:010E 210000 ld hl,0000  ; Else return 0 ;;false
0000:0111 AF     xor a      
0000:0112 C9     ret        

          HL<>DE?
0000:0113 7D     ld a,l      
0000:0114 93     sub e      
0000:0115 2004   jr nz,011B  ;; different, ret 1, true
0000:0117 7C     ld a,h      
0000:0118 92     sub d      
0000:0119 28F3   jr z,010E   ;; Same, ret 0, false
0000:011B 210100 ld hl,0001  
0000:011E 7D     ld a,l      
0000:011F B4     or h        
0000:0120 C9     ret        

;; The next four routines are just compares of signed 2's complement values.
;; In 2's comp, neg values look bigger to simple compare, so you have to compensate.
;; If both are neg, no problem.  If only one is neg, compare will give wrong answer.
;; But!  It is even easier, coz the negative value is always the lowest!

          HL<=DE?
0000:0121 EB     ex de,hl    ;;swap 'em, and fall thru to opposite test

          HL>=DE?
0000:0122 7C     ld a,h      
0000:0123 AA     xor d      
0000:0124 FA3401 jp m,0134   ;; plan b, if signs not same.
0000:0127 7D     ld a,l      
0000:0128 93     sub e      
0000:0129 7C     ld a,h      
0000:012A 9A     sbc a,d     ;;hl - de ;; if de > hl, cy = 1 ;; if de <= hl, cy = 0
0000:012B 3F     ccf         ; Kinda nullifies the above ops, eh?
;;                            ;; I thought same, then I figured it out, it's
;;                            ;; complement, not clear! (lousy mnemonic!!!)
0000:012C 3E00   ld a,00     ;;NOW, if de <= hl, cy = 1
0000:012E CE00   adc a,00    ;;now, A = 1 if de <= hl
0000:0130 6F     ld l,a      ; Return 0  ;; unh unh, ret's 1 if de <= hl
0000:0131 2600   ld h,00    
0000:0133 C9     ret        
0000:0134 7A     ld a,d      ;; signs different, negative one is lowest.
0000:0135 07     rlca        
0000:0136 E601   and 01      
0000:0138 6F     ld l,a      ;; result = sign bit of DE
0000:0139 2600   ld h,00     ;; true, if DE lower
0000:013B C9     ret        

          HL>DE?   ;;  (ret 1 if hl>de)
0000:013C EB     ex de,hl    ;; swap 'em, and fall thru to opposite test

          HL<DE?   ;; (ret 1 if hl<de)
0000:013D 7C     ld a,h      
0000:013E AA     xor d      
0000:013F FA4E01 jp m,014E   ;; plan b, if signs not same.
;; here if signs same
0000:0142 7D     ld a,l      ;; HL - DE
0000:0143 93     sub e      
0000:0144 7C     ld a,h      
0000:0145 9A     sbc a,d     ;; hl - de,  if de > hl, cy = 1   (NOT complemented this time)
0000:0146 3E00   ld a,00    
0000:0148 CE00   adc a,00    ;; A = cy,   if DE > HL, then A = 1
0000:014A 6F     ld l,a      
0000:014B 2600   ld h,00     ;; HL = A,   if DE > HL, then Hl = 1
0000:014D C9     ret        
;; here if signs not same
0000:014E 7C     ld a,h      ;;signs different, negative one is lowest.
0000:014F 07     rlca        
0000:0150 E601   and 01      
0000:0152 6F     ld l,a      ;; result = sign bit of HL
0000:0153 2600   ld h,00     ;; true, if DE lower
0000:0155 C9     ret        

          HL=-HL   ;; 2's complement
0000:0156 7D     ld a,l      
0000:0157 2F     cpl        
0000:0158 6F     ld l,a      
0000:0159 7C     ld a,h      
0000:015A 2F     cpl        
0000:015B 67     ld h,a      
0000:015C 23     inc hl      
0000:015D 7D     ld a,l      ;;set flags
0000:015E B4     or h        
0000:015F C9     ret        

          HL=DE-HL   ;; (subtract without carry)
0000:0160 EB     ex de,hl    

          HL=HL-DE   ;; (subtract without carry)
0000:0161 7D     ld a,l      
0000:0162 93     sub e      
0000:0163 6F     ld l,a      
0000:0164 7C     ld a,h      
0000:0165 9A     sbc a,d    
0000:0166 67     ld h,a      
0000:0167 B5     or l        
0000:0168 C9     ret        


;; Case statement I think. (switch in C)
;; scans inline data for match with hl, and jumps to the address
;; paired with match, or last address when no match.
;;***************** calls to #0169 have inline parameters.*******************
          switch
0000:0169 EB     ex de,hl    ;; save hl in de
0000:016A E1     pop hl      ;; HL = return address (its pointing to inline params)
0000:016B C5     push bc     ;; save BC
0000:016C 42     ld b,d      ;; BC = DE [saved hl]
0000:016D 4B     ld c,e      
0000:016E 5E     ld e,(hl)   ;; Pickup first inline parameter  (num of cases)
0000:016F 23     inc hl      
0000:0170 56     ld d,(hl)  
;; loop
0000:0171 1B     dec de      ;; decrement num
0000:0172 7A     ld a,d      
0000:0173 B7     or a        
0000:0174 FA8601 jp m,0186   ;; if num negative, jump out of loop.
0000:0177 23     inc hl      ;; compare next 2 inline bytes to bc (bc is calling hl value)
0000:0178 79     ld a,c      
0000:0179 BE     cp (hl)    
0000:017A 2805   jr z,0181   ;; jump if c matches
0000:017C 23     inc hl      ;; c didn't match, skip 2nd byte of pair
;;
0000:017D 23     inc hl      ;; skip 2 more bytes, must be groups of 4.
0000:017E 23     inc hl      
0000:017F 18F0   jr 0171     ;; goback, jack, doitagain
;;
0000:0181 23     inc hl      ;; c matched, how bout b?
0000:0182 78     ld a,b      
0000:0183 BE     cp (hl)    
0000:0184 20F7   jr nz,017D  ;; loop if not a match
;;
0000:0186 23     inc hl      ;; HL = (pointer)  ;  matched, or end of data.
0000:0187 7E     ld a,(hl)  
0000:0188 23     inc hl      
0000:0189 66     ld h,(hl)  
0000:018A 6F     ld l,a      
0000:018B C1     pop bc      ;; restore bc
0000:018C E9     jp (hl)     ;; jump to where the pointer points.



;; The next four routines are unsigned compares.
          DE>=HL?
0000:018D EB     ex de,hl    

          HL>=DE?
0000:018E 7D     ld a,l      ;; HL - DE
0000:018F 93     sub e      
0000:0190 7C     ld a,h      
0000:0191 9A     sbc a,d     ;; if  HL >= DE , carry = 0
0000:0192 3E00   ld a,00    
0000:0194 3F     ccf         ;; if  HL >= DE , carry = 1
0000:0195 CE00   adc a,00    ;; if  HL >= DE , carry A = 1 , true
0000:0197 6F     ld l,a      
0000:0198 2600   ld h,00    
0000:019A C9     ret        

          DE<HL?
0000:019B EB     ex de,hl    

          HL<DE?
0000:019C 7D     ld a,l      ;; HL - DE
0000:019D 93     sub e      
0000:019E 7C     ld a,h      
0000:019F 9A     sbc a,d     ;; if  HL < DE , carry = 1
0000:01A0 3E00   ld a,00    
0000:01A2 CE00   adc a,00    ;; if  HL < DE , A = 1
0000:01A4 6F     ld l,a      
0000:01A5 2600   ld h,00    
0000:01A7 C9     ret        




;; the params seem bacwards!!!  I don't have time to check it, but
;; it seems there are several places where this would make more sense
;; as "hl=hl/de".  beware, if it seems backwadrs to you too, it prob is!!!!
;;
;; signed divide, de = de / hl , hl = remainder.
de=de/hl,hl=remndr???orisit_hl=hl/de???
;;
;; ok, maybe it is really hl = de mod hl????  but there is another (just a few
;; lines below, at #01bd) function that is almost same as this one, except
;; that other one uses just the sign of de for the sign of result.  This one
;; right here uses sign of both de & hl to determine sign of result.  But
;; since hl is what is used by the callers, I guess we will call this
;; function "remainder".
;;
          hl=remainder_of_de/hl
0000:01A8 7A     ld a,d      ;; save sign of result
0000:01A9 AC     xor h      
0000:01AA F5     push af    
;;
0000:01AB CDCA01 call de=abs_de/abs_hl, hl=rem   ;; divide
0000:01AE EB     ex de,hl    
;;
0000:01AF F1     pop af      
0000:01B0 FA5601 jp m,HL=-HL   ;; negate hl if needed
0000:01B3 7D     ld a,l      
0000:01B4 B4     or h        
0000:01B5 C9     ret        




;; modulus???  +hl = +de / +hl , de = remainder
de=remndr,hl=de/hl,unsigned
;;
;; OK, the callers of this are also interested in the value of HL on return.
;; And due to the "ex de,hl" after the divide, this one is a divide function.
;;
          hl=de/hl
0000:01B6 CDE001 call de=de/hl,hl=rem,unsigned   ;; divide positives
;;
;; this time the relevant register is de
0000:01B9 EB     ex de,hl    
0000:01BA 7D     ld a,l      
0000:01BB B4     or h        
0000:01BC C9     ret        



;; I think this is really mod, and not divide,
;; coz hl is what is used by callers
;;
          hl=de_mod_hl
;;
de = +-_de/abs_hl
;; signed divide by positive,  de = de / +hl
0000:01BD 7A     ld a,d      ;; sign of result determined by de only???
0000:01BE F5     push af    
0000:01BF CDCA01 call de=abs_de/abs_hl, hl=rem   ;; divide abs values
0000:01C2 F1     pop af      
0000:01C3 B7     or a        
0000:01C4 FA5601 jp m,HL=-HL   ;; negate result if needed   (if calling de was neg)
0000:01C7 7C     ld a,h      
0000:01C8 B5     or l        
0000:01C9 C9     ret        




          de=abs_de/abs_hl, hl=rem
;; divide absolute values,  de = abs de  /  abs hl , hl = remainder.
0000:01CA 7C     ld a,h      ;; hl = absolute value of hl
0000:01CB B7     or a        
0000:01CC F2D501 jp p,01D5   ;; jump if HL positive
0000:01CF 2F     cpl        
0000:01D0 67     ld h,a      
0000:01D1 7D     ld a,l      
0000:01D2 2F     cpl        
0000:01D3 6F     ld l,a      
0000:01D4 23     inc hl      ;; else 2's complement of HL
;;
0000:01D5 7A     ld a,d      ;; de = abs val of de
0000:01D6 B7     or a        
0000:01D7 F2E001 jp p,de=de/hl,hl=rem,unsigned   ;; jump if DE positive
0000:01DA 2F     cpl        
0000:01DB 57     ld d,a      
0000:01DC 7B     ld a,e      
0000:01DD 2F     cpl        
0000:01DE 5F     ld e,a      
0000:01DF 13     inc de      ;; else 2's complement of DE




;; unsigned divide, +de = +de / +hl , hl = remainder.
          de=de/hl,hl=rem,unsigned
0000:01E0 C5     push bc    
0000:01E1 4D     ld c,l      ;; put hl in bc for call to actual mult
0000:01E2 44     ld b,h      
0000:01E3 210000 ld hl,0000  ;; HL = 0
0000:01E6 CDED01 call 01ED  
0000:01E9 C1     pop bc      
0000:01EA 7D     ld a,l      
0000:01EB B4     or h        
0000:01EC C9     ret        




;; unsigned divide.  de = de / bc , hl = remainder.
;; I am not sure this is right.  might have hl & de reversed?????????
;; If so, then the other 16 bit divide funcs that use this are backwards too!!!
;; I supose the easiest way to verify these is to write some test code...
;;
0000:01ED 79     ld a,c      ;; 2's complement BC
0000:01EE 2F     cpl        
0000:01EF 4F     ld c,a      
0000:01F0 78     ld a,b      
0000:01F1 2F     cpl        
0000:01F2 47     ld b,a      
0000:01F3 03     inc bc      
;;
;;
0000:01F4 3E10   ld a,10     ;; Do this loop sixteen times
;;
;; loop
0000:01F6 29     add hl,hl   ;; shift HLDE 1 bit left
0000:01F7 EB     ex de,hl    
0000:01F8 29     add hl,hl  
0000:01F9 EB     ex de,hl    
0000:01FA 3001   jr nc,01FD  ;; if shift  of de produced a carry ...
0000:01FC 2C     inc l       ;;  ... put it in HL
;;
0000:01FD 09     add hl,bc   ;; HL = HL + BC  (bc is neg, so effectively a subtract, so cy is a borrow???)
0000:01FE 380C   jr c,020C   ;; if carry, put it in DE, and loop
;;
0000:0200 F5     push af    
0000:0201 7D     ld a,l      ;; hl = hl - bc  (since bc is neg, this is adding it back in if above borrowed???)
0000:0202 91     sub c      
0000:0203 6F     ld l,a      
0000:0204 7C     ld a,h      
0000:0205 98     sbc a,b    
0000:0206 67     ld h,a      
0000:0207 F1     pop af      
0000:0208 3D     dec a      
0000:0209 20EB   jr nz,01F6  ;; do the above loop sixteen times
;;
0000:020B C9     ret        
;;
0000:020C 1C     inc e       ;; this is shifting in a 1 (or changing the shifted in 0 to a 1)
0000:020D 3D     dec a       ;; loop index                                                      
0000:020E 20E6   jr nz,01F6  
;;
0000:0210 C9     ret        





;;** These comments refer to addresses in v2.54.  In 2.53yr the addresses are
;;** offset by 1 byte from where they are in 2.54.
;;** In 2.53yr, "X" is at #E613, and "Y" is at #E61B.
;; The next several routines handle long integer variables (32 bit).
;; They use the the variable #e614, e618, and e61c instead of cpu registers.
;; (versions other than 2.54 use different addresses.)
;; Sorta like a calculator for the compiler, these vars are used all over the place, so much that I got tired of
;; typing the addresses, and used "first" for #E614, and "second" for #E61C in lots of my comments to CALLs to
;; these functions (also "X" & "Y", when I got tired of typing "first" & "second";  I think x & y are better, but
;; I didn't go change the first & seconds yet...).  E618 is not named, & seldom used (just mult & div???).
;; I supose they could really just be two 64 bit vars, with E618 the high part of E614.


          load_Y_imed   ;; ************Has 4 bytes inline data ***
0000:0211 D1     pop de      ;; get return address
0000:0212 210400 ld hl,0004  ;; add 4 and put back on stack, skipping inline data
0000:0215 19     add hl,de  
0000:0216 E5     push hl    
0000:0217 EB     ex de,hl    ;; hl points at inline parameter, fall thru to next


          load_Y_hl^
0000:0218 111BE6 ld de,Y     ;; destination for 4 bytes pointed by hl
0000:021B 180A   jr 0227    


          Load_X_imed   ;; ************Has 4 bytes inline data ***
0000:021D D1     pop de      ;; DE = ret addr (points at inline long)
0000:021E 210400 ld hl,0004  
0000:0221 19     add hl,de  
0000:0222 E5     push hl     ;; push ret addr + 4 (skip inline when returning)
0000:0223 EB     ex de,hl    ;; hl points at inline, fall into next


          load_X_hl^
0000:0224 1113E6 ld de,X     ;; de = var e614
0000:0227 C5     push bc     ;; move 4 bytes from (hl) to (de), and return
0000:0228 010400 ld bc,0004  
0000:022B EDB0   ldir        
0000:022D C1     pop bc      
0000:022E C9     ret        


          save_X_hl^
0000:022F 1113E6 ld de,X     ;; DE = E614
0000:0232 EB     ex de,hl    ;; DE=HL , HL=E614
0000:0233 C5     push bc    
0000:0234 010400 ld bc,0004  
0000:0237 EDB0   ldir        ;; copy 4 bytes from E614 to somewhere
0000:0239 C1     pop bc      
0000:023A EB     ex de,hl    
0000:023B C9     ret        


          push_X
0000:023C D1     pop de      ;; return address in DE.
0000:023D 2116E6 ld hl,E616  ;; why?  next LD overwrites hl
0000:0240 2A15E6 ld hl,(E615);; push var E614
0000:0243 E5     push hl    
0000:0244 2A13E6 ld hl,(X)  
0000:0247 E5     push hl    
0000:0248 EB     ex de,hl    ;; hl is now return address
0000:0249 E9     jp (hl)     ;; this is the return!  ook!!!


          pop_Y
0000:024A D1     pop de      
0000:024B E1     pop hl      
0000:024C 221BE6 ld (Y),hl  
0000:024F E1     pop hl      
0000:0250 221DE6 ld (E61D),hl
0000:0253 EB     ex de,hl    
0000:0254 E9     jp (hl)    


          swap_X_Y
0000:0255 2A1BE6 ld hl,(Y)  
0000:0258 EB     ex de,hl    
0000:0259 2A13E6 ld hl,(X)  
0000:025C 221BE6 ld (Y),hl  
0000:025F EB     ex de,hl    
0000:0260 2213E6 ld (X),hl  
0000:0263 2A1DE6 ld hl,(E61D)
0000:0266 EB     ex de,hl    
0000:0267 2A15E6 ld hl,(E615)
0000:026A 221DE6 ld (E61D),hl
0000:026D EB     ex de,hl    
0000:026E 2215E6 ld (E615),hl
0000:0271 C9     ret        

          negate_X
0000:0272 2113E6 ld hl,X     ;; point hl at var e614, and fall into negate below.

          negate_HL^
0000:0275 AF     xor a       ;; clear flags
0000:0276 1604   ld d,04     ;; do 4 bytes
0000:0278 3E00   ld a,00     ;; top of loop, a=0
0000:027A 9E     sbc a,(hl)  ;; a = 0 minus a byte of something
0000:027B 77     ld (hl),a   ;; something = a
0000:027C 23     inc hl      ;; next byte
0000:027D 15     dec d      
0000:027E 20F8   jr nz,0278  
0000:0280 C9     ret        

          X=0?
0000:0281 2113E6 ld hl,X    
0000:0284 1604   ld d,04    
0000:0286 7E     ld a,(hl)  
0000:0287 B7     or a        
0000:0288 C29004 jp nz,0490  ;; ret 1
0000:028B 23     inc hl      
0000:028C 15     dec d      
0000:028D 20F7   jr nz,0286  ;;  (not cpu detection, even if it looks like it!  :^)
0000:028F C38604 jp 0486     ;; ret 0 when X = 0

;; Compare "X" to "Y" (#e614 to #e61c)
;; The next 4 chunks of code are related.  first two exits, next two entry pts., then one more exit.
;; the loop does the compare, and exits thru  one of top two exits if it finds a difference, exit val tells which
;; was higher.  If the same, it exits thru the third exit at bottom
0000:0292 AF     xor a       ;; return -1
0000:0293 3D     dec a      
0000:0294 C1     pop bc      
0000:0295 C9     ret        

0000:0296 AF     xor a       ;; return +1
0000:0297 3C     inc a      
0000:0298 C1     pop bc      
0000:0299 C9     ret        

;; This is like the next at 02AD, but here we invert just the hi order bit of
;; both X and Y before comparing them????  What does that mean????
;; is this comparing -X to -Y????   (whats up with this???????)
;;
0000:029A C5     push bc     ;; first entry point.  same as second, except high bit of 1st byte of both inverted.
0000:029B 1116E6 ld de,E616  ;; X                    -5 fb -> 7b
0000:029E 211EE6 ld hl,E61E  ;; Y                     4 04 -> 84
0000:02A1 7E     ld a,(hl)   ;;                      -9 f7    f7
0000:02A2 EE80   xor 80      
0000:02A4 4F     ld c,a      ;; c = Y xor #80
0000:02A5 1A     ld a,(de)  
0000:02A6 EE80   xor 80      ;; a = X xor #80
0000:02A8 B9     cp c        ;; (X xor #80) - (Y xor #80)
0000:02A9 0604   ld b,04    
0000:02AB 180B   jr 02B8     ;; sneak into second to finish.

;; compare X to Y   -1 if Y bigger, 0 if same, +1 if X bigger
0000:02AD C5     push bc     ;; second entry point
0000:02AE 1116E6 ld de,E616  ;; pt de at high byte of X
0000:02B1 211EE6 ld hl,E61E  ;; pt hl at high byte of Y
0000:02B4 0604   ld b,04    
;;
0000:02B6 1A     ld a,(de)   ;; do this loop 4 times
0000:02B7 BE     cp (hl)     ;; (de) - (hl)   X-Y
0000:02B8 38D8   jr c,0292   ;; ret -1 ? (hl) Y bigger
0000:02BA 20DA   jr nz,0296  ;; ret +1 ? (de) X bigger
0000:02BC 2B     dec hl      
0000:02BD 1B     dec de      
0000:02BE 10F6   djnz 02B6   ;; loop 3 more times
;;
0000:02C0 AF     xor a       ;; ret 0, if both the same
0000:02C1 C1     pop bc      
0000:02C2 C9     ret        

          X=X+Y
0000:02C3 C5     push bc    
0000:02C4 1113E6 ld de,X    
0000:02C7 211BE6 ld hl,Y    
0000:02CA AF     xor a      
0000:02CB 0604   ld b,04    
0000:02CD 1A     ld a,(de)  
0000:02CE 8E     adc a,(hl)  
0000:02CF 12     ld (de),a  
0000:02D0 23     inc hl      
0000:02D1 13     inc de      
0000:02D2 10F9   djnz 02CD  
0000:02D4 C1     pop bc      
0000:02D5 C9     ret        

; Subtract long
; (E614)=(E614)-(E61C)
          X=X-Y
0000:02D6 C5     push bc    
0000:02D7 1113E6 ld de,X    
0000:02DA 211BE6 ld hl,Y    
0000:02DD AF     xor a      
0000:02DE 0604   ld b,04     ; A=0, B=4, carry = 0
0000:02E0 1A     ld a,(de)   ; (LONG) (E614)-(E61C)
0000:02E1 9E     sbc a,(hl)  
0000:02E2 12     ld (de),a  
0000:02E3 23     inc hl      
0000:02E4 13     inc de      
0000:02E5 10F9   djnz 02E0   ; Loop 4x
0000:02E7 C1     pop bc      
0000:02E8 C9     ret        

          X=X_AND_Y
0000:02E9 C5     push bc    
0000:02EA 1113E6 ld de,X    
0000:02ED 211BE6 ld hl,Y    
0000:02F0 0604   ld b,04    
0000:02F2 1A     ld a,(de)  
0000:02F3 A6     and (hl)    
0000:02F4 12     ld (de),a  
0000:02F5 23     inc hl      
0000:02F6 13     inc de      
0000:02F7 10F9   djnz 02F2  
0000:02F9 C1     pop bc      
0000:02FA C9     ret        

          X=X_OR_Y
0000:02FB C5     push bc    
0000:02FC 1113E6 ld de,X    
0000:02FF 211BE6 ld hl,Y    
0000:0302 0604   ld b,04    
0000:0304 1A     ld a,(de)  
0000:0305 B6     or (hl)    
0000:0306 12     ld (de),a  
0000:0307 23     inc hl      
0000:0308 13     inc de      
0000:0309 10F9   djnz 0304  
0000:030B C1     pop bc      
0000:030C C9     ret        

          X=X_XOR_Y
0000:030D C5     push bc    
0000:030E 1113E6 ld de,X    
0000:0311 211BE6 ld hl,Y    
0000:0314 0604   ld b,04    
0000:0316 1A     ld a,(de)  
0000:0317 AE     xor (hl)    
0000:0318 12     ld (de),a  
0000:0319 23     inc hl      
0000:031A 13     inc de      
0000:031B 10F9   djnz 0316  
0000:031D C1     pop bc      
0000:031E C9     ret        

          complement_X
0000:031F 2113E6 ld hl,X    
0000:0322 1604   ld d,04    
0000:0324 7E     ld a,(hl)  
0000:0325 2F     cpl        
0000:0326 77     ld (hl),a  
0000:0327 23     inc hl      
0000:0328 15     dec d      
0000:0329 20F9   jr nz,0324  
0000:032B C9     ret        


          X=X_shl_L   ;; shift var X left hl bits.
0000:032C 7D     ld a,l      ;; mod 64 of L (don't ever need to shift more than 32, but easier to limit to 63???)
0000:032D E63F   and 3F      ;; this is not really what it does.  what if L is #40?  Won't shift at all!
0000:032F C8     ret z       ;; this would make sense for rotate of 32 bit value.  (so would mod 32)
0000:0330 2A13E6 ld hl,(X)   ;; HLDE = var E614
0000:0333 EB     ex de,hl    
0000:0334 2A15E6 ld hl,(E615);; hl is high order byte
0000:0337 29     add hl,hl   ;; shift 1 bit
0000:0338 EB     ex de,hl    ;; hl is now  low order byte
0000:0339 29     add hl,hl   ;; (cy is for low byte)
0000:033A EB     ex de,hl    ;; hl is now high order byte
0000:033B 3001   jr nc,033E  ;; did low byte carry?
0000:033D 2C     inc l       ;; put cy in high byte
0000:033E 3D     dec a       ;; loop index
0000:033F 20F6   jr nz,0337  
0000:0341 2215E6 ld (E615),hl
0000:0344 EB     ex de,hl    
0000:0345 2213E6 ld (X),hl  
0000:0348 C9     ret        


          X=X_srl_L   ;; shift var X right hl bits, logical
0000:0349 AF     xor a       ;; put 0 in carry
0000:034A 1804   jr 0350    


          X=X_sra_L   ;; shift var X right hl bits, arithmetic
0000:034C 3A16E6 ld a,(E616) ;; put sign bit in carry, for sign extension
0000:034F 17     rla        
;;
;; srl jumps in here
0000:0350 F5     push af     ;; save carry bit
0000:0351 7D     ld a,l      
0000:0352 E63F   and 3F      ;; limit number of shifts???  this is not right!!!
0000:0354 2812   jr z,0368   ;; what if hl > 64???  result should be 0!!!!!!
;;
0000:0356 57     ld d,a      ;; d is number of bits
0000:0357 2116E6 ld hl,E616  
;;
;; bitloop
0000:035A 1E04   ld e,04     ;; shift 4 bytes
0000:035C F1     pop af      ;; restore carry bit
0000:035D F5     push af    
;;
;; byteloop
0000:035E 7E     ld a,(hl)  
0000:035F 1F     rra        
0000:0360 77     ld (hl),a  
0000:0361 2B     dec hl      
0000:0362 1D     dec e      
0000:0363 20F9   jr nz,035E  ;; loop for all 4 bytes
;;
0000:0365 15     dec d      
0000:0366 20EF   jr nz,0357  ;; bitloop
;;
0000:0368 F1     pop af      
0000:0369 C9     ret        


          de^=abs(de^)
0000:036A 210300 ld hl,0003  ;; point at high byte of what de points at, test sign
0000:036D 19     add hl,de  
0000:036E 4E     ld c,(hl)   ;; c = (de + 3)
0000:036F 79     ld a,c      ;; a = c
0000:0370 B7     or a        ;; set flags
0000:0371 F0     ret p       ;; return if a positive
0000:0372 EB     ex de,hl    ;; point hl where de points
0000:0373 C37502 jp negate_HL^     ;; negate whatever hl points to (4 bytes)

;; signed longint multiply?  or divide???
0000:0376 C5     push bc    
0000:0377 1113E6 ld de,X    
0000:037A CD6A03 call de^=abs(de^)   ;; abs val e614
0000:037D C5     push bc    
0000:037E 111BE6 ld de,Y    
0000:0381 CD6A03 call de^=abs(de^)   ;; abs val e61c
0000:0384 79     ld a,c      
0000:0385 C1     pop bc      
0000:0386 A9     xor c       ;; xor high bytes before abs vals
0000:0387 F5     push af     ;; save sign
0000:0388 CDD203 call divide????   ;; multiply the positive values
0000:038B F1     pop af      ;; retrieve sign
0000:038C C1     pop bc      
0000:038D FA7202 jp m,negate_X   ;; negate e614 (result of multiply) if needed
0000:0390 C9     ret        

;; multiply, signed by positive value????????  var e614 = var e614  x  var e61c  or divide?????
0000:0391 C5     push bc    
0000:0392 1113E6 ld de,X    
0000:0395 CD6A03 call de^=abs(de^)   ;; abs value of var e614
0000:0398 79     ld a,c      
0000:0399 B7     or a        
0000:039A F5     push af     ;; save sign of e614
0000:039B 111BE6 ld de,Y    
0000:039E CD6A03 call de^=abs(de^)   ;; abs value of var e61c.  why no sign saved???
0000:03A1 CDD203 call divide????   ;; multiply?
0000:03A4 1117E6 ld de,E617  ;; move var e618 to var e614 (move result to e614)
0000:03A7 2113E6 ld hl,X    
0000:03AA 0604   ld b,04    
0000:03AC 1A     ld a,(de)  
0000:03AD 77     ld (hl),a  
0000:03AE 13     inc de      
0000:03AF 23     inc hl      
0000:03B0 10FA   djnz 03AC  
0000:03B2 F1     pop af      
0000:03B3 C1     pop bc      
0000:03B4 FA7202 jp m,negate_X   ;; negate var e614
0000:03B7 C9     ret        

divide???? preserving bc
          X=X/Y
0000:03B8 C5     push bc    
0000:03B9 CDD203 call divide????  
0000:03BC C1     pop bc      
0000:03BD C9     ret        

;; modulus?????
0000:03BE C5     push bc    
0000:03BF CDD203 call divide????  
0000:03C2 1117E6 ld de,E617  
0000:03C5 2113E6 ld hl,X    
0000:03C8 0604   ld b,04    
;;
0000:03CA 1A     ld a,(de)  
0000:03CB 77     ld (hl),a  
0000:03CC 13     inc de      
0000:03CD 23     inc hl      
0000:03CE 10FA   djnz 03CA  
0000:03D0 C1     pop bc      
0000:03D1 C9     ret        


;; only used by other pg #00 routines
          divide????
0000:03D2 0604   ld b,04     ;; zero var between X & Y
0000:03D4 2117E6 ld hl,E617  ;; hi 4 bytes of 8 byte X????
0000:03D7 AF     xor a      
0000:03D8 77     ld (hl),a  
0000:03D9 23     inc hl      
0000:03DA 10FC   djnz 03D8   ;; loop, zero 4 bytes of result.
;;
0000:03DC 3E20   ld a,20    
0000:03DE F5     push af     ;; big loop, do #20 x
;;
0000:03DF 2113E6 ld hl,X     ;; shift 8 byte "X" left 1 bit
0000:03E2 0608   ld b,08    
0000:03E4 B7     or a        ;; clear carry flag
;;
0000:03E5 7E     ld a,(hl)  
0000:03E6 8F     adc a,a     ;; shift left 1 bit
0000:03E7 77     ld (hl),a  
0000:03E8 23     inc hl      
0000:03E9 10FA   djnz 03E5   ;; loop, shift all 8 bytes 1 bit each
;;
0000:03EB 9F     sbc a,a     ;; did shift create a carry?
0000:03EC E601   and 01      ;;
0000:03EE 4F     ld c,a      ;; c = +1 if carry, 0 if not.
;;
0000:03EF 0604   ld b,04     ;; subtract var e61c from var e618
0000:03F1 1117E6 ld de,E617  
0000:03F4 211BE6 ld hl,Y    
0000:03F7 B7     or a        
0000:03F8 1A     ld a,(de)  
0000:03F9 9E     sbc a,(hl)  
0000:03FA 12     ld (de),a  
0000:03FB 13     inc de      
0000:03FC 23     inc hl      
0000:03FD 10F9   djnz 03F8  
;;
0000:03FF 79     ld a,c      ;; restore a to 1 if we saved a carry (on line 03ee)
0000:0400 DE00   sbc a,00    ;; if subtract loop borrowed, cancel out shift carry!
0000:0402 2009   jr nz,040D  ;; bottomloop if borrow or carry (but not both)
;;
0000:0404 2113E6 ld hl,X     ;; increment var e614.  this is really shifting in a 1
0000:0407 34     inc (hl)    ;; (low bit is always 0 after shift, inc never makes carry.)
;;
0000:0408 F1     pop af      
0000:0409 3D     dec a      
0000:040A 20D2   jr nz,03DE  ;; big loop
0000:040C C9     ret        
;;
;; bottom loop
0000:040D F1     pop af      ;; dec count.  done yet?
0000:040E 3D     dec a      
0000:040F 2826   jr z,0437   ;; add var e61c to var e618,  and return
0000:0411 F5     push af     ;; not done yet
;;
0000:0412 2113E6 ld hl,X     ;; shift vars e614,e618 left 1 bit
0000:0415 0608   ld b,08    
0000:0417 B7     or a        ;; clear carry flag
0000:0418 7E     ld a,(hl)  
0000:0419 8F     adc a,a    
0000:041A 77     ld (hl),a  
0000:041B 23     inc hl      
0000:041C 10FA   djnz 0418  
;;
0000:041E 9F     sbc a,a    
0000:041F 4F     ld c,a      ;; c = -1 if carry
;;
0000:0420 0604   ld b,04     ;; add var e61c to var e618
0000:0422 1117E6 ld de,E617  
0000:0425 211BE6 ld hl,Y    
0000:0428 B7     or a        
0000:0429 1A     ld a,(de)  
0000:042A 8E     adc a,(hl)  
0000:042B 12     ld (de),a  
0000:042C 13     inc de      
0000:042D 23     inc hl      
0000:042E 10F9   djnz 0429  
;;
0000:0430 79     ld a,c      ;; a = -1 if shift carried.
0000:0431 CE00   adc a,00    ;; if add loop caried, cancel out shift carry
0000:0433 20D8   jr nz,040D  ;; stay in bottom loop if not canceled
0000:0435 18CD   jr 0404     ;; back into top big loop (if both or neither carried)
;;
0000:0437 0604   ld b,04     ;; add var e61c to var e618,  and return
0000:0439 1117E6 ld de,E617  
0000:043C 211BE6 ld hl,Y    
0000:043F B7     or a        
0000:0440 1A     ld a,(de)  
0000:0441 8E     adc a,(hl)  
0000:0442 12     ld (de),a  
0000:0443 13     inc de      
0000:0444 23     inc hl      
0000:0445 10F9   djnz 0440  
0000:0447 C9     ret        


          X=X*Y   ;; HEY! this looks like a multiply like i remember!!  maybe the earlier WAS divide???????
0000:0448 C5     push bc    
0000:0449 2113E6 ld hl,X     ;; move operand to e618, and zero e614
0000:044C 0604   ld b,04    
0000:044E 1117E6 ld de,E617  
0000:0451 7E     ld a,(hl)  
0000:0452 12     ld (de),a  
0000:0453 3600   ld (hl),00  
0000:0455 23     inc hl      
0000:0456 13     inc de      
0000:0457 10F8   djnz 0451  
0000:0459 3E20   ld a,20     ;; do 32 bits
0000:045B F5     push af    
0000:045C 2113E6 ld hl,X     ;; shift vars e614,e618 left 1 bit
0000:045F 0608   ld b,08    
0000:0461 B7     or a        
0000:0462 7E     ld a,(hl)  
0000:0463 8F     adc a,a    
0000:0464 77     ld (hl),a  
0000:0465 23     inc hl      
0000:0466 05     dec b      
0000:0467 20F9   jr nz,0462  
0000:0469 3010   jr nc,047B  ;; skip if no carry from shift
0000:046B 0604   ld b,04     ;; add var e61c to var e614
0000:046D 1113E6 ld de,X    
0000:0470 211BE6 ld hl,Y    
0000:0473 B7     or a        
0000:0474 1A     ld a,(de)  
0000:0475 8E     adc a,(hl)  
0000:0476 12     ld (de),a  
0000:0477 13     inc de      
0000:0478 23     inc hl      
0000:0479 10F9   djnz 0474  
0000:047B F1     pop af      
0000:047C 3D     dec a      
0000:047D 20DC   jr nz,045B  
0000:047F C1     pop bc      
0000:0480 C9     ret        


;; calls to 029A & 02AD are complementay compares of vars e614 and e61c.
;; the following are the relational operators
0000:0481 CD9A02 call 029A  
0000:0484 280A   jr z,0490  

0000:0486 210000 ld hl,0000  ;; return 0
0000:0489 AF     xor a      
0000:048A C9     ret        

0000:048B CD9A02 call 029A  
0000:048E 28F6   jr z,0486  

0000:0490 210100 ld hl,0001  ;; return +1
0000:0493 AF     xor a      
0000:0494 3C     inc a      
0000:0495 C9     ret        

0000:0496 CD9A02 call 029A  
0000:0499 FA9004 jp m,0490  
0000:049C 18E8   jr 0486    

0000:049E CD9A02 call 029A  
0000:04A1 FA9004 jp m,0490  
0000:04A4 28EA   jr z,0490  
0000:04A6 18DE   jr 0486    

0000:04A8 CD9A02 call 029A  
0000:04AB FA8604 jp m,0486  
0000:04AE 18E0   jr 0490    

0000:04B0 CD9A02 call 029A  
0000:04B3 FA8604 jp m,0486  
0000:04B6 28CE   jr z,0486  
0000:04B8 18D6   jr 0490    


;; 02AD compares (E614) - (E61C) , returns  -1 if e61c bigger, 0 if same, +1 if e614 bigger
;; or, X - Y using shorterhand notation


          X<Y?
0000:04BA CDAD02 call 02AD  
0000:04BD FA9004 jp m,0490   ;; return +1  (true)
0000:04C0 18C4   jr 0486     ;; ret 0


          X<=Y?
0000:04C2 CDAD02 call 02AD  
0000:04C5 FA9004 jp m,0490   ;; return +1
0000:04C8 28C6   jr z,0490   ;; return +1
0000:04CA 18BA   jr 0486     ;; ret 0


          X>=Y?
0000:04CC CDAD02 call 02AD  
0000:04CF FA8604 jp m,0486   ;; ret 0
0000:04D2 18BC   jr 0490     ;; return +1


          X>Y?
0000:04D4 CDAD02 call 02AD  
0000:04D7 FA8604 jp m,0486   ;; ret 0
0000:04DA 28AA   jr z,0486   ;; ret 0
0000:04DC 18B2   jr 0490     ;; return +1


          X=hl_unsigned   ;; unsigned move 16 bit HL to 32 bit X
0000:04DE 2213E6 ld (X),hl  
0000:04E1 210000 ld hl,0000  
0000:04E4 2215E6 ld (E615),hl
0000:04E7 C9     ret        


          X=hl_signed   ;; sign extended HL to var X
0000:04E8 2213E6 ld (X),hl  
0000:04EB 7C     ld a,h      
0000:04EC B7     or a        
0000:04ED F2E104 jp p,04E1  
0000:04F0 21FFFF ld hl,FFFF  
0000:04F3 2215E6 ld (E615),hl
0000:04F6 C9     ret        


          hl=X
0000:04F7 2A13E6 ld hl,(X)  
0000:04FA C9     ret        


;; more 16 bit operations start here

          hl=hl*de   ;; 16 bit multiply   hl = hl x de
0000:04FB C5     push bc    
0000:04FC 44     ld b,h      ; BC=HL
0000:04FD 4D     ld c,l      
0000:04FE 210000 ld hl,0000  ; HL=0
0000:0501 3E10   ld a,10     ; A=0x10     ;; sixteen shift and add's
0000:0503 29     add hl,hl   ; Double HL  ;; shift hlde
0000:0504 EB     ex de,hl    
0000:0505 29     add hl,hl   ; Double DE
0000:0506 EB     ex de,hl    
0000:0507 3001   jr nc,050A  ; No overflow? -> 050A
0000:0509 09     add hl,bc   ; Else Add BC to HL
0000:050A 3D     dec a       ;
0000:050B 20F6   jr nz,0503  ; Loop 16x
0000:050D C1     pop bc      
0000:050E 7D     ld a,l      ; Return HL
0000:050F B4     or h        
0000:0510 C9     ret        


          hl=de_sra_hl   ;; shift right arithmatic
0000:0511 EB     ex de,hl    
0000:0512 7B     ld a,e      
0000:0513 E61F   and 1F      
0000:0515 5F     ld e,a      
0000:0516 281C   jr z,0534   ;; if Z, ret hl???
;;
0000:0518 7C     ld a,h      
0000:0519 B4     or h        
0000:051A F23E05 jp p,053E   ;; if positive, jump into shift right logical
;;
;; hl is negative
0000:051D 7C     ld a,h      
0000:051E 37     scf         ;; shift 1's in for sign extension
0000:051F 1F     rra        
0000:0520 67     ld h,a      
0000:0521 7D     ld a,l      
0000:0522 1F     rra        
0000:0523 6F     ld l,a      
0000:0524 1D     dec e      
0000:0525 20F6   jr nz,051D  
;;
0000:0527 B4     or h        
0000:0528 C9     ret        


          hl=de_shl_hl   ;; shift de left hl bits
0000:0529 EB     ex de,hl    
0000:052A 7B     ld a,e      
0000:052B E61F   and 1F      ;; suppress multiples of 32??? this is correct for rotate, but not for shift!!!
;;                                  ;; here a shift of 32, 64, etc will ret hl unshifted, it should ret ZERO!!!!!!
;;                                  ;; A shift of 33 will ret hl SHL 1, it should ret ZERO!!!!!!  Or am I too tired????
0000:052D 5F     ld e,a      
0000:052E 2804   jr z,0534   ;; if n is multiple of 32, ret hl unshifted??????
;;
0000:0530 29     add hl,hl   ;; shift left 1 bit
0000:0531 1D     dec e      
0000:0532 20FC   jr nz,0530  
;;
0000:0534 7D     ld a,l      
0000:0535 B4     or h        
0000:0536 C9     ret        


          hl=de_srl_hl   ;; HL = DE shifted right logical hl bits
0000:0537 EB     ex de,hl    ;;
0000:0538 7B     ld a,e      
0000:0539 E61F   and 1F      
0000:053B 5F     ld e,a      ;; e = e mod 32   (?????)
0000:053C 28F6   jr z,0534   ;; ret hl
0000:053E 7C     ld a,h      
0000:053F B7     or a        ;; clear cy
0000:0540 1F     rra        
0000:0541 67     ld h,a      
0000:0542 7D     ld a,l      
0000:0543 1F     rra        
0000:0544 6F     ld l,a      ;; shift hl right 1 bit
0000:0545 1D     dec e      
0000:0546 20F6   jr nz,053E  ;; shift hl right e bits
0000:0548 B4     or h        
0000:0549 C9     ret        


          hl=hl_and_de
0000:054A 7C     ld a,h      
0000:054B A2     and d      
0000:054C 67     ld h,a      
0000:054D 7D     ld a,l      
0000:054E A3     and e      
0000:054F 6F     ld l,a      
0000:0550 B4     or h        
0000:0551 C9     ret        


          hl=not_hl
0000:0552 7C     ld a,h      
0000:0553 2F     cpl        
0000:0554 67     ld h,a      
0000:0555 7D     ld a,l      
0000:0556 2F     cpl        
0000:0557 6F     ld l,a      
0000:0558 B4     or h        
0000:0559 C9     ret        


          hl=hl_or_de
0000:055A 7C     ld a,h      
0000:055B B2     or d        
0000:055C 67     ld h,a      
0000:055D 7D     ld a,l      
0000:055E B3     or e        
0000:055F 6F     ld l,a      
0000:0560 B4     or h        
0000:0561 C9     ret        


          hl=hl_xor_de
0000:0562 7C     ld a,h      
0000:0563 AA     xor d      
0000:0564 67     ld h,a      
0000:0565 7D     ld a,l      
0000:0566 AB     xor e      
0000:0567 6F     ld l,a      
0000:0568 B4     or h        
0000:0569 C9     ret        



          jump_to_hl   ;; Used for "calling" HL
0000:056A E9     jp (hl)     ;; part of following subroutine, and also used elsewhere to "call (hl)".  This is
                                   ;; why there is no call to the update code at c51c, aka 3:451c
;; I really dislike this syntax, it SHOULD say "JP  HL", coz (HL) should mean "grab the word that hl points at, and
;; then use that word as the address to jump to".  And that's not what it does.  It just jumps to the address in hl.
;; iow, the operation is really  "PC <-- HL" , NOT  "PC <-- (HL)"



;; LOCALIZE,  with indexes.  Whoever called here will be refered to as allocatee.
;; Reserve Negative DE bytes on stack.  Called from several other functions, to allocate space for local variables.
;; DE is negative, the 2's complement of the number of bytes needed for local vars, and it
;; adjusts stack pointer to lower address, (which is "higher" on the stack).
;; This is the c compiler allocating local variables.  Also saves registers bc, ix, iy.
;;
;; It seems that the params are (almost???) always 2 bytes ea.  But I named most of them in my comments by the offset
;; from the start of the params, so the first 2 byte param would consist of par0 & par1.  and the next would be
;; par2 & par3.  iow, the "real C code params" are par0, par2, par4, etc., and the odd pars are the hi byte of ea.
;;
;; I also have been calling the locals by offset from sp, and since there are 8 bytes pushed after allocating locals,
;; the first byte of locals is "sp0008", and last is "sp0008+n-1" (where n is number of local bytes).
;; And since there 4 bytes pushed before the locals, on top of the params, par0 = sp0008 + n + 4.
;; If it's not obvious, by sp0008 I mean sp plus 8.  There are probably lots of places where a param is named spxxxx,
;; and not parxx, just because I didn't calc where the locals stop, and params started.  (really a job for a
;; computer... heh heh.)
;;
;; Here's a picture of how I see it.  Might be upside down from how others see it, but I write top to bottom, so this
;; stack grows "down" in the diagram, toward lower memory addresses, which is the opposite of the code in this listing.

;; This is what the stack looks like for the callback:
;;
;;                     [~STACK~]  (bytes)
;; {higher addresses}  [~~~~~~~]
;;   sp+8+n+4+m-1 -->  [par m-1]    (1)
;;                     [  ...  ]    (?)
;;       sp+8+n+4 -->  [ par 0 ]    (1)
;;       sp+8+n+2 -->  [caller ]    (2)  where allocatee is supposed to return too when done, (we'll do it for them.)
;;(orig sp)sp+8+n -->  [c'bk/BC]    (2)  allocatee's callback add on entry, saved BC on callback to allocatee
;;     (sp+8+n-1) -->  [ Vn-1  ]    (1)  last local variable byte
;;                     [  ...  ]    (?)
;;         (sp+8) -->  [  V0   ]    (1)  first local variable byte, sp0008
;;         (sp+6) -->  [origSP ]    (2)  unadjusted SP value
;;         (sp+4) -->  [  IX   ]    (2)
;;         (sp+2) -->  [  IY   ]    (2)
;;   sp on/c'back -->  [cleanup]    (2)  addr of cleanup routine.  allocatee rets to cleanup, cleanup rets to caller.
;;  {lower addresses}  [~~~~~~~]
;;
;; n is number of bytes of local vars, m is number of bytes of parameters.
;;
;; My z80 Databook sez: dec sp BEFORE push, inc  AFTER  pop, ie. sp normaly points at data, not free space.
;;
;; On entry, DE is 2's comp of number of bytes for local vars needed by allocatee, and top of stk is callback address.
          localize
0000:056B E1     pop hl      ; HL = Return address ;;(callback point)
0000:056C C5     push bc     ; Save BC
0000:056D 44     ld b,h      ; BC = HL
0000:056E 4D     ld c,l      ;;bc = return address
0000:056F 210000 ld hl,0000  ;
0000:0572 39     add hl,sp   ;;hl = sp
0000:0573 EB     ex de,hl    ;;de = sp, hl = number of bytes (negative, add to stack pointer to make room)
0000:0574 39     add hl,sp   ; SP=HL=SP+DE  ;; adjust stack pointer, making room for local vars.
0000:0575 F9     ld sp,hl    
0000:0576 D5     push de     ; Save original SP on stack ;;in lieu of remembering how many bytes allocated.
0000:0577 DDE5   push ix     ; Save IX, IY
0000:0579 FDE5   push iy    
0000:057B 60     ld h,b      ; HL = Return address);;finish the sub that allocated the space.
0000:057C 69     ld l,c      
0000:057D CD6A05 call jump_to_hl   ; Call function that called us;; ***(callback via a call to a jump to other.)***
;; above call sends us back to finish the sub that called us, sorta as if it was inline parameter to us.
;; When the allocatee tries to return to whoever call it, It pops the address this call pushed, bringing control back here!
;;
;; This is part of the above, it deallocates the space on the stack.  It runs when the called back sub is done.
;; We swiped the other subs ret to get back here, so we can clean up.
;; Since the "real" ret add is still on stack, below IY, IX, & BC, when WE ret, we go back to allocatee's caller.
0000:0580 FDE1   pop iy      ; Restore IX, IY
0000:0582 DDE1   pop ix      
0000:0584 EB     ex de,hl    ; Swap HL, DE  ;; save other subs return value in DE
0000:0585 E1     pop hl      ; Restore SP to original value
0000:0586 F9     ld sp,hl    
0000:0587 C1     pop bc      ; Restore BC
0000:0588 EB     ex de,hl    ; Restore HL
0000:0589 7C     ld a,h      ; Return (HL==0) ;; NO!, return whatever the called back sub returned!!!
0000:058A B5     or l        
0000:058B C9     ret         ;; Finally, do a ret on behalf of that other sub. (now it's paid back!)


;; LOCALIZE, without indexes.  IT APPEARS THAT THIS IS NEVER CALLED, at least  in first 64k of code.
;; This is similar to the above, in that it allocates space on stack.  But it doesn't save index regs.
;; (This COULD be an 8080 version of above routine.)
;; It uses the above cleanup code, jumpimg in right after the IX & IY are popped, 'cause it doesn't save them!
0000:058C E1     pop hl      ;;pop return address (for callback)
0000:058D C5     push bc     ;;push BC
0000:058E 44     ld b,h      ;;push localvars(DE is num bytes)
0000:058F 4D     ld c,l      
0000:0590 210000 ld hl,0000  
0000:0593 39     add hl,sp  
0000:0594 EB     ex de,hl    
0000:0595 39     add hl,sp  
0000:0596 F9     ld sp,hl    
0000:0597 D5     push de     ;;push DE
0000:0598 218405 ld hl,0584  ;;push #0584.  Create-A-Call.  Sneaky way to use some of the above routine!!!
0000:059B E5     push hl     ;;   ***(callback via a push of return address, and a jump to allocatee.)***
0000:059C 60     ld h,b      ;;   ***(A push and jump equals a call!!!)***
0000:059D 69     ld l,c      ;;   ***(Just why the two routines use different ways to callback escapes me!)***
0000:059E E9     jp (hl)     ;;   ***(This way is way cleaner than jp-to-call outside of the routine!!!!!) ***



;; Following is a _REAL_LONG_ list of handles to library functions, and who knows what else.
;; If the function is in page #00 (this page), it is just jumped to.  If in any other page,
;; the address is loaded in HL, and the appropriate page handle is jumped to.
;; Any routine that is callable from outside of it's own page needs one of these.  (Always available in slot #0000)
;;
          memcpy(dst,src,n)
0000:059F C3E10E jp memcpy(dst,src,n)     ;  memcpy(dest, src, numbytes)

          memmov(dst,src,n)
0000:05A2 C3080F jp memmov(dst,src,n)     ;  memmov(dest, src, numbytes) ;; overlap_safe_copy

          memcompare(a,b,n)
0000:05A5 C3410F jp memcompare(a,b,n)    

          memfill(dst,val,n)
0000:05A8 C3700F jp memfill(dst,val,n)     ;  Fill(wNumBytes, bValue, *Dest)

          Copy_virtual(dst_pg, dst_off, src_pg, src_off, n)
0000:05AB C36610 jp Copy_virtual(dst_pg, dst_off, src_pg, src_off, n)    

          Copy_virtual_overlapsafe(dst_pg, dst_off, src_pg, src_off, n)
0000:05AE C3A810 jp Copy_virtual_overlapsafe(dst_pg, dst_off, src_pg, src_off, n)    

          Fill_virtual(page, offset, fillbyte, n)
0000:05B1 C35C11 jp Fill_virtual(page, offset, fillbyte, n)    

          Copy_virtual-pointed(dst_pg, dst_ptr, src_pg, src_ptr, n)
0000:05B4 218850 ld hl,5088  
0000:05B7 C34800 jp Copy_virtual-pointed(dst_pg, dst_ptr, src_pg, src_ptr, n)                         ; D088

          strcat(dest, src)
0000:05BA C3E80D jp strcat(dest, src)                 ; strcat(dest, src)

          strncat(dest, src, n)
0000:05BD C3140E jp strncat(dest, src, n)             ; strncat(n, dest, src)

          strchr(s1, c)
0000:05C0 C34D0E jp strchr(s1, c)                     ; strchr(s1, c)

          strstr(s1, s2)
0000:05C3 C3720E jp strstr(s1, s2)                    ; strcmp(s1, s2)?

          Strcpy(dst,src)
0000:05C6 C35C0C jp Strcpy(dst,src)                   ; String copy(Source, Dest)

          strncpy(dst, src, n)
0000:05C9 C3810C jp strncpy(dst, src, n)              ; strncpy(n, src, dest)

          strlen(src)
0000:05CC C3B40C jp strlen(src)                       ; strlen(src)

          strcompare(str1, str2)
0000:05CF C3D30C jp strcompare(str1, str2)            ; a=1

          strcompare_insens(str1, str2)
0000:05D2 C3EB0C jp strcompare_insens(str1, str2)     ; a=0

          strcompare(str1, str2, n)
0000:05D5 C3020D jp strcompare(str1, str2, n)         ; string compare case insensitive?

          strcompare_insens(str1, str2, n)
0000:05D8 C32B0D jp strcompare_insens(str1, str2, n)      ; Uses above

          get_filehandle(???, code, n)
0000:05DB C38614 jp get_filehandle(???, code, n)    

          nutherunknown(fh, n)
0000:05DE C36E17 jp nutherunknown(fh, n)    

          readfile(fh, dest^, n)
0000:05E1 C3F912 jp readfile(fh, dest^, n)    

          writefile(fh, source^, n)
0000:05E4 C33414 jp writefile(fh, source^, n)    

          seek(handle#, offset, dontcare, origin)
0000:05E7 C36612 jp seek(handle#, offset, dontcare, origin)    

          idunnoyet_close????(file#)
0000:05EA C38915 jp idunnoyet_close????(file#)    

          Call_Far(page, address, params...)
0000:05ED C35219 jp Call_Far(page, address, params...)     ;;  call to any page, page & address on stk

          Rampage!(new)
0000:05F0 C3821A jp Rampage!(new)     ;; sets slot8000device = ram, page = newpage, rets oldpage

          What_Rampage?
0000:05F3 C3961A jp What_Rampage?     ;; sets slot8000device = ram, rets currentpage


0000:05F6 C3631A jp 1A63     ;; set4000codepage(newpage) sets slot4000device = coderom, page = newpage, rets oldpage
0000:05F9 C3771A jp 1A77     ;; set4000code().   sets slot4000 device = coderom, returns current page

0000:05FC C3A11A jp 1AA1     ;; set4000datapage(newpage).  sets device4000 = dataflash, page = newpage, rets oldpage
0000:05FF C3B51A jp 1AB5     ;; set4000data().   sets  device4000 = dataflash, returns current page.

          0602(who, tab30.6, signal, par6, par8)
0000:0602 216945 ld hl,4569  
0000:0605 C35400 jp 0602(who, tab30.6, signal, par6, par8)     ; 185A7

          app_init(who, par2)
0000:0608 21F342 ld hl,42F3  
0000:060B C35400 jp app_init(who, par2)     ; 18331

          getwozthis
0000:060E 213545 ld hl,4535  
0000:0611 C35400 jp getwozthis     ; 18573

          table30rowexists(who)
0000:0614 213E45 ld hl,453E  
0000:0617 C35400 jp ;; rets 1 if tab30.funcaddr[     ; 1857C

          put12List(par)
0000:061A 216754 ld hl,5467  ;; rets row#
0000:061D C35400 jp put12List(par)     ; 194A5

          put_Table30(ram_etc, address, unused)
0000:0620 218053 ld hl,5380  
0000:0623 C35400 jp put_Table30(ram_etc, address, unused)     ; 193BE

          AddTask_6List(addr)
0000:0626 21BC54 ld hl,54BC  ;; list holds up to 6 tasks, one is the reflash test
0000:0629 C35400 jp AddTask_6List(addr)     ; 194FA

          set_task_yyyy(addr)
0000:062C 21E654 ld hl,54E6  ;; address used to "call hl" in at least one place (page #0e)
0000:062F C35400 jp set_task_yyyy(addr)     ; 19524

          set_task_zzzz(addr)
0000:0632 21F254 ld hl,54F2  ;; address is often used as address to call via hl elsewhere
0000:0635 C35400 jp set_task_zzzz(addr)     ; 19530

          load_tab5_then_zzzz-0C-0-0(who, dataptr, num_rows)
0000:0638 21FE54 ld hl,54FE  
0000:063B C35400 jp load_tab5_then_zzzz-0C-0-0(who, dataptr, num_rows)     ; 1953C

          table30_remove(row)
0000:063E 21D355 ld hl,55D3  
0000:0641 C35400 jp table30_remove(row)     ; 19611

          kill_if_higerthan6(12Listrow)
0000:0644 216B56 ld hl,566B  
0000:0647 C35400 jp kill_if_higerthan6(12Listrow)     ; 196A9

          widget_Handle_event(tab16row, sig???, par4, par6)
0000:064A 21C14A ld hl,4AC1  
0000:064D C35400 jp widget_Handle_event(tab16row, sig???, par4, par6)     ; 18AFF

          Put_Event(Who, signal, this, that)
0000:0650 211C47 ld hl,471C  
0000:0653 C35400 jp Put_Event(Who, signal, this, that)     ; 1875A

          app_handle_event(who, signal, this, that)
0000:0656 21604B ld hl,4B60  ;; This can execute code in dataflash!!!
0000:0659 C35400 jp app_handle_event(who, signal, this, that)     ; 18B9E

          Pop_Event(eventptr)
0000:065C 21A545 ld hl,45A5  
0000:065F C35400 jp Pop_Event(eventptr)     ; 185E3  ;; wrapper for below

          Pop_or_Peek_Event(eventptr, pop)
0000:0662 21BB45 ld hl,45BB  ;; this one calls 3:451C  with "jp (hl)"
0000:0665 C35400 jp Pop_or_Peek_Event(eventptr, pop)     ; 185F9

          Put_Event_go_main_app
0000:0668 218C4C ld hl,4C8C  
0000:066B C35400 jp Put_Event_go_main_app     ; 18CCA

          Put_Event_go_prev_app
0000:066E 21A94C ld hl,4CA9  
0000:0671 C35400 jp Put_Event_go_prev_app     ; 18CE7

          IsEvent.Sig_01_04_or_03__and_unmasked?(eventptr)
0000:0674 21C347 ld hl,47C3  
0000:0677 C35400 jp IsEvent.Sig_01_04_or_03__and_unmasked?(eventptr)     ; 18801

          Dispatch_Event(eventptr)
0000:067A 212148 ld hl,4821  
0000:067D C35400 jp Dispatch_Event(eventptr)     ; 1885F

          set_focus???_new_tab16row_for_tab30.wozthis(tab16row)
0000:0680 210F60 ld hl,600F  
0000:0683 C35400 jp set_focus???_new_tab16row_for_tab30.wozthis(tab16row)     ; 1A04D

          get_tab30.wozthis.tab16row
0000:0686 218960 ld hl,6089  
0000:0689 C35400 jp get_tab30.wozthis.tab16row     ; 1A0C7

          get_shiftstatus-60=caploc_90=ctrl_A0=shift
0000:068C 21F074 ld hl,74F0  
0000:068F C38800 jp get_shiftstatus-60=caploc_90=ctrl_A0=shift     ; 3B507

          widget_init(wtype, rametc, x, y, xd, yd, who, F_seq#???, str#etc)
0000:0692 217764 ld hl,6477  
0000:0695 C34E00 jp widget_init(wtype, rametc, x, y, xd, yd, who, F_seq#???, str#etc)     ; 16477

          exists12List(row)
0000:0698 215C68 ld hl,685C  
0000:069B C34E00 jp exists12List(row)     ; 1685c

          widget_delete(tab16row)
0000:069E 213F69 ld hl,693F  
0000:06A1 C34E00 jp widget_delete(tab16row)     ; 1693f

          isthis_tab16_row_for_wozthis?(tab16row)
0000:06A4 218368 ld hl,6883  
0000:06A7 C34E00 jp isthis_tab16_row_for_wozthis?(tab16row)     ; 16883

          get_tab16.1_ram_etc???nogo???_ifwozthis(tab16row)
0000:06AA 211069 ld hl,6910  
0000:06AD C34E00 jp get_tab16.1_ram_etc???nogo???_ifwozthis(tab16row)     ; 16910

0000:06B0 21CA6B ld hl,6BCA  
0000:06B3 C34E00 jp 05:6BCA     ; 16BCA

          get_widgetbox_wc(tab16row, boxptr)
0000:06B6 21A16C ld hl,6CA1  
0000:06B9 C34E00 jp get_widgetbox_wc(tab16row, boxptr)     ; 16CA1

          get_tab16.1_ram_etc???nogo???_verify_assoc_wozthis(tab16row)
0000:06BC 21836B ld hl,6B83  
0000:06BF C34E00 jp get_tab16.1_ram_etc???nogo???_verify_assoc_wozthis(tab16row)     ; 16B83

          nextORprev_woz_tab16row(tab16row, forward)
0000:06C2 21F969 ld hl,69F9  
0000:06C5 C34E00 jp nextORprev_woz_tab16row(tab16row,  forward)     ; 169F9

          widget_resize(widget, x, y, xd, yd, flag_redraw??refocus??)
0000:06C8 215573 ld hl,7355  
0000:06CB C34E00 jp widget_resize(widget, x, y, xd, yd, flag_redraw??refocus??)     ; 17355

          get_widgetbox_sc(widget, boxptr)
0000:06CE 219576 ld hl,7695  
0000:06D1 C34E00 jp get_widgetbox_sc(widget, boxptr)     ; 17695


0000:06D4 214D5A ld hl,5A4D  
0000:06D7 C35400 jp 06:5A4D     ; 19A8B
0000:06DA 21535A ld hl,5A53  
0000:06DD C35400 jp 06:5A53     ; 19A91

          set_new_fh???(tab16row, new_fh???)
0000:06E0 21595A ld hl,5A59  
0000:06E3 C35400 jp set_new_fh???(tab16row, new_fh???)     ; 19A97

          get_tab16.fh(tab16row)
0000:06E6 21AF5A ld hl,5AAF  
0000:06E9 C35400 jp get_tab16.fh(tab16row)     ; 19AED

          set_font(tab16row, font)
0000:06EC 21DA5A ld hl,5ADA  
0000:06EF C35400 jp set_font(tab16row, font)     ; 19B18

          get_font(tab16row)
0000:06F2 21635B ld hl,5B63  
0000:06F5 C35400 jp get_font(tab16row)     ; 19BA1

          set_font(thingyptr, font)
0000:06F8 214956 ld hl,5649  
0000:06FB C34E00 jp set_font(thingyptr, font)     ; 15649

          draw_string(thingyptr, strptr, n, boxptr, ????)
0000:06FE 217956 ld hl,5679  ;
0000:0701 C34E00 jp draw_string(thingyptr, strptr, n, boxptr, ????)     ; 15679

          draw_string_wc(thingyptr, x, y, string^, n)
0000:0704 C3B938 jp draw_string_wc(thingyptr, x, y, string^, n)    

0000:0707 21BB62 ld hl,62BB  
0000:070A C34E00 jp 05:62BB     ; 162BB

          Set_a_timer(who, msec, persist)
0000:070D 219A5B ld hl,5B9A  
0000:0710 C35400 jp Set_a_timer(who, msec, persist)     ; 19BD8

          Kill_Timer(timer#)
0000:0713 21A45C ld hl,5CA4  
0000:0716 C35400 jp Kill_Timer(timer#)     ; 19CE2

          setcursor(tab16row, x, y, use_lg_font_flag)
0000:0719 214D47 ld hl,474D  
0000:071C C34E00 jp setcursor(tab16row, x, y, use_lg_font_flag)     ; 1474D

          move????(x,y)
0000:071F 21CA47 ld hl,47CA  
0000:0722 C34E00 jp move????(x,y)     ; 147CA

          cursor_off
0000:0725 210C48 ld hl,480C  
0000:0728 C34E00 jp cursor_off     ; 1480C

          init_widget_thingy(tab16row, thingyptr)
0000:072B 211E48 ld hl,481E  
0000:072E C34E00 jp init_widget_thingy(tab16row, thingyptr)     ; 1481E

          init_whole_thingy(thingyptr)
0000:0731 21974D ld hl,4D97  
0000:0734 C34E00 jp init_whole_thingy(thingyptr)     ; 14D97

          init_top_thingy(thingyptr)
0000:0737 215A4E ld hl,4E5A  
0000:073A C34E00 jp init_top_thingy(thingyptr)     ; 14E5A

          init_bottom_thingy(thingyptr)
0000:073D 211A4F ld hl,4F1A  
0000:0740 C34E00 jp init_bottom_thingy(thingyptr)     ; 14F1A

          draw_icon_wc(thingyptr, x, y, iconnum)
0000:0743 210150 ld hl,5001  
0000:0746 C34E00 jp draw_icon_wc(thingyptr, x, y, iconnum)     ; 15001

          invert_box_wc(thingyptr, boxptr)
0000:0749 214B50 ld hl,504B  
0000:074C C34E00 jp invert_box_wc(thingyptr, boxptr)     ; 1504B

          draw_box_inverted_wc(thingyptr, boxptr)
0000:074F 21D050 ld hl,50D0  
0000:0752 C34E00 jp draw_box_inverted_wc(thingyptr, boxptr)     ; 150D0

          draw_box_wc(thingyptr, x0, y0, x1, y1)
0000:0755 215551 ld hl,5155  
0000:0758 C34E00 jp draw_box_wc(thingyptr, x0, y0, x1, y1)     ; 15155

          draw_clipped_line_wc(thingyptr, x0,y0,x1,y1)
0000:075B 212B52 ld hl,522B  
0000:075E C34E00 jp draw_clipped_line_wc(thingyptr, x0,y0,x1,y1)     ; 1522B

          draw(tab16row, boxptr, fill)
0000:0761 219452 ld hl,5294  
0000:0764 C34E00 jp draw(tab16row, boxptr, fill)     ; 15294

          fill_or_erase_box_wc(thingyptr, x0, y0, x1, y1)
0000:0767 21BE51 ld hl,51BE  
0000:076A C34E00 jp fill_or_erase_box_wc(thingyptr, x0, y0, x1, y1)     ; 151BE

          ???????(tab16row, always0??, par4, par6)
0000:076D 21B16D ld hl,6DB1  
0000:0770 C34E00 jp ???????(tab16row, always0??, par4, par6)     ; 16DB1

          Load_widgets(par0)
0000:0773 21E077 ld hl,77E0  
0000:0776 C34E00 jp Load_widgets(par0)     ; 177E0

          remove_widgets
0000:0779 21E679 ld hl,79E6  
0000:077C C34E00 jp remove_widgets     ; 179E6

          find_1st_widget_with_flag(par0)
0000:077F 21AC7A ld hl,7AAC  
0000:0782 C34E00 jp find_1st_widget_with_flag(par0)     ; 17AAC

          get_inuseflag???(tab16row)
0000:0785 21307B ld hl,7B30  
0000:0788 C34E00 jp get_inuseflag???(tab16row)     ; 17B30

          writesomefile(pointer, n)
0000:078B 21127B ld hl,7B12  
0000:078E C34800 jp writesomefile(pointer, n)     ; FB12

          readsomefile(destptr, n)
0000:0791 21DA7B ld hl,7BDA  
0000:0794 C34800 jp readsomefile(destptr, n)     ; FBDA

          clear_DABA????
0000:0797 21557C ld hl,7C55  
0000:079A C34800 jp clear_DABA????     ; FC55

          getDABA
0000:079D 218D7C ld hl,7C8D  
0000:07A0 C34800 jp getDABA     ; FC8D

          oddball_upcase_char(somechar)
0000:07A3 21A056 ld hl,56A0  
0000:07A6 C35400 jp oddball_upcase_char(somechar)     ; 196DE

          oddball_lowcase_char(somechar)
0000:07A9 21F256 ld hl,56F2  
0000:07AC C35400 jp oddball_lowcase_char(somechar)     ; 19730

          string2int(strptr)
0000:07AF 214457 ld hl,5744  
0000:07B2 C35400 jp string2int(strptr)     ; 19782

          int2string(number, strptr, n)
0000:07B5 21B757 ld hl,57B7  
0000:07B8 C35400 jp int2string(number, strptr, n)     ; 197F5

          initbox(boxptr, x0, y0, x1, y1)
0000:07BB 21A37B ld hl,7BA3  
0000:07BE C34E00 jp initbox(boxptr, x0, y0, x1, y1)     ; 17BA3

0000:07C1 21FA7B ld hl,7BFA  
0000:07C4 C34E00 jp 05:7BFA     ; 17BFA

          shift_box(boxptr, x_offset, y_offset)
0000:07C7 216B7C ld hl,7C6B  
0000:07CA C34E00 jp shift_box(boxptr, x_offset, y_offset)     ; 17C6B

0000:07CD 211A7D ld hl,7D1A  
0000:07D0 C34E00 jp 05:7D1A     ; 17D1A

          intersect?(resultboxptr, box1ptr, box2ptr)
0000:07D3 21A84B ld hl,4BA8  
0000:07D6 C34E00 jp intersect?(resultboxptr, box1ptr, box2ptr)     ; 14BA8

0000:07D9 21CF7D ld hl,7DCF  
0000:07DC C34E00 jp 05:7DCF     ; 17DCF

          set_a_menu_widget_06
0000:07DF 210040 ld hl,4000  
0000:07E2 C38800 jp set_a_menu_widget_06     ; 38000

          add_menu_item(widget, menurow, string#)
0000:07E5 214D41 ld hl,414D  
0000:07E8 C38800 jp add_menu_item(widget, menurow, string#)     ; 3814D

          ????(tab16row, flags, x, y)
0000:07EB 218B45 ld hl,458B  
0000:07EE C38800 jp ????(tab16row, flags, x, y)     ; 3858B

          MessageBox(string#, flags)
0000:07F1 210040 ld hl,4000  ;;   uses strings from page #0F  (see strings.txt)
0000:07F4 C38200 jp MessageBox(string#, flags)     ; 34000

          ????(string#, par2)  FYBER NOTE: print string???
0000:07F7 21D34D ld hl,4DD3  
0000:07FA C38200 jp ????(string#, par2)     ; 34E71

0000:07FD 214C4F ld hl,4F4C  
0000:0800 C38200 jp 0D:4F4C     ; 34FEA

          isitalpha?(somechar)
0000:0803 21E059 ld hl,59E0  
0000:0806 C35400 jp isitalpha?(somechar)     ; 19A1E

          isitnumeric?(somechar)
0000:0809 21055A ld hl,5A05  
0000:080C C35400 jp isitnumeric?(somechar)     ; 19A43

          itituppercase?(char)
0000:080F 211D5A ld hl,5A1D  
0000:0812 C35400 jp itituppercase?(char)     ; 19A5B

          isitlowercase?(char)
0000:0815 21355A ld hl,5A35  
0000:0818 C35400 jp isitlowercase?(char)     ; 19A73

          string_lookup_page#0F_etc(string#, where^, n)
0000:081B 212463 ld hl,6324  
0000:081E C34E00 jp string_lookup_page#0F_etc(string#, where^, n)     ; 16324

          draw_scroll arrows????(icon#)
0000:0821 218866 ld hl,6688  
0000:0824 C35400 jp draw_scroll arrows????(icon#)     ; 1A6C6

          Draw_app_foldertab(stringptr)
0000:0827 212A67 ld hl,672A  
0000:082A C35400 jp Draw_app_foldertab(stringptr)     ; 1A768

          Draw_string_upper_right_thingy(strptr)
0000:082D 219B68 ld hl,689B  
0000:0830 C35400 jp Draw_string_upper_right_thingy(strptr)     ; 1A8D9

          draw_string_mid_topthingy(strptr)
0000:0833 212F69 ld hl,692F  
0000:0836 C35400 jp draw_string_mid_topthingy(strptr)     ; 1A96D

          random(limit)
0000:0839 C3341A jp random(limit)    

          printer_driver???(char_to_print)
0000:083C 212551 ld hl,5125  
0000:083F C34800 jp printer_driver???(char_to_print)     ; D125

          prints_somethin(pointer, n)
0000:0842 218252 ld hl,5282  
0000:0845 C34800 jp prints_somethin(pointer, n)     ; D282

          print_longline(pointer, numspaces, crlf_flag)
0000:0848 21E053 ld hl,53E0  
0000:084B C34800 jp print_longline(pointer, numspaces, crlf_flag)     ; D3E0

          print3dots
0000:084E 219355 ld hl,5593  
0000:0851 C34800 jp print3dots     ; D593

          select_printer
0000:0854 21365D ld hl,5D36  
0000:0857 C34800 jp select_printer     ; DD36
         
0000:085A 21016C ld hl,6C01  
0000:085D C34800 jp 03:6C01     ; EC01

          Read_Romdisk(iy=twoLoBytesofAddress, ix=page???, bc=n, hl=dest)
0000:0860 C3BC13 jp Read_Romdisk(iy=twoLoBytesofAddress, ix=page???, bc=n, hl=dest)    

          Turn_modem_on
0000:0863 C3F733 jp Turn_modem_on    

          Turn_modem_off
0000:0866 C36534 jp Turn_modem_off    

          no_modem_rxdata
0000:0869 21AE70 ld hl,70AE  
0000:086C C35400 jp no_modem_rxdata     ; 1B0EC

          L=getbyte_modem_rx_queue
0000:086F 211371 ld hl,7113  
0000:0872 C35400 jp L=getbyte_modem_rx_queue     ; 1B151

0000:0875 21456C ld hl,6C45  
0000:0878 C35400 jp 06:6C45     ; 1AC83

          modem_somethin
0000:087B 218870 ld hl,7088  
0000:087E C35400 jp modem_somethin     ; 1B0C6

          modem_send(buff, n)
0000:0881 21786B ld hl,6B78  
0000:0884 C35400 jp modem_send(buff, n)     ; 1ABB6

          addrecord(file#, n, where^)
0000:0887 21F04C ld hl,4CF0  
0000:088A C3F400 jp addrecord(file#, n, where^)     ; C8CF0

          ???(file#, rec#)
0000:088D 21BC53 ld hl,53BC  
0000:0890 C3F400 jp ???(file#, rec#)     ; C93BC

          modify_file(file#, rec#, recoffset, n, where^)
0000:0893 21434F ld hl,4F43  
0000:0896 C3F400 jp modify_file(file#, rec#, recoffset, n, where^)     ; C8F43

          write_any_file(file#, rec#, n, whereptr)
0000:0899 219650 ld hl,5096  
0000:089C C3F400 jp write_any_file(file#, rec#, n, whereptr)     ; C9096

          must_be_read???(file#, rec#, n, where)
0000:089F 214B4C ld hl,4C4B  
0000:08A2 C3F400 jp must_be_read???(file#, rec#, n, where)     ; C8C4B

          delete_file???(file#)
0000:08A5 215454 ld hl,5454  
0000:08A8 C3F400 jp delete_file???(file#)     ; C9454

          rename(file1, file2)
0000:08AB 218957 ld hl,5789  
0000:08AE C3F400 jp rename(file1, file2)     ; C9789

          Get_Record_Address(file#, firstorsecondbkmk, rec#, where^)
0000:08B1 219E4A ld hl,4A9E  
0000:08B4 C3F400 jp Get_Record_Address(file#, firstorsecondbkmk, rec#, where^)     ; C8A9E

          ????(file#, )
0000:08B7 215E4B ld hl,4B5E  
0000:08BA C3F400 jp ????(file#, )     ; C8B5E

          read_df_file_or_record(dfaddr, n, where)
0000:08BD 21FE49 ld hl,49FE  
0000:08C0 C3F400 jp read_df_file_or_record(dfaddr, n, where)     ; C89FE

          Num_Records_2or3_friendly(file#, #4a_or_8a, where^)
0000:08C3 210843 ld hl,4308  
0000:08C6 C3F400 jp Num_Records_2or3_friendly(file#, #4a_or_8a, where^)     ; C8308

          avail_flash(result^)
0000:08C9 21E158 ld hl,58E1  
0000:08CC C3F400 jp avail_flash(result^)     ; C98E1

          Number_of_Records(file#)
0000:08CF 211F57 ld hl,571F  
0000:08D2 C3F400 jp Number_of_Records(file#)     ; C971F

0000:08D5 21A45B ld hl,5BA4  
0000:08D8 C3F400 jp some_df_usage_stat(result_ptr)     ; C9BA4

0000:08DB 210D5D ld hl,5D0D  
0000:08DE C3F400 jp crank_dataflashcheck_statemach     ; C9D0D

          init_dataflash(command)
0000:08E1 214859 ld hl,5948  
0000:08E4 C3F400 jp init_dataflash(command)     ; C9948

          put_flag_by_number(flag#, where^)
0000:08E7 211D5B ld hl,5B1D  
0000:08EA C3F400 jp put_flag_by_number(flag#, where^)     ; C9B1D

          get_flag_by_number(flag#, where^)
0000:08ED 21965A ld hl,5A96  
0000:08F0 C3F400 jp get_flag_by_number(flag#, where^)     ; C9A96

          chk_dataflash_progressbar(fixittooflag)
0000:08F3 21B673 ld hl,73B6  
0000:08F6 C3F400 jp chk_dataflash_progressbar(fixittooflag)     ; CB3B6

0000:08F9 210E59 ld hl,590E  
0000:08FC C3F400 jp 32:590E     ; C990E

          Write_dataflash_Lastsector(offset, n, @where)
0000:08FF C3DE37 jp Write_dataflash_Lastsector(offset, n, @where)    

          Read_dataflash_Lastsector(offset, n, @where)
0000:0902 C30138 jp Read_dataflash_Lastsector(offset, n, @where)    

          Read_dataflash(page:sector:offset, n, @where)
0000:0905 C32438 jp Read_dataflash(page:sector:offset, n, @where)    
;; Note: This routine [0905] reads across sector boundaries.  There are also
;; read and write dataflash sectorwise routines, with no handles.  Both this
;; and the sector-wise routines are called directly from many more places than
;; this handle is called.


0000:0908 00     nop         ;; I wonder what went here???
0000:0909 00     nop        
0000:090A 00     nop        

          Writedataflash_low(dataflashaddr, n, where^)
0000:090B 212840 ld hl,4028  
0000:090E C3F400 jp Writedataflash_low(dataflashaddr, n, where^)     ; C8028

0000:0911 214B40 ld hl,404B  
0000:0914 C3FA00 jp 33:404B     ; CC04B

0000:0917 214240 ld hl,4042  
0000:091A C3FA00 jp 33:4042     ; CC042

0000:091D 215D40 ld hl,405D  
0000:0920 C3FA00 jp 33:405D     ; C005D  ;; cc

0000:0923 214840 ld hl,4048  
0000:0926 C3FA00 jp 33:4048     ; C0048  ;; cc

0000:0929 216340 ld hl,4063  
0000:092C C3FA00 jp 33:4063     ; C0063  ;; cc

0000:092F 214540 ld hl,4045  
0000:0932 C3FA00 jp 33:4045     ; C0045  ;; cc

          app_11(who, tab30.6, signal, this, that)
0000:0935 211A4D ld hl,4D1A  ;;                      in tab30.11
0000:0938 C34800 jp app_11(who, tab30.6, signal, this, that)     ; 0C048  ;; 0cd1a

0000:093B 212A40 ld hl,402A  
0000:093E C3FA00 jp 33:402A     ; C002A  ;; cc

0000:0941 213940 ld hl,4039  
0000:0944 C3FA00 jp 33:4039     ; C0039  ;; cc

0000:0947 216C40 ld hl,406C  
0000:094A C3FA00 jp 33:406C     ; C006C  ;; cc

0000:094D 215740 ld hl,4057  
0000:0950 C3FA00 jp 33:4057     ; C0057  ;; cc
0000:0953 215A40 ld hl,405A  
0000:0956 C3FA00 jp 33:405A     ; C005A  ;; cc
0000:0959 215140 ld hl,4051  
0000:095C C3FA00 jp 33:4051     ; C0051  ;; cc
0000:095F 215440 ld hl,4054  
0000:0962 C3FA00 jp 33:4054     ; C0054  ;; cc

          black_hole!!!
0000:0965 216509 ld hl,black_hole!!!  
0000:0968 C3FA00 jp 33:0965     ; ????   ;; yeah, whats up with that???
                                     ;; AFAICT, this will just jump to itself.

0000:096B 217B40 ld hl,407B  
0000:096E C3FA00 jp 33:407B     ; C007B  ;; cc
;;
0000:0971 216F40 ld hl,406F  
0000:0974 C3FA00 jp 33:406F     ; C006F  ;; cc
;;
0000:0977 213040 ld hl,4030  
0000:097A C3FA00 jp 33:4030     ; C0030  ;; cc

          app_16(who, tab30.6, signal, this, that)
0000:097D 21224F ld hl,4F22  ;;                      in tab30.16
0000:0980 C34800 jp app_16(who, tab30.6, signal, this, that)     ; 0CF22

0000:0983 217840 ld hl,4078  
0000:0986 C3FA00 jp 33:4078     ; C0078  ;; cc
0000:0989 217540 ld hl,4075  
0000:098C C3FA00 jp 33:4075     ; C0075  ;; cc

          app_12(who, tab30.6, signal, this, that)
0000:098F 21824D ld hl,4D82  ;;                      in tab30.12
0000:0992 C34800 jp app_12(who, tab30.6, signal, this, that)     ; CD82

0000:0995 213640 ld hl,4036  
0000:0998 C3FA00 jp 33:4036     ; C0036  ;; cc
;;
0000:099B 213340 ld hl,4033  
0000:099E C3FA00 jp 33:4033     ; C0033  ;; cc

          app_17(who, tab30.6, signal, this, that)
0000:09A1 218A4F ld hl,4F8A  ;;                      in tab30.17
0000:09A4 C34800 jp app_17(who, tab30.6, signal, this, that)     ; CF8A
;;
0000:09A7 217240 ld hl,4072  
0000:09AA C3FA00 jp 33:4072     ; C0072  ;; cc
0000:09AD 211B40 ld hl,401B  
0000:09B0 C3FA00 jp 33:401B     ; C001B  ;; cc
;;
0000:09B3 212D40 ld hl,402D  
0000:09B6 C3FA00 jp 33:402D     ; C002D  ;; cc

          copystr_to0105:9636(str)
0000:09B9 212740 ld hl,4027  
0000:09BC C3FA00 jp copystr_to0105:9636(str)     ; C0027  ;; cc

          copystr_to0105:9686(str)
0000:09BF 212140 ld hl,4021  
0000:09C2 C3FA00 jp copystr_to0105:9686(str)     ; C0021  ;; cc

0000:09C5 211540 ld hl,4015  
0000:09C8 C3FA00 jp 33:4015     ; C0015  ;; cc
;;
0000:09CB 212440 ld hl,4024  
0000:09CE C3FA00 jp 33:4024     ; C0024  ;; cc
;;
0000:09D1 211E40 ld hl,401E  
0000:09D4 C3FA00 jp 33:401E     ; C001E  ;; cc
;;
0000:09D7 211840 ld hl,4018  
0000:09DA C3FA00 jp 33:4018     ; C0018  ;; cc

          app_13(who, tab30.6, signal, this, that)
0000:09DD 21EA4D ld hl,4DEA  ;;                      in tab30.13
0000:09E0 C34800 jp app_13(who, tab30.6, signal, this, that)     ; CDEA

          app_14(who, tab30.6, signal, this, that)
0000:09E3 21524E ld hl,4E52  ;;                      in tab30.14
0000:09E6 C34800 jp app_14(who, tab30.6, signal, this, that)     ; CE52

          app_15(who, tab30.6, signal, this, that)
0000:09E9 21BA4E ld hl,4EBA  ;;                      in tab30.15
0000:09EC C34800 jp app_15(who, tab30.6, signal, this, that)     ; CEBA

0000:09EF 216640 ld hl,4066  
0000:09F2 C3FA00 jp 33:4066     ; C0066  ;; cc
0000:09F5 214E40 ld hl,404E  
0000:09F8 C3FA00 jp 33:404E     ; C004E  ;; cc
0000:09FB 216040 ld hl,4060  
0000:09FE C3FA00 jp 33:4060     ; C0060  ;; cc
0000:0A01 216940 ld hl,4069  
0000:0A04 C3FA00 jp 33:4069     ; C0069  ;; cc
0000:0A07 213C40 ld hl,403C  
0000:0A0A C3FA00 jp 33:403C     ; C003C  ;; cc
0000:0A0D 217E40 ld hl,407E  
0000:0A10 C3FA00 jp 33:407E     ; C007E  ;; cc
0000:0A13 218140 ld hl,4081  
0000:0A16 C3FA00 jp 33:4081     ; C0081  ;; cc

; Enable interrupts
          Enable_Interrupts
0000:0A19 FB     ei          
0000:0A1A C9     ret        

; Disable interrupts
          Disable_Interrupts
0000:0A1B F3     di          
0000:0A1C C9     ret        

          mask_interrupts_1_4_5(which_int, on_or_off)
0000:0A1D 21FC42 ld hl,42FC  ;;  keybd_etc, time16, something_else
0000:0A20 C34800 jp mask_interrupts_1_4_5(which_int, on_or_off)     ; C2FC

          Set_CPU_Clock(reg, value)   
          ;
          ; 	FYBER NOTE(12-30-09): 
          ;		* reg=0 changes 0x0D bits 1 and 2, reg=1 changes 0x2F bits 5-4, sets 7-6 on, and kills bits 2-0
          ;		* Only used in page 6, once
          ;		
0000:0A23 212843 ld hl,4328  
0000:0A26 C34800 jp Set_CPU_Clock(reg, value)     ; C328

          mask_interrupts_7_6_2(which_int, on_or_off)
0000:0A29 210040 ld hl,4000  ;; modem, callid int's
0000:0A2C C34800 jp mask_interrupts_7_6_2(which_int, on_or_off)     ; C000

          set_interrupt(int#=C, enable=B)
0000:0A2F C3FB1A jp set_interrupt(int#=C, enable=B)     ; Translate bit position given in C (0-7) to bit mask and apply it to A
                             
          Read_datetime(timerecptr)
0000:0A32 212C40 ld hl,402C  
0000:0A35 C34800 jp Read_datetime(timerecptr)     ; C02C

          Set_datetime(timerecptr)
0000:0A38 213741 ld hl,4137  
0000:0A3B C34800 jp Set_datetime(timerecptr)     ; C137

          set_timer(timerecptr)
0000:0A3E 213642 ld hl,4236  
0000:0A41 C34800 jp set_timer(timerecptr)     ; C236

          read_timer(timerecptr)
0000:0A44 219442 ld hl,4294  
0000:0A47 C34800 jp read_timer(timerecptr)     ; C294

          tweak_rtc_ports???
0000:0A4A C3951C jp tweak_rtc_ports???    

          enable_interrupt_3.5
0000:0A4D C3A71C jp enable_interrupt_3.5     ;; wouldn't it be a suprise if this is clock int???

          either_setting_or_checking_mail_timer
0000:0A50 21485F ld hl,5F48  
0000:0A53 C35400 jp either_setting_or_checking_mail_timer     ; 19F86

          set_mailcheck_timer???(timerecptr)
0000:0A56 21D15D ld hl,5DD1  
0000:0A59 C35400 jp set_mailcheck_timer???(timerecptr)     ; 19E0F

          Delay(msec)
0000:0A5C C3751C jp Delay(msec)     ; Delay

          mightbelastmailcheck???=Time32
0000:0A5F 21325D ld hl,5D32  
0000:0A62 C35400 jp mightbelastmailcheck???=Time32     ; 19D70

          somesortoftimer????(par0)
0000:0A65 21585D ld hl,5D58  
0000:0A68 C35400 jp somesortoftimer????(par0)     ; 19D96

          powerdownmode
0000:0A6B 21E84C ld hl,4CE8  ;; sets bootstate = #5A, then does powerdown.
0000:0A6E C35400 jp powerdownmode     ; 18D26

          is_lcd_on?
0000:0A71 C37F1B jp is_lcd_on?     ; Return 1 if P2.7 set

          Wall_Adaptor_detect
0000:0A74 C3921B jp Wall_Adaptor_detect    

          set_yougotmail_LED(newstate)
0000:0A77 C3D81A jp set_yougotmail_LED(newstate)     ; Set/clr P2.4 based on stacked value

          Low_battery_detect()
0000:0A7A C3A41B jp Low_battery_detect()     ; (P9.5=0)? Return 2, (P9.6=0)? Return 1, else return 0

          cpuhalt
0000:0A7D 76     halt        
0000:0A7E C9     ret        

          LCD_on
0000:0A7F C3E31C jp LCD_on     ; Set P2.7  ;; you NEED this to display anything, resets to OFF!!!

          LCD_off
0000:0A82 C3EE1C jp LCD_off     ; Clear P2.7

          Clear_LCD
0000:0A85 C35D24 jp Clear_LCD     ; Clear bitmap buffer & LCD

          calc_string_height&width(thingyptr, stringptr, len, w_h_ptr)
0000:0A88 C3AA29 jp calc_string_height&width(thingyptr, stringptr, len, w_h_ptr)    

          fill_or_erase_box_sc(thingy, x0, y0, x1, y1, unused)
0000:0A8B 217343 ld hl,4373  
0000:0A8E C34E00 jp fill_or_erase_box_sc(thingy, x0, y0, x1, y1, unused)     ; 14373

          updateLCDifdirty
0000:0A91 21EA45 ld hl,45EA  
0000:0A94 C34E00 jp updateLCDifdirty     ; 145EA

          get_charwidth(font, achar)
0000:0A97 C3542A jp get_charwidth(font, achar)    

          getkeycodefrombuffer(wheretoputit^)
0000:0A9A C35532 jp getkeycodefrombuffer(wheretoputit^)    

          init_keybuffer
0000:0A9D C3BB32 jp init_keybuffer     ;;   (clearkeybuffer a better name?????)

          init_keyboard(flagz)
0000:0AA0 C3CA32 jp init_keyboard(flagz)    

          get_powerbutton
0000:0AA3 C30F33 jp get_powerbutton    

          somethingwiththemodem
0000:0AA6 210748 ld hl,4807  
0000:0AA9 C3EE00 jp somethingwiththemodem     ; C4807

0000:0AAC 215375 ld hl,Enter_Test_Mode(par0)  
0000:0AAF C33C00 jp Enter_Test_Mode(par0)     ; 7542


0000:0AB2 218440 ld hl,4084  
0000:0AB5 C3FA00 jp 33:4084     ; CC084

0000:0AB8 00     nop        
0000:0AB9 00     nop        
0000:0ABA 00     nop        
0000:0ABB 00     nop        
0000:0ABC 00     nop        
0000:0ABD 00     nop        

          delete_records(file#, startrec#, endrec#)
0000:0ABE 219854 ld hl,5498  
0000:0AC1 C3F400 jp delete_records(file#, startrec#, endrec#)     ; C9498

0000:0AC4 218740 ld hl,4087  
0000:0AC7 C3FA00 jp 33:4087     ; CC087

0000:0ACA 218A40 ld hl,408A  
0000:0ACD C3FA00 jp 33:408A     ; CC08A

          TextBox(textpointer, flags)
0000:0AD0 213240 ld hl,4032  
0000:0AD3 C38200 jp TextBox(textpointer, flags)     ; 34032

          L = Scan_Magicsector(who)
0000:0AD6 C3893A jp L = Scan_Magicsector(who)     ;;  (on ret, L is a page# in dataflash)

          get_app_caption(who, stringnum, dest^, n)
0000:0AD9 C3FE1B jp get_app_caption(who, stringnum, dest^, n)     ; Calls above routine

          draw???icon(unused, par2, x, y, icon#)
0000:0ADC 211745 ld hl,4517  
0000:0ADF C34E00 jp draw???icon(unused, par2, x, y, icon#)     ; 14517

          parse_datetime(inptr, outptr)
0000:0AE2 211E7D ld hl,7D1E  
0000:0AE5 C3E800 jp parse_datetime(inptr, outptr)     ; C3DAF

          readserialnumber_9bytes(whereptr)
0000:0AE8 21677D ld hl,7D67  
0000:0AEB C3E800 jp readserialnumber_9bytes(whereptr)     ; C3DF8

          get_dev_headers(dest)
0000:0AEE 21837D ld hl,7D83  
0000:0AF1 C3E800 jp get_dev_headers(dest)     ; C3E14

          get_dev_mime(destptr)
0000:0AF4 21BF7D ld hl,7DBF  
0000:0AF7 C3E800 jp get_dev_mime(destptr)     ; C3E50

          get_dev_opt(strptr)
0000:0AFA 21D77D ld hl,7DD7  
0000:0AFD C3E800 jp get_dev_opt(strptr)     ; C3E68

         
0000:0B00 219040 ld hl,4090  
0000:0B03 C3FA00 jp 33:4090     ; CC090

          sssecondcrunch(serial, par2, par4, par6, par8)
0000:0B06 218D40 ld hl,408D  
0000:0B09 C3FA00 jp sssecondcrunch(serial, par2, par4, par6, par8)     ; CC08D

0000:0B0C 219340 ld hl,4093  
0000:0B0F C3FA00 jp 33:4093     ; CC093

          ccopy_string_to#0105:9C50
0000:0B12 219640 ld hl,4096  
0000:0B15 C3FA00 jp ccopy_string_to#0105:9C50     ; CC096

          readkeyboard????
0000:0B18 213275 ld hl,7532  ;;                   6List 4
0000:0B1B C38800 jp readkeyboard????     ; 3B549

          modemstuff???
0000:0B1E 219271 ld hl,7192  ;;                   6List 2
0000:0B21 C35400 jp modemstuff???     ; 1B1D0

          invert_cursor_every300ms
0000:0B24 210647 ld hl,4706  ;;                   6List 1
0000:0B27 C34E00 jp invert_cursor_every300ms     ; 14706

          just_wild_guess_thisis_idle_powerdown_OR_mebbe_mailcheck????
0000:0B2A 21A67E ld hl,7EA6  ;;                   6List 5
0000:0B2D C3C400 jp just_wild_guess_thisis_idle_powerdown_OR_mebbe_mailcheck????     ; 67E6F

          watch_for_update_trigger
0000:0B30 211C45 ld hl,451C  ; Reprog test/jump ;;  6List 3
0000:0B33 C34800 jp watch_for_update_trigger     ; C51C

          prob_callid
0000:0B36 214E68 ld hl,684E  
0000:0B39 C3E200 jp prob_callid     ; DE84E


;; The next 11 handles are loaded into 12List
;; They are "widget" event/signal handlers.

          12List.0_textentry???(tab16row, sig???, par4, par6)
0000:0B3C 210040 ld hl,4000  ;;                   12List.0
0000:0B3F C36000 jp 12List.0_textentry???(tab16row, sig???, par4, par6)     ; 20000

          12List.1_mightbefolderbrowser????(tab16row, sig???, par4, par6)
0000:0B42 21575F ld hl,5F57  ;;                   12List.1
0000:0B45 C38200 jp 12List.1_mightbefolderbrowser????(tab16row, sig???, par4, par6)     ; 35FF4

          12List.2_iconmenu????(tab16row, sig???, par4, par6)
0000:0B48 21BF67 ld hl,67BF  ;;                   12List.2
0000:0B4B C38800 jp 12List.2_iconmenu????(tab16row, sig???, par4, par6)     ; 3A7D6

          12List.3_string/icon_by_number(tab16row, sig???, par4, par6)
0000:0B4E 210B77 ld hl,Read_port_4  ;;                   12List.3
0000:0B51 C38200 jp 12List.3_string/icon_by_number(tab16row, sig???, par4, par6)     ; 377A8

          12List.4(tab16row, sig???, par4, par6)
0000:0B54 21E86F ld hl,6FE8  ;;                   12List.4
0000:0B57 C34800 jp 12List.4(tab16row, sig???, par4, par6)     ; EFE8

          12List.5-send/recv_progress???(tab16row, sig???, par4, par6)
0000:0B5A 21704F ld hl,4F70  ;;                   12List.5
0000:0B5D C38200 jp 12List.5-send/recv_progress???(tab16row, sig???, par4, par6)     ; 3500E

          12List.6_menu(tab16row, sig???, par4, par6)
0000:0B60 21664B ld hl,4B66  ;;                   12List.6
0000:0B63 C38800 jp 12List.6_menu(tab16row, sig???, par4, par6)     ; 38B66

          12List.7_calendarpage???(tab16row, sig???, par4, par6)
0000:0B66 212B40 ld hl,402B  ;;                   12List.7
0000:0B69 C3D600 jp 12List.7_calendarpage???(tab16row, sig???, par4, par6)     ; 7002B

          12List.8_anystring(tab16row, sig???, par4, par6)
0000:0B6C 216379 ld hl,7963  ;;                   12List.8
0000:0B6F C38200 jp 12List.8_anystring(tab16row, sig???, par4, par6)     ; 37A00

          12List.9_semistring(tab16row, sig???, par4, par6)
0000:0B72 21055D ld hl,5D05  ;;                   12List.9
0000:0B75 C3D600 jp 12List.9_semistring(tab16row, sig???, par4, par6)     ; 71D05

          12List.A_check_or_x_icon(tab16row, sig???, par4, par6)
0000:0B78 219F61 ld hl,619F  ;;                   12List.A
0000:0B7B C3D600 jp 12List.A_check_or_x_icon(tab16row, sig???, par4, par6)     ; 7219F

          yyyy_check_caplock????(par0, par2)
0000:0B7E 21A560 ld hl,60A5  ;; this gets set as Task_yyyy
0000:0B81 C35400 jp yyyy_check_caplock????(par0, par2)     ; 1A0E3

          zzzz(sig, par2, par4)
0000:0B84 21C960 ld hl,60C9  ;; this gets set as Task_zzzz
0000:0B87 C35400 jp zzzz(sig, par2, par4)     ; 1A107

          Main_menu(who, tab30.6, signal, par4, par6)
0000:0B8A 21195E ld hl,5E19  ;;                     tab30.00
0000:0B8D C3C400 jp Main_menu(who, tab30.6, signal, par4, par6)     ; 65D8E

          guess_inbox????(who, tab30.6, signal, par4, par6)
0000:0B90 21D162 ld hl,62D1  ;;                     tab30.01
0000:0B93 C3B200 jp guess_inbox????(who, tab30.6, signal, par4, par6)     ; 5A2D1

          guess_outbox????(who, tab30.6, signal, par4, par6)
0000:0B96 212568 ld hl,6825  ;;                     tab30.02
0000:0B99 C3B200 jp guess_outbox????(who, tab30.6, signal, par4, par6)     ; 5A825

          guess_createnewemail????(who, tab30.6, signal, par4, par6)
0000:0B9C 21336C ld hl,6C33  ;;                     tab30.03
0000:0B9F C3B200 jp guess_createnewemail????(who, tab30.6, signal, par4, par6)     ; 5AC33

          guess_addressbook????(who, tab30.6, signal, par6, par8)
0000:0BA2 210040 ld hl,4000  ;;                     tab30.04
0000:0BA5 C39400 jp guess_addressbook????(who, tab30.6, signal, par6, par8)     ; 44000

          Extras(who, tab30.6, signal, par4, par6)
0000:0BA8 217E65 ld hl,657E  ;;                     tab30.05
0000:0BAB C3C400 jp Extras(who, tab30.6, signal, par4, par6)     ; 664F3

          Calculator_app(who, tab30.6, signal, par4, par6)
0000:0BAE 210040 ld hl,4000  ;;                     tab30.06
0000:0BB1 C3A000 jp Calculator_app(who, tab30.6, signal, par4, par6)     ; 4C000

          Calendar_app????(who, tab30.6, signal, par4, par6)
0000:0BB4 216E40 ld hl,406E  ;;                     tab30.07
0000:0BB7 C3A600 jp Calendar_app????(who, tab30.6, signal, par4, par6)     ; 5006E

          app_0C_wakeup_splash(who, tab30.6, signal, par4, par6)
0000:0BBA 212B7A ld hl,7A2B  ;;                     tab30.0C  wakeup??? splash
0000:0BBD C3C400 jp app_0C_wakeup_splash(who, tab30.6, signal, par4, par6)     ; 679E2

          app_0D_wakeup_mailtimer????(who, tab30.6, signal, par4, par6)
0000:0BC0 21706F ld hl,6F70  ;;                     tab30.0D  wakeup??? mailtime
0000:0BC3 C3B200 jp app_0D_wakeup_mailtimer????(who, tab30.6, signal, par4, par6)     ; 5AF70

          app_0E_wakeup_other??????(who, tab30.6, signal, par4, par6)
0000:0BC6 213A7B ld hl,7B3A  ;;                     tab30.0E  wakeup??? other
0000:0BC9 C3C400 jp app_0E_wakeup_other??????(who, tab30.6, signal, par4, par6)     ; 67AF1

          app_0B_createnewuser?????(who, tab30.6, signal, par4, par6)
0000:0BCC 215162 ld hl,6251  ;;                     tab30.0B  create user??? [16:7a89]
0000:0BCF C3D000 jp app_0B_createnewuser?????(who, tab30.6, signal, par4, par6)     ; 6E251

          app_08_sent????(who, tab30.6, signal, par4, par6)
0000:0BD2 218263 ld hl,6382  ;;                     tab30.08  sent???
0000:0BD5 C3D000 jp app_08_sent????(who, tab30.6, signal, par4, par6)     ; 6E382

          app_09_settings?????(who, tab30.6, signal, par4, par6)
0000:0BD8 21116A ld hl,6A11  ;;                     tab30.09   settings???
0000:0BDB C3D000 jp app_09_settings?????(who, tab30.6, signal, par4, par6)     ; 6EA5E

          app_0A_users????(who, tab30.6, signal, par4, par6)
0000:0BDE 210071 ld hl,7100  ;;                     tab30.0A   users???
0000:0BE1 C3D000 jp app_0A_users????(who, tab30.6, signal, par4, par6)     ; 6E14D

          app_0F(who, tab30.6, signal, par4, par6)
0000:0BE4 212467 ld hl,6724  ;;                     tab30.0F
0000:0BE7 C3A600 jp app_0F(who, tab30.6, signal, par4, par6)     ; 52724

0000:0BEA 210040 ld hl,4000  
0000:0BED C3E200 jp 2F:4000     ; DC000

          Yahoo_app(par0, par2, par4)
0000:0BF0 211A6E ld hl,6E1A  ;;                     tab30.10
0000:0BF3 C3C400 jp Yahoo_app(par0, par2, par4)     ; 66DD1

0000:0BF6 214B60 ld hl,604B  
0000:0BF9 C3CA00 jp 1A:604B     ; 69EF9
0000:0BFC 212D4D ld hl,4D2D  
0000:0BFF C38E00 jp 10:4D2D     ; 40D2D
0000:0C02 21F850 ld hl,50F8  
0000:0C05 C38E00 jp 10:50F8     ; 410F8
0000:0C08 21F654 ld hl,54F6  
0000:0C0B C38E00 jp 10:54F6     ; 414F6
0000:0C0E 21B36E ld hl,6EB3  
0000:0C11 C3A600 jp 14:6EB3     ; 52EB3
0000:0C14 213240 ld hl,4032  
0000:0C17 C3C400 jp 19:4032     ; 64032
0000:0C1A 219D40 ld hl,409D  
0000:0C1D C3C400 jp 19:409D     ; 6409D
0000:0C20 21F343 ld hl,43F3  
0000:0C23 C3C400 jp 19:43F3     ; 643F3
0000:0C26 216244 ld hl,4462  
0000:0C29 C3C400 jp 19:4462     ; 64462
0000:0C2C 21F560 ld hl,60F5  
0000:0C2F C3AC00 jp 15:60F5     ; 560F5
0000:0C32 219757 ld hl,5797  
0000:0C35 C3E200 jp 2F:5797     ; DD797
0000:0C38 210C64 ld hl,640C  
0000:0C3B C3CA00 jp 1A:640C     ; 6A2BA

;; not only are these not called, but it seems that the code they refer to
;; may not exist anymore either????
0000:0C3E 211447 ld hl,4714           ;; this appears to be cruft.  jumps
0000:0C41 C3D000 jp 1B:4714     ; 6C714  ;; into middle of another function.

0000:0C44 218047 ld hl,4780           ;; this appears to be cruft.  jumps
0000:0C47 C3D000 jp 1B:4780     ; 6C780  ;; into middle of another function.

0000:0C4A 210F6F ld hl,6F0F  
0000:0C4D C3D000 jp 1B:6F0F     ; 6EF5C
0000:0C50 21D661 ld hl,61D6  
0000:0C53 C3D000 jp 1B:61D6     ; 6E1D6
0000:0C56 212156 ld hl,5621  
0000:0C59 C3D000 jp 1B:5621     ; 6D621
;; End of _REAL_LONG_ list of handles.




; StringCopy(Source, Dest)
; Return Dest
          [05C6] Strcpy(dst,src)
0000:0C5C DD210200 ld ix,0002  
0000:0C60 DD39   add ix,sp  
0000:0C62 DD5E00 ld e,(ix+00);; de = par0   (dest)
0000:0C65 DD5601 ld d,(ix+01)
0000:0C68 DD6E02 ld l,(ix+02);; hl = par2   (source)
0000:0C6B DD6603 ld h,(ix+03)
0000:0C6E 7E     ld a,(hl)  
0000:0C6F FE00   cp 00      
0000:0C71 2804   jr z,0C77   ;; done when you hit null
0000:0C73 EDA0   ldi        
0000:0C75 18F7   jr 0C6E    
0000:0C77 12     ld (de),a   ;; oops, copy the null too!
0000:0C78 DD6E00 ld l,(ix+00)
0000:0C7B DD6601 ld h,(ix+01)
0000:0C7E 7C     ld a,h      
0000:0C7F B5     or l        
0000:0C80 C9     ret         ret hl = par0  (dest)

; memcpy(wNumbytes, src, dest). Stops at wNumbytes or a zero encountered
          [05C9] strncpy(dst, src, n)
0000:0C81 DD210200 ld ix,0002  
0000:0C85 DD39   add ix,sp  
0000:0C87 DD5E00 ld e,(ix+00); DE=v3  ;; de = par0
0000:0C8A DD5601 ld d,(ix+01)
0000:0C8D DD6E02 ld l,(ix+02); HL=v2  ;; hl = par2
0000:0C90 DD6603 ld h,(ix+03)
0000:0C93 DD4E04 ld c,(ix+04); BC=v1  ;; bc = par4
0000:0C96 DD4605 ld b,(ix+05)
0000:0C99 79     ld a,c      ; v1 != 0? -> Skip ahead
0000:0C9A B0     or b        
0000:0C9B 280B   jr z,0CA8  
0000:0C9D 7E     ld a,(hl)   ; Read source byte
0000:0C9E FE00   cp 00      
0000:0CA0 28D5   jr z,0C77   ; Zero? -> Copy to dest and exit
0000:0CA2 EDA0   ldi         ; Copy byte from source to dest
0000:0CA4 78     ld a,b      
0000:0CA5 B1     or c        
0000:0CA6 20F5   jr nz,0C9D  ; Loop BC times
0000:0CA8 3E00   ld a,00    
0000:0CAA 12     ld (de),a  
0000:0CAB DD6E00 ld l,(ix+00); HL = dest
0000:0CAE DD6601 ld h,(ix+01)
0000:0CB1 7C     ld a,h      
0000:0CB2 B5     or l        
0000:0CB3 C9     ret        

;;  HL = strlen(par)
          [05CC] strlen(src)
0000:0CB4 210200 ld hl,0002  
0000:0CB7 39     add hl,sp  
0000:0CB8 5E     ld e,(hl)  
0000:0CB9 23     inc hl      
0000:0CBA 56     ld d,(hl)  
0000:0CBB EB     ex de,hl    
0000:0CBC CDC20C call HL = strlen(HL)   ;;strlen(HL) --> HL
0000:0CBF 7C     ld a,h      
0000:0CC0 B5     or l        
0000:0CC1 C9     ret        

          HL = strlen(HL)
0000:0CC2 C5     push bc     ;;save bc
0000:0CC3 010000 ld bc,0000  ;;bc = 0000, count the bytes!
0000:0CC6 7E     ld a,(hl)   ;;next byte of (HL) --> A
0000:0CC7 FE00   cp 00      
0000:0CC9 2804   jr z,0CCF   ;;if not end of string, then inc pointer, inc count
0000:0CCB 23     inc hl      
0000:0CCC 03     inc bc      
0000:0CCD 18F7   jr 0CC6     ;;do another
0000:0CCF 69     ld l,c      ;;found end, count --> HL
0000:0CD0 60     ld h,b      
0000:0CD1 C1     pop bc      ;;restore orig BC
0000:0CD2 C9     ret        

;; strcompare(str1, str2), match case, any length
          [05CF] strcompare(str1, str2)
0000:0CD3 210200 ld hl,0002  
0000:0CD6 39     add hl,sp  
0000:0CD7 5E     ld e,(hl)  
0000:0CD8 23     inc hl      
0000:0CD9 56     ld d,(hl)  
0000:0CDA 23     inc hl      
0000:0CDB 4E     ld c,(hl)  
0000:0CDC 23     inc hl      
0000:0CDD 46     ld b,(hl)  
0000:0CDE C5     push bc    
0000:0CDF E1     pop hl      
0000:0CE0 3E01   ld a,01     ;; match case
0000:0CE2 010000 ld bc,0000  
0000:0CE5 CD530D call 0D53   ;; string compare
0000:0CE8 7C     ld a,h      
0000:0CE9 B5     or l        
0000:0CEA C9     ret        

;; strcompare(str1, str2), any case, any length
          [05D2] strcompare_insens(str1, str2)
0000:0CEB 210200 ld hl,0002  
0000:0CEE 39     add hl,sp  
0000:0CEF 5E     ld e,(hl)  
0000:0CF0 23     inc hl      
0000:0CF1 56     ld d,(hl)  
0000:0CF2 23     inc hl      
0000:0CF3 4E     ld c,(hl)  
0000:0CF4 23     inc hl      
0000:0CF5 46     ld b,(hl)  
0000:0CF6 C5     push bc    
0000:0CF7 E1     pop hl      
0000:0CF8 010000 ld bc,0000  
0000:0CFB AF     xor a       ;; any case
0000:0CFC CD530D call 0D53   ;; string compare
0000:0CFF 7C     ld a,h      
0000:0D00 B5     or l        
0000:0D01 C9     ret        

;; strcompare(str1, str2, len), match case, fixed length
          [05D5] strcompare(str1, str2, n)
0000:0D02 DD210200 ld ix,0002  
0000:0D06 DD39   add ix,sp  
0000:0D08 DD5E00 ld e,(ix+00); DE=v3
0000:0D0B DD5601 ld d,(ix+01)
0000:0D0E DD6E02 ld l,(ix+02); HL=v2
0000:0D11 DD6603 ld h,(ix+03)
0000:0D14 DD4E04 ld c,(ix+04); BC=v1  ;; n
0000:0D17 DD4605 ld b,(ix+05)
0000:0D1A 78     ld a,b      
0000:0D1B B1     or c        ; v1=0? -> Return 0
0000:0D1C 2807   jr z,0D25  
0000:0D1E 3E01   ld a,01     ;; match case
0000:0D20 CD530D call 0D53   ;; string compare
0000:0D23 1803   jr 0D28     ; Return
0000:0D25 210000 ld hl,0000  
0000:0D28 7C     ld a,h      
0000:0D29 B5     or l        
0000:0D2A C9     ret        

;; strcompare(str1, str2, len), any case, fixed length
          [05D8] strcompare_insens(str1, str2, n)
0000:0D2B DD210200 ld ix,0002  
0000:0D2F DD39   add ix,sp  
0000:0D31 DD5E00 ld e,(ix+00)
0000:0D34 DD5601 ld d,(ix+01)
0000:0D37 DD6E02 ld l,(ix+02)
0000:0D3A DD6603 ld h,(ix+03)
0000:0D3D DD4E04 ld c,(ix+04)
0000:0D40 DD4605 ld b,(ix+05)
0000:0D43 78     ld a,b      
0000:0D44 B1     or c        
0000:0D45 2806   jr z,0D4D  
0000:0D47 AF     xor a       ;; any case
0000:0D48 CD530D call 0D53   ;; string compare
0000:0D4B 1803   jr 0D50    
0000:0D4D 210000 ld hl,0000  
0000:0D50 7C     ld a,h      
0000:0D51 B5     or l        
0000:0D52 C9     ret        

;;string compare(DE,HL,A)  ((A = 0 for any case ,  A = nonzero for match case))
0000:0D53 F5     push af     ; Save vars
0000:0D54 C5     push bc    
0000:0D55 D5     push de    
0000:0D56 DDE1   pop ix      ; IX=DE
0000:0D58 E5     push hl    
0000:0D59 FDE1   pop iy      ; IY=HL
0000:0D5B CDC20C call HL = strlen(HL)   ; STRLEN(HL) ;; HL = strlen(HL)
0000:0D5E 4D     ld c,l      ; BC=string length of HL
0000:0D5F 44     ld b,h      
0000:0D60 EB     ex de,hl    ; Get length of string(DE)
0000:0D61 CDC20C call HL = strlen(HL)   ;; hl = strlen(HL)
0000:0D64 5D     ld e,l      ; DE=string length of (DE)
0000:0D65 54     ld d,h      
0000:0D66 78     ld a,b      
0000:0D67 B2     or d        
0000:0D68 200A   jr nz,0D74  ; Both zero length? -> Return 0
0000:0D6A 79     ld a,c      
0000:0D6B B3     or e        
0000:0D6C 2006   jr nz,0D74  
0000:0D6E C1     pop bc      
0000:0D6F F1     pop af      
0000:0D70 210000 ld hl,0000  
0000:0D73 C9     ret        
0000:0D74 AF     xor a      
0000:0D75 ED42   sbc hl,bc   ; Subtract 2nd string length from first
0000:0D77 3805   jr c,0D7E   ; Less? -> Skip
0000:0D79 60     ld h,b      ; HL=BC
0000:0D7A 69     ld l,c      
0000:0D7B 4B     ld c,e      ; BC=DE
0000:0D7C 42     ld b,d      
0000:0D7D EB     ex de,hl    ; Swap HL, DE  ;; (bc swapped with de)
0000:0D7E E1     pop hl      ;; hl is now the calling bc value
0000:0D7F 7C     ld a,h      ; HL=0? -> Skip
0000:0D80 B5     or l        
0000:0D81 2808   jr z,0D8B  
0000:0D83 E5     push hl    
0000:0D84 ED42   sbc hl,bc   ; HL > BC? -> Skip
0000:0D86 E1     pop hl      
0000:0D87 3002   jr nc,0D8B  
0000:0D89 4D     ld c,l      ; Else BC=HL
0000:0D8A 44     ld b,h      
0000:0D8B F1     pop af      ; Restore A
0000:0D8C CD900D call 0D90   ;;do the compare now
0000:0D8F C9     ret        

;; compare string (IX) to string (IY), bc is length to compare, A is flag indicating case sensitive
0000:0D90 F5     push af     ;; save caseflag
;; loop
0000:0D91 F1     pop af      
0000:0D92 F5     push af     ;; A is caseflag
0000:0D93 B7     or a        
0000:0D94 280E   jr z,0DA4   ;; jump if case sensitive flag = 0
;; here if case sensitive compare (a <> 0) ((flag was set))
0000:0D96 DD7E00 ld a,(ix+00); Read (IX), compare with (IY)
0000:0D99 FDBE00 cp (iy+00)  
0000:0D9C 281C   jr z,0DBA   ; Same? -> Next byte
0000:0D9E 3028   jr nc,0DC8  ; Greater? -> Return 1
0000:0DA0 182B   jr 0DCD     ; Less? -> Return -1
;;
0000:0DA2 1816   jr 0DBA     ; Next byte
;; here if case insenstive compare (A = 0)
0000:0DA4 FD7E00 ld a,(iy+00); Read (IY)
0000:0DA7 CDD20D call 0DD2   ; Upcase(?)
0000:0DAA 57     ld d,a      
0000:0DAB DD7E00 ld a,(ix+00)
0000:0DAE CDD20D call 0DD2   ; Upcase(?)
0000:0DB1 BA     cp d        ; Strcmp
0000:0DB2 2806   jr z,0DBA   ; Same? -> Keep looping
0000:0DB4 3012   jr nc,0DC8  ; More? -> Return 1
0000:0DB6 1815   jr 0DCD     ; Less? -> Return -1
0000:0DB8 1800   jr 0DBA     ; Next byte
0000:0DBA DD23   inc ix      ; Next byte
0000:0DBC FD23   inc iy      
0000:0DBE 0B     dec bc      
0000:0DBF 78     ld a,b      
0000:0DC0 B1     or c        
0000:0DC1 20CE   jr nz,0D91  ; Loop BC times
;;
0000:0DC3 210000 ld hl,0000  
0000:0DC6 1808   jr 0DD0     ;; ret 0, they match
;;
0000:0DC8 210100 ld hl,0001  ;;ret 1
0000:0DCB 1803   jr 0DD0    
;;
0000:0DCD 21FFFF ld hl,FFFF  ;; ret -1
;;
0000:0DD0 F1     pop af      
0000:0DD1 C9     ret        



; If upper case, return
; If lower case, convert to upper case
; If less than E0 or equal to F7, return
; Otherwise, subtract 20h
0000:0DD2 FE61   cp 61       ;; A < #61 ?
0000:0DD4 D8     ret c       ;; done, no change, if less than 'a'
;;
0000:0DD5 FE7B   cp 7B       ;; A < #7b ?
0000:0DD7 3003   jr nc,0DDC  ;; jp if > than 'z'  (i.e. not lower case)
;;
0000:0DD9 D620   sub 20      ;; here, if lower case, make it upper case
0000:0DDB C9     ret         ;; done
;;
0000:0DDC FEE0   cp E0       ;; (11100000)
0000:0DDE D8     ret c       ;; done, if < #E0   (no change, if higher than 'z', and less than #E0)
;;
;;
0000:0DDF FEF7   cp F7       ;; (11110111)  don't change these special chars (wonder what they are???)
0000:0DE1 C8     ret z      
0000:0DE2 FEFF   cp FF       ;; (11111111)
0000:0DE4 C8     ret z      
;;
0000:0DE5 D620   sub 20      ;; if #DF > A > #FF , sub #20   (is this case change, too??? rev vid, maybe???)
0000:0DE7 C9     ret        

;; string concatenate   par0 = par0 + par2
          [05BA] strcat(dest, src)
0000:0DE8 DD210200 ld ix,0002  
0000:0DEC DD39   add ix,sp  
0000:0DEE DD5E00 ld e,(ix+00);; de = par0
0000:0DF1 DD5601 ld d,(ix+01)
0000:0DF4 DD4E02 ld c,(ix+02);; bc = par2
0000:0DF7 DD4603 ld b,(ix+03)
0000:0DFA D5     push de    
0000:0DFB E1     pop hl      
0000:0DFC CDC20C call HL = strlen(HL)   ;; hl = strlen(par0)
0000:0DFF 19     add hl,de   ;; hl points at end of par0 (just past, dest for concat)
0000:0E00 DDE5   push ix    
0000:0E02 C5     push bc    
0000:0E03 E5     push hl    
0000:0E04 CDC605 call Strcpy(dst,src)   ; String copy(BC -> HL) ;; par2 -> end of par0
0000:0E07 E1     pop hl      
0000:0E08 C1     pop bc      
0000:0E09 DDE1   pop ix      
0000:0E0B DD6E00 ld l,(ix+00);; point hl at result
0000:0E0E DD6601 ld h,(ix+01)
0000:0E11 7C     ld a,h      
0000:0E12 B5     or l        
0000:0E13 C9     ret        

;; str copy(str1, str2, n)  copy n chars from str2 to end of str1
          [05BD] strncat(dest, src, n)
0000:0E14 DD210200 ld ix,0002  
0000:0E18 DD39   add ix,sp  
0000:0E1A DD5E00 ld e,(ix+00);; de = par1
0000:0E1D DD5601 ld d,(ix+01)
0000:0E20 D5     push de    
0000:0E21 E1     pop hl      ;; hl = par1
0000:0E22 CDC20C call HL = strlen(HL)   ;; hl = strlen(par1)
0000:0E25 19     add hl,de   ;; hl points at end of par1
0000:0E26 EB     ex de,hl    ;; de points at end of par1
0000:0E27 DD6E02 ld l,(ix+02);; hl = par2
0000:0E2A DD6603 ld h,(ix+03)
0000:0E2D DD4E04 ld c,(ix+04);; bc = par3
0000:0E30 DD4605 ld b,(ix+05)
0000:0E33 79     ld a,c      
0000:0E34 B0     or b        
0000:0E35 280D   jr z,0E44   ;; jp if bc = 0
0000:0E37 DDE5   push ix    
0000:0E39 C5     push bc    
0000:0E3A E5     push hl    
0000:0E3B D5     push de    
0000:0E3C CDC905 call strncpy(dst, src, n)   ;; mem copy
0000:0E3F D1     pop de      
0000:0E40 E1     pop hl      
0000:0E41 C1     pop bc      
0000:0E42 DDE1   pop ix      
0000:0E44 DD6E00 ld l,(ix+00);; hl = par1
0000:0E47 DD6601 ld h,(ix+01)
0000:0E4A 7C     ld a,h      
0000:0E4B B5     or l        
0000:0E4C C9     ret        





;; returns pointer to the first occurrence of char in string
;;
          [05C0] strchr(s1, c)
0000:0E4D 210200 ld hl,0002  
0000:0E50 39     add hl,sp  
0000:0E51 5E     ld e,(hl)  
0000:0E52 23     inc hl      
0000:0E53 56     ld d,(hl)  
0000:0E54 23     inc hl      
0000:0E55 4E     ld c,(hl)  
0000:0E56 EB     ex de,hl    
0000:0E57 59     ld e,c      
0000:0E58 E5     push hl    
0000:0E59 CDC20C call HL = strlen(HL)  
0000:0E5C 4D     ld c,l      
0000:0E5D 44     ld b,h      
0000:0E5E 03     inc bc      
0000:0E5F E1     pop hl      
0000:0E60 78     ld a,b      
0000:0E61 B1     or c        
0000:0E62 2808   jr z,0E6C   ;; ret 0
0000:0E64 7B     ld a,e      
0000:0E65 EDB1   cpir        
0000:0E67 2003   jr nz,0E6C  ;; ret 0
0000:0E69 2B     dec hl      
0000:0E6A 1803   jr 0E6F     ;; ret hl
;;
0000:0E6C 210000 ld hl,0000  
;;
0000:0E6F 7C     ld a,h      
0000:0E70 B5     or l        
0000:0E71 C9     ret        



          [05C3] strstr(s1, s2)
0000:0E72 210200 ld hl,0002  
0000:0E75 39     add hl,sp  
0000:0E76 4E     ld c,(hl)  
0000:0E77 23     inc hl      
0000:0E78 46     ld b,(hl)  
0000:0E79 23     inc hl      
0000:0E7A C5     push bc    
0000:0E7B DDE1   pop ix      ;; s1                 'baddog'
;;
0000:0E7D 5E     ld e,(hl)  
0000:0E7E 23     inc hl      
0000:0E7F 56     ld d,(hl)  
0000:0E80 D5     push de    
0000:0E81 FDE1   pop iy      ;; s2                  'dog'
;;
0000:0E83 EB     ex de,hl    
0000:0E84 CDC20C call HL = strlen(HL)  
0000:0E87 7C     ld a,h      
0000:0E88 B5     or l        
0000:0E89 284A   jr z,0ED5   ;; jp if len s2 is 0
;;
0000:0E8B EB     ex de,hl    ;; de = len s2            3
;;
0000:0E8C 69     ld l,c      ;; s1
0000:0E8D 60     ld h,b      
0000:0E8E CDC20C call HL = strlen(HL)  
0000:0E91 7C     ld a,h      
0000:0E92 B5     or l        
0000:0E93 2846   jr z,0EDB   ;; jp if len s1 is 0
;;
0000:0E95 4D     ld c,l      
0000:0E96 44     ld b,h      ;; bc = len s1             6
;;
0000:0E97 ED52   sbc hl,de   ;; len s1 - len s2
0000:0E99 3840   jr c,0EDB   ;; jp if len s1 is < len s2        
;;
0000:0E9B DDE5   push ix    
0000:0E9D E1     pop hl      ;; hl = s1
;;
;; loop
0000:0E9E FD7E00 ld a,(iy+00);; a = 1st char of s2        d
0000:0EA1 EDB1   cpir        ;; search s1 for match
;;
0000:0EA3 03     inc bc      ;;                            4  3
;;
0000:0EA4 FDE5   push iy    
0000:0EA6 D5     push de    
0000:0EA7 C5     push bc    
0000:0EA8 E5     push hl    
;;
0000:0EA9 201F   jr nz,0ECA  ;; jp if no match found
;;
;; loop2
0000:0EAB 1B     dec de      ;; len_s2 --                  2
0000:0EAC 7A     ld a,d      
0000:0EAD B3     or e        
0000:0EAE 2816   jr z,0EC6   ;; if 0, ret hl - 1  (we found match)
;;
0000:0EB0 0B     dec bc      ;;                            3
0000:0EB1 78     ld a,b      
0000:0EB2 B1     or c        
0000:0EB3 2815   jr z,0ECA   ;; if 0, ret hl = 0
;;
0000:0EB5 FD23   inc iy      ;; next char in s2
0000:0EB7 FD7E00 ld a,(iy+00)
0000:0EBA BE     cp (hl)    
0000:0EBB 23     inc hl      
0000:0EBC 28ED   jr z,0EAB   ;; loop2 if char matched
;;
;; here if any char doesn't match while doing in loop2.
;; We
0000:0EBE E1     pop hl      ;; hl is pionting at next char to try in s1
0000:0EBF C1     pop bc      
0000:0EC0 0B     dec bc      ;; len_s1 --
0000:0EC1 D1     pop de      
0000:0EC2 FDE1   pop iy      
0000:0EC4 18D8   jr 0E9E     ;; loop
;;
;; ret (hl - 1)    which is position of first char of match
0000:0EC6 E1     pop hl      
0000:0EC7 2B     dec hl      
0000:0EC8 1804   jr 0ECE    
;;
;;
;; ret hl = 0
0000:0ECA E1     pop hl      
0000:0ECB 210000 ld hl,0000  
;;
0000:0ECE C1     pop bc      
0000:0ECF D1     pop de      
0000:0ED0 FDE1   pop iy      
;;
0000:0ED2 7C     ld a,h      
0000:0ED3 B5     or l        
0000:0ED4 C9     ret        
;;
;; here when len(s2) was 0
0000:0ED5 DDE5   push ix     ;; s1
0000:0ED7 E1     pop hl      ;; ret s1
0000:0ED8 7C     ld a,h      
0000:0ED9 B5     or l        
0000:0EDA C9     ret        
;;
;; here when len(s1) was 0
;; here when len(s1) < len(s2)
0000:0EDB 210000 ld hl,0000  
0000:0EDE 7C     ld a,h      
0000:0EDF B5     or l        
0000:0EE0 C9     ret        



          [059F] memcpy(dst,src,n)
0000:0EE1 DD210200 ld ix,0002  
0000:0EE5 DD39   add ix,sp  
0000:0EE7 DD5E00 ld e,(ix+00);; dest
0000:0EEA DD5601 ld d,(ix+01)
0000:0EED DD6E02 ld l,(ix+02);; source
0000:0EF0 DD6603 ld h,(ix+03)
0000:0EF3 DD4E04 ld c,(ix+04);; n
0000:0EF6 DD4605 ld b,(ix+05)
0000:0EF9 79     ld a,c      
0000:0EFA B0     or b        
0000:0EFB 2802   jr z,0EFF   ;; jp if n=0 (nothing to copy) (ldir tests for 0 after decrement)
0000:0EFD EDB0   ldir        ;; do copy
0000:0EFF DD6E00 ld l,(ix+00)
0000:0F02 DD6601 ld h,(ix+01);; ret dest
0000:0F05 7C     ld a,h      
0000:0F06 B5     or l        
0000:0F07 C9     ret        

;; overlap_safe_copy(dest, source, n)
          [05A2] memmov(dst,src,n)
0000:0F08 DD210200 ld ix,0002  
0000:0F0C DD39   add ix,sp  
0000:0F0E DD5E00 ld e,(ix+00)
0000:0F11 DD5601 ld d,(ix+01)
0000:0F14 DD6E02 ld l,(ix+02)
0000:0F17 DD6603 ld h,(ix+03)
0000:0F1A DD4E04 ld c,(ix+04)
0000:0F1D DD4605 ld b,(ix+05)
0000:0F20 79     ld a,c      
0000:0F21 B0     or b        
0000:0F22 2814   jr z,0F38   ;; jp if nothing to copy
0000:0F24 E5     push hl    
0000:0F25 ED52   sbc hl,de  
0000:0F27 E1     pop hl      
0000:0F28 300C   jr nc,0F36  ;; if src is ahead of dest, use ldir, it's safe
0000:0F2A 280C   jr z,0F38   ;; sourc = dest???? wouldn't that "not carry" thus "not get here"??????
0000:0F2C EB     ex de,hl    
0000:0F2D 09     add hl,bc  
0000:0F2E 2B     dec hl      
0000:0F2F EB     ex de,hl    ;; dest = dest + n - 1
0000:0F30 09     add hl,bc  
0000:0F31 2B     dec hl      ;; src = src + n - 1
0000:0F32 EDB8   lddr        ;; copy backwards, so as not to whomp on source in case of overlap
0000:0F34 1802   jr 0F38    
0000:0F36 EDB0   ldir        
0000:0F38 DD6E00 ld l,(ix+00)
0000:0F3B DD6601 ld h,(ix+01)
0000:0F3E 7C     ld a,h      
0000:0F3F B5     or l        
0000:0F40 C9     ret        

;; memcompare(a, b, n)
          [05A5] memcompare(a,b,n)
0000:0F41 DD210200 ld ix,0002  
0000:0F45 DD39   add ix,sp  
0000:0F47 DD5E00 ld e,(ix+00);; va
0000:0F4A DD5601 ld d,(ix+01)
0000:0F4D DD6E02 ld l,(ix+02);; vb
0000:0F50 DD6603 ld h,(ix+03)
0000:0F53 DD4E04 ld c,(ix+04);; vn
0000:0F56 DD4605 ld b,(ix+05)
0000:0F59 79     ld a,c      ;; if vn = 0, ret 0
0000:0F5A B0     or b        
0000:0F5B 280D   jr z,0F6A  
0000:0F5D 3E01   ld a,01     ;; A = #01
0000:0F5F D5     push de     ;; IX = va
0000:0F60 DDE1   pop ix      
0000:0F62 E5     push hl     ;; IY = vb
0000:0F63 FDE1   pop iy      
0000:0F65 CD900D call 0D90   ;; Do string compare.  ret will be +1, 0, or -1
0000:0F68 1803   jr 0F6D     ;; ret(result)
0000:0F6A 210000 ld hl,0000  
0000:0F6D 7C     ld a,h      
0000:0F6E B5     or l        
0000:0F6F C9     ret        

;; memfill(dest, val, n)
          [05A8] memfill(dst,val,n)
0000:0F70 DD210200 ld ix,0002  
0000:0F74 DD39   add ix,sp  
0000:0F76 DD6E00 ld l,(ix+00);; hl = par0  (dest)
0000:0F79 DD6601 ld h,(ix+01)
0000:0F7C DD5E02 ld e,(ix+02);; e = par2 (fill byte)
0000:0F7F DD4E04 ld c,(ix+04);; par3 (n)
0000:0F82 DD4605 ld b,(ix+05)
0000:0F85 78     ld a,b      
0000:0F86 B1     or c        
0000:0F87 280B   jr z,0F94   ;; done if n = 0
0000:0F89 73     ld (hl),e   ;; fill first byte, n--
0000:0F8A 0B     dec bc      
0000:0F8B 78     ld a,b      
0000:0F8C B1     or c        
0000:0F8D 2805   jr z,0F94   ;; done if n = 0
0000:0F8F 5D     ld e,l      ;; fill rest
0000:0F90 54     ld d,h      
0000:0F91 13     inc de      
0000:0F92 EDB0   ldir        
0000:0F94 DD6E00 ld l,(ix+00);; ret hl = dest
0000:0F97 DD6601 ld h,(ix+01)
0000:0F9A 7C     ld a,h      
0000:0F9B B5     or l        
0000:0F9C C9     ret        


;; Load_buffer_efbe (e = source_page, iy = source_offset, bc = n, a = dir)
;; params are:   E = page
;;              BC = n
;;               A = flag, ascending or decending pointers (what's the difference, unless source overlaps buffer???)
;;              IY = window pointer
;; on return bc = n actually moved, and hl = n left for next time
0000:0F9D DDE5   push ix     ; Save IX
0000:0F9F F5     push af     ; Save AF
0000:0FA0 3E01   ld a,01    
0000:0FA2 D308   out (08),a  ;; slot8000 device = ram
0000:0FA4 7B     ld a,e      
0000:0FA5 D307   out (07),a  ;; slot8000 page = E
;;
0000:0FA7 78     ld a,b      
0000:0FA8 FE04   cp 04       ;; b - 4
0000:0FAA 3005   jr nc,0FB1  ;; jp if BC >= #0400,  (n >= 1k)
;;
;; n < 1k  (it will all fit in buffer)
0000:0FAC 210000 ld hl,0000  ;; else HL = #0000...
0000:0FAF 1807   jr 0FB8     ;; ...and skip over next
;;
;; n >= 1k  (figger out how much will/won't fit in buffer)
0000:0FB1 C5     push bc     ;;
0000:0FB2 E1     pop hl      ;;
0000:0FB3 010004 ld bc,0400  ;; bc = #0400     , this much will fit
0000:0FB6 ED42   sbc hl,bc   ;; HL = BC - #0400, this much left over (hl is number in excess of 1k)
;;
0000:0FB8 F1     pop af      ;; A is dir flag
0000:0FB9 C5     push bc     ;; Save n_thistime
0000:0FBA E5     push hl     ;; save n_leftfornexttime
0000:0FBB B7     or a        ;; dir up or down?
0000:0FBC 2825   jr z,0FE3   ;; A = 0 means down
;;
;; a was not 0, up
0000:0FBE DD21BDEF ld ix,virtual_rambuff  ;; point at begin of 1k ram buffer
;; loop
0000:0FC2 FD7E00 ld a,(iy+00);; grab byte from source...
0000:0FC5 DD7700 ld (ix+00),a;; ...and put it in buffer
0000:0FC8 DD23   inc ix      ;; move ptrs ahead 1
0000:0FCA FD23   inc iy      
;;
0000:0FCC FDE5   push iy     ;; check if we moved out of window.  (8000 - bfff)
0000:0FCE E1     pop hl      
0000:0FCF 7C     ld a,h      
0000:0FD0 FEC0   cp C0       ;; Zero means we moved out of window...
0000:0FD2 2008   jr nz,0FDC  ;; ...skip ahead if we didn't,
;;
0000:0FD4 1C     inc e       ;; else slide window forward a page...
0000:0FD5 7B     ld a,e      
0000:0FD6 D307   out (07),a  
0000:0FD8 FD210080 ld iy,8000  ;; ...and move pointer to end of window.
;;
0000:0FDC 0B     dec bc      ;; dec n_thistime
0000:0FDD 78     ld a,b      ; Loop 'til BC=0
0000:0FDE B1     or c        
0000:0FDF 20E1   jr nz,0FC2  
0000:0FE1 1823   jr 1006     ; Exit
;;
;; a was 0, down
0000:0FE3 DD21BCF3 ld ix,F3BC  ;; point at END of 1k ram buffer (same buffer as above)
;; loop2
0000:0FE7 FD7E00 ld a,(iy+00)
0000:0FEA DD7700 ld (ix+00),a
0000:0FED DD2B   dec ix      ;; move ptrs back 1
0000:0FEF FD2B   dec iy      
;;
0000:0FF1 FDE5   push iy     ;; check if we moved out of window.   (8000 - bfff)
0000:0FF3 E1     pop hl      
0000:0FF4 7C     ld a,h      
0000:0FF5 FE80   cp 80       ;; carry means we backed out of window...
0000:0FF7 3008   jr nc,1001  ;; ...skip ahead if we didn't,
;;
0000:0FF9 1D     dec e       ;; else, slide window back a page...
0000:0FFA 7B     ld a,e      
0000:0FFB D307   out (07),a  
0000:0FFD FD21FFBF ld iy,BFFF  ;; ...and move pointer to beginning of window.
;;
0000:1001 0B     dec bc      
0000:1002 78     ld a,b      
0000:1003 B1     or c        
0000:1004 20E1   jr nz,0FE7  ;; loop2 if bc not 0
;; exit
0000:1006 E1     pop hl      ;; hl = n_leftfornexttime
0000:1007 C1     pop bc      ;; bc = n_thistime
0000:1008 DDE1   pop ix      ;; restore saved ix
0000:100A C9     ret        


;; Save_buffer_efbe (d = dest_page, ix = dest_offset, bc = n, a = dir)
;; bc is n, which this time is already limited to the size of buffer, because the load_buffer_efbe limited it.
;; load also put excess n into hl, and it is still there.  before return, though, we put it in bc, so caller
;; doesn't need to be bothered.  The result is that this pair can be called in a loop, till bc is 0, without worrying
;; about how many bytes moved in any particular call.  This lets an arbitrarily large number of bytes to be copied
;; via a 1k buffer.
0000:100B FDE5   push iy    
0000:100D E5     push hl     ;; excess_n  (notice where this gets popped)
0000:100E F5     push af    
0000:100F 3E01   ld a,01    
0000:1011 D308   out (08),a  ; Port 8 = 1
0000:1013 7A     ld a,d      
0000:1014 D307   out (07),a  ; P7 = D
0000:1016 F1     pop af      
0000:1017 B7     or a        
0000:1018 2825   jr z,103F   ; A=0? -> 103F
0000:101A FD21BDEF ld iy,virtual_rambuff  ; IY=EFBE  ;; start of a 1k-byte buffer in ram
0000:101E FD7E00 ld a,(iy+00); (IX) = (IY)
0000:1021 DD7700 ld (ix+00),a
0000:1024 DD23   inc ix      ; Next byte
0000:1026 FD23   inc iy      
0000:1028 DDE5   push ix    
0000:102A E1     pop hl      
0000:102B 7C     ld a,h      
0000:102C FEC0   cp C0       ; Dest = C000?
0000:102E 2008   jr nz,1038  
0000:1030 14     inc d       ; INC bank (P7)
0000:1031 7A     ld a,d      
0000:1032 D307   out (07),a  
0000:1034 DD210080 ld ix,8000  ; Reset IX to 8000
0000:1038 0B     dec bc      
0000:1039 78     ld a,b      
0000:103A B1     or c        
0000:103B 20E1   jr nz,101E  
0000:103D 1823   jr 1062    
;;
0000:103F FD21BCF3 ld iy,F3BC  
0000:1043 FD7E00 ld a,(iy+00)
0000:1046 DD7700 ld (ix+00),a
0000:1049 DD2B   dec ix      
0000:104B FD2B   dec iy      
0000:104D DDE5   push ix    
0000:104F E1     pop hl      
0000:1050 7C     ld a,h      
0000:1051 FE80   cp 80      
0000:1053 3008   jr nc,105D  
0000:1055 15     dec d      
0000:1056 7A     ld a,d      
0000:1057 D307   out (07),a  
0000:1059 DD21FFBF ld ix,BFFF  
0000:105D 0B     dec bc      
0000:105E 78     ld a,b      
0000:105F B1     or c        
0000:1060 20E1   jr nz,1043  
0000:1062 C1     pop bc      ;; now bc has excess_n
0000:1063 FDE1   pop iy      
0000:1065 C9     ret        



;; [#05AB] Copy_virtual(dest_page, dest_offset, source_page, source_offset, n)
;; preserves slot8000page.
          [05AB] Copy_virtual(dst_pg, dst_off, src_pg, src_off, n)
0000:1066 DB07   in a,(07)   ; Read Port 7
0000:1068 F5     push af     ; Save it
0000:1069 FD210400 ld iy,0004  ; Point to stacked values
0000:106D FD39   add iy,sp  
0000:106F FD5600 ld d,(iy+00); D = last param (ignore MSB) ;; d = dest_page
0000:1072 FD6E02 ld l,(iy+02); HL= 2nd param
0000:1075 FD6603 ld h,(iy+03)
0000:1078 010080 ld bc,8000  ; BC = 8000h  ;; add slot8000 offset
0000:107B 09     add hl,bc   ; IX = HL + 8000h
0000:107C E5     push hl    
0000:107D DDE1   pop ix      ;; ix is param2 + 8000        ;; ix = dest_offset
0000:107F FD5E04 ld e,(iy+04); E = 3rd param (ignore MSB)  ;; e = source_page
0000:1082 FD6E06 ld l,(iy+06); HL = 4th param
0000:1085 FD6607 ld h,(iy+07)
0000:1088 09     add hl,bc   ; IY = HL + 8000h  ;; add slot8000 offset
0000:1089 FD4E08 ld c,(iy+08); BC = 5th param
0000:108C FD4609 ld b,(iy+09)
0000:108F E5     push hl    
0000:1090 FDE1   pop iy      ;; param4 + 8000              ;;  iy = source_offset
0000:1092 78     ld a,b      ; v5 != 0? -> 10A2
0000:1093 B1     or c        
0000:1094 280C   jr z,10A2   ;; jump if v5 = 0  (done if n=0)
;;
0000:1096 3E01   ld a,01     ;; dir is forward
0000:1098 CD9D0F call 0F9D   ;; Load_buffer_efbe (e = source_page, iy = source_offset, bc = n, a = dir)
0000:109B 3E01   ld a,01     ;; dir is forward
0000:109D CD0B10 call 100B   ;; Save_buffer_efbe (d = dest_page, ix = dest_offset, bc = n, a = dir)
0000:10A0 18F0   jr 1092     ; Loop back
;;
0000:10A2 F1     pop af      ; Restore Port 7
0000:10A3 D307   out (07),a  
0000:10A5 7C     ld a,h      ; Return HL
0000:10A6 B5     or l        
0000:10A7 C9     ret        


;; [05ae]  Copy_virtual_overlapsafe(dest_page, dest_offset, source_page, source_offset, n)
          [05AE] Copy_virtual_overlapsafe(dst_pg, dst_off, src_pg, src_off, n)
0000:10A8 DB07   in a,(07)  
0000:10AA F5     push af     ;; save ram page
0000:10AB FD210400 ld iy,0004  ;; skip over ret addr, and above push
0000:10AF FD39   add iy,sp  
0000:10B1 FD5600 ld d,(iy+00);; d = dest page
0000:10B4 FD5E04 ld e,(iy+04);; e = source page
0000:10B7 FD4E02 ld c,(iy+02)
0000:10BA FD4603 ld b,(iy+03);; bc = dest offset
0000:10BD FD6E06 ld l,(iy+06)
0000:10C0 FD6607 ld h,(iy+07);; hl = source offset
0000:10C3 7B     ld a,e      
0000:10C4 BA     cp d        ;; sourcepage - destpage
0000:10C5 3839   jr c,1100   ;; if sourcepage lower, do backwards copy
0000:10C7 200A   jr nz,10D3  ;; jp if not in samepage , do forward copy
0000:10C9 AF     xor a      
0000:10CA ED42   sbc hl,bc   ;; srcoff - destoff
0000:10CC 3832   jr c,1100   ;; if destoff > srcoff , do backwards
0000:10CE 2003   jr nz,10D3  ;; if srcoff <> destoff , do forwards
0000:10D0 C35611 jp 1156     ;; if srcoff = destoff , were done
;;
;; forward copy
0000:10D3 FD6E02 ld l,(iy+02)
0000:10D6 FD6603 ld h,(iy+03);; hl = dest offset
0000:10D9 010080 ld bc,8000  
0000:10DC 09     add hl,bc  
0000:10DD E5     push hl    
0000:10DE DDE1   pop ix      ;; ix = dest pointer
0000:10E0 FD6E06 ld l,(iy+06)
0000:10E3 FD6607 ld h,(iy+07)
0000:10E6 09     add hl,bc   ;; hl = source pointer
0000:10E7 FD4E08 ld c,(iy+08)
0000:10EA FD4609 ld b,(iy+09);; bc = n
0000:10ED E5     push hl    
0000:10EE FDE1   pop iy      ;; iy = source pointer
;;
;; fwd loop
0000:10F0 78     ld a,b      
0000:10F1 B1     or c        
0000:10F2 2862   jr z,1156   ;; done when n = 0
;;
0000:10F4 3E01   ld a,01     ;; dir is forward
0000:10F6 CD9D0F call 0F9D   ;; Load_buffer_efbe (e = source_page, iy = source_offset, bc = n, a = dir)
0000:10F9 3E01   ld a,01     ;; dir is forward
0000:10FB CD0B10 call 100B   ;; Save_buffer_efbe (d = dest_page, ix = dest_offset, bc = n, a = dir)
0000:10FE 18F0   jr 10F0     ;; fwd loop
;;
;; backwards copy
0000:1100 AF     xor a      
0000:1101 FD7E09 ld a,(iy+09);; A = hi byte of n
;; move pages to last page
0000:1104 FE40   cp 40      
0000:1106 3806   jr c,110E   ;; while A > 40,
0000:1108 D640   sub 40      ;;    A = A - #40
0000:110A 14     inc d       ;;    inc dest page
0000:110B 1C     inc e       ;;    inc src page
0000:110C 18F6   jr 1104    
;;
0000:110E 47     ld b,a      
0000:110F FD4E08 ld c,(iy+08);; bc = n_incurrentpage
0000:1112 FD6E02 ld l,(iy+02)
0000:1115 FD6603 ld h,(iy+03)
0000:1118 09     add hl,bc   ;; offset to end ofdest
0000:1119 7C     ld a,h      
0000:111A FE40   cp 40      
0000:111C 3804   jr c,1122   ;; if offset is in page, skip ahead
0000:111E D640   sub 40      ;; else lower offset by 4000, and inc page
0000:1120 14     inc d      
0000:1121 67     ld h,a      
;;
0000:1122 C5     push bc     ;; save n_incurrentpage
0000:1123 01FF7F ld bc,7FFF  
0000:1126 09     add hl,bc   ;; add window offset, hl points at last byte of dest
0000:1127 C1     pop bc      ;; bc = n_incurrentpage
0000:1128 E5     push hl    
0000:1129 DDE1   pop ix      ;; ix is dest pointer
;; do same crap with source page, offset
0000:112B FD6E06 ld l,(iy+06)
0000:112E FD6607 ld h,(iy+07)
0000:1131 09     add hl,bc  
0000:1132 7C     ld a,h      
0000:1133 FE40   cp 40      
0000:1135 3804   jr c,113B  
0000:1137 D640   sub 40      
0000:1139 1C     inc e      
0000:113A 67     ld h,a      
0000:113B 01FF7F ld bc,7FFF  
0000:113E 09     add hl,bc  
0000:113F FD4E08 ld c,(iy+08)
0000:1142 FD4609 ld b,(iy+09);; bc is total n to copy
0000:1145 E5     push hl    
0000:1146 FDE1   pop iy      ;; iy is src pointer
;;
;; back loop
0000:1148 78     ld a,b      
0000:1149 B1     or c        
0000:114A 280A   jr z,1156   ;; done when n = 0
;;
0000:114C AF     xor a       ;; (dir is backward)
0000:114D CD9D0F call 0F9D   ;; Load_buffer_efbe (e = source_page, iy = source_offset, bc = n, a = dir)
0000:1150 AF     xor a       ;; (dir is backward)
0000:1151 CD0B10 call 100B   ;; Save_buffer_efbe (d = dest_page, ix = dest_offset, bc = n, a = dir)
0000:1154 18F2   jr 1148     ;; back loop
;;
0000:1156 F1     pop af      
0000:1157 D307   out (07),a  ;; restore orig ram page
0000:1159 7C     ld a,h      
0000:115A B5     or l        
0000:115B C9     ret        


; Fill(wLength, wFillByte, wAddress, wBank)
          [05B1] Fill_virtual(page, offset, fillbyte, n)
0000:115C FD210200 ld iy,0002  
0000:1160 FD39   add iy,sp   ; IY=stack
0000:1162 DB07   in a,(07)   ; Save P7
0000:1164 F5     push af     ;; push current rampage
;;
0000:1165 FD5600 ld d,(iy+00); D=stacked byte        ;; d = page
0000:1168 FD6E02 ld l,(iy+02); HL=stacked address    ;; hl = offset
0000:116B FD6603 ld h,(iy+03)
0000:116E 010080 ld bc,8000  ; BC=8000
0000:1171 09     add hl,bc   ; Add 8000 to stacked address
0000:1172 E5     push hl     ; IX=param + 8000h
0000:1173 DDE1   pop ix      ;; ix is pointer
0000:1175 FD5E04 ld e,(iy+04); E=byte                ;; e is fillbyte
0000:1178 FD4E06 ld c,(iy+06); BC=param
0000:117B FD4607 ld b,(iy+07);; bc is n
0000:117E 7A     ld a,d      
0000:117F D307   out (07),a  ; P7=bank               ;; select our page
0000:1181 78     ld a,b      
0000:1182 B1     or c        
0000:1183 2818   jr z,119D   ; Length=0? -> 119D     ;; done when n = 0
0000:1185 DD7300 ld (ix+00),e; (IX++)=E
0000:1188 DD23   inc ix      ;
0000:118A DDE5   push ix    
0000:118C E1     pop hl      
0000:118D 7C     ld a,h      
0000:118E FEC0   cp C0       ; IX==C000?
0000:1190 2008   jr nz,119A  
0000:1192 14     inc d       ; Bump bank
0000:1193 7A     ld a,d      
0000:1194 D307   out (07),a  
0000:1196 DD210080 ld ix,8000  ; Reset IX to start of bank
0000:119A 0B     dec bc      
0000:119B 18E4   jr 1181    

0000:119D F1     pop af      ; Restore P7  ;; original ram page
0000:119E D307   out (07),a  
0000:11A0 7C     ld a,h      ; Return A=H|L
0000:11A1 B5     or l        
0000:11A2 C9     ret        






          copy_anydev_to_virt_ram(destpg, destoff, srcdev, srcpg, srcoff, n)
;; called from two places a little ways down.
0000:11A3 DB07   in a,(07)   ;; save slot8000page
0000:11A5 F5     push af     ;; [-2]
;;
0000:11A6 DB06   in a,(06)   ;; save slot4000device
0000:11A8 4F     ld c,a      
0000:11A9 DB05   in a,(05)   ;; save slot4000page
0000:11AB 47     ld b,a      
0000:11AC C5     push bc     ;; [-4]
;;
0000:11AD DD210600 ld ix,0006  ;; normal 2, plus 4 from above pushes
0000:11B1 DD39   add ix,sp  
0000:11B3 DD7E04 ld a,(ix+04);; A = src device
0000:11B6 E60F   and 0F      ;; whats in hi 4 bits???
0000:11B8 FE01   cp 01      
0000:11BA 202D   jr nz,11E9  ;; jump if src device not #01   (ram)
;;
;; src device is ram.  copy from virtual ram to virtual ram.
0000:11BC D308   out (08),a  ;; slot8000dev = ram  is this nec??? copy v will set dev + page
;;
0000:11BE DD4E0A ld c,(ix+0A)
0000:11C1 DD460B ld b,(ix+0B)
0000:11C4 C5     push bc     ;; n
;;
0000:11C5 DD4E08 ld c,(ix+08)
0000:11C8 DD4609 ld b,(ix+09)
0000:11CB C5     push bc     ;; source_offset
;;
0000:11CC DD4E06 ld c,(ix+06)
0000:11CF 0600   ld b,00    
0000:11D1 C5     push bc     ;; source_page
;;
0000:11D2 DD4E02 ld c,(ix+02)
0000:11D5 DD4603 ld b,(ix+03)
0000:11D8 C5     push bc     ;; dest_offset
;;
0000:11D9 DD4E00 ld c,(ix+00)
0000:11DC 0600   ld b,00    
0000:11DE C5     push bc     ;; dest_page
;;
0000:11DF CDAB05 call Copy_virtual(dst_pg, dst_off, src_pg, src_off, n)  
0000:11E2 C1     pop bc      
0000:11E3 C1     pop bc      
0000:11E4 C1     pop bc      
0000:11E5 C1     pop bc      
0000:11E6 E1     pop hl      
0000:11E7 1838   jr 1221    
;;
;; device is not ram
0000:11E9 DD7E04 ld a,(ix+04);; get device (again) (source device)
0000:11EC D306   out (06),a  ;; put it in slot4000  (everything but the ram swaps into 4000)
0000:11EE DD5E06 ld e,(ix+06);; E is source_page
0000:11F1 DD5600 ld d,(ix+00);; D is dest_page
0000:11F4 DD6E02 ld l,(ix+02);; HL is dest_offset
0000:11F7 DD6603 ld h,(ix+03)
0000:11FA 010080 ld bc,8000  ;; slot8000 offset
0000:11FD 09     add hl,bc   ;; HL points at destination in virtual ram
0000:11FE E5     push hl    
0000:11FF FDE1   pop iy      ;; IY points at destination in virtual ram
0000:1201 DD6E08 ld l,(ix+08);; HL is source_offset
0000:1204 DD6609 ld h,(ix+09)
0000:1207 010040 ld bc,4000  ;; slot4000 offset
0000:120A 09     add hl,bc   ;; HL points at source
0000:120B DD4E0A ld c,(ix+0A);; bc is n
0000:120E DD460B ld b,(ix+0B)
0000:1211 DDE5   push ix     ;; save ix (param pointer)
0000:1213 E5     push hl    
0000:1214 DDE1   pop ix      ;; IX points at source
0000:1216 CD2E12 call 122E  
0000:1219 DDE1   pop ix      
0000:121B DD6E0A ld l,(ix+0A);; return value HL = n
0000:121E DD660B ld h,(ix+0B)
;;
0000:1221 C1     pop bc      ;; restore slot4000
0000:1222 79     ld a,c      
0000:1223 D306   out (06),a  
0000:1225 78     ld a,b      
0000:1226 D305   out (05),a  
;;
0000:1228 F1     pop af      ;; restore slot8000page (I guess we just trust that the device is/was always ram)
0000:1229 D307   out (07),a  
;;
0000:122B 7C     ld a,h      
0000:122C B5     or l        
0000:122D C9     ret        






;; this is called from above, to copy from some device
;; (prob code or dataflash) to virtual ram.
; DE = bank info
0000:122E 7A     ld a,d      ;; virtual ram dest page in slot8000
0000:122F D307   out (07),a  ; P7=D
0000:1231 7B     ld a,e      ;; source page in slot4000
0000:1232 D305   out (05),a  ; P5=E
0000:1234 78     ld a,b      ; BC=0? -> Exit ;; done if n=0
0000:1235 B1     or c        
0000:1236 282D   jr z,1265  
0000:1238 DD7E00 ld a,(ix+00); (IY)=(IX)
0000:123B FD7700 ld (iy+00),a
0000:123E DD23   inc ix      ; Next byte
0000:1240 DDE5   push ix     ;; check if source ptr moved out of slot4000 window
0000:1242 E1     pop hl      
0000:1243 7C     ld a,h      
0000:1244 FE80   cp 80       ; IX=8000?
0000:1246 2008   jr nz,1250  
0000:1248 1C     inc e      
0000:1249 7B     ld a,e      
0000:124A D305   out (05),a  ; P5++ ;; put next page in window, and point at first byte in window
0000:124C DD210040 ld ix,4000  ; Reset IX to 4000
0000:1250 FD23   inc iy      ;; inc dest ptr
0000:1252 FDE5   push iy     ;; check if it moved out of slot80000 window, adjust if so.
0000:1254 E1     pop hl      
0000:1255 7C     ld a,h      
0000:1256 FEC0   cp C0       ; IY=C000?
0000:1258 2008   jr nz,1262  
0000:125A 14     inc d      
0000:125B 7A     ld a,d      
0000:125C D307   out (07),a  ; P7++
0000:125E FD210080 ld iy,8000  ; IY=8000
0000:1262 0B     dec bc      ; Loop 'til BC=0
0000:1263 18CF   jr 1234    
0000:1265 C9     ret        







;; the offset seems to be passed as a long, but the hi 2 bytes are not used!
;;
;; origin = 0 means from begining
;; origin = 1 means from current position
;; origin > 1 means from end
;;
          [05E7] seek(handle#, offset, dontcare, origin)
0000:1266 DD210200 ld ix,0002  
0000:126A DD39   add ix,sp  
0000:126C DD7E00 ld a,(ix+00);; A = handle#
0000:126F FE1E   cp 1E      
0000:1271 3806   jr c,1279   ;; jump if handle# < 30dec
0000:1273 210000 ld hl,0000  ;; else ret 0
0000:1276 7C     ld a,h      
0000:1277 B5     or l        
0000:1278 C9     ret        
;;
;; here if handle# < 30
0000:1279 CD9112 call iy=fh_ptr(A=file#)   ;; IY = Handle_pointer(handle#)    
;;
;;            IY+ : 00     01        02 03      04 05     06 07
;;  Handle records: Byte   Byte      Word       Word      Word
;;                  code   filepage  filebegin  filesize  filepos
;;
0000:127C DD4E02 ld c,(ix+02);; bc is par2
0000:127F DD4603 ld b,(ix+03)
0000:1282 DD5E04 ld e,(ix+04);; de is par4 (not used)
0000:1285 DD5605 ld d,(ix+05)
0000:1288 DD7E06 ld a,(ix+06);; a is par6
0000:128B CD9F12 call 129F  
0000:128E 7C     ld a,h      
0000:128F B5     or l        
0000:1290 C9     ret        







;; Handle_pointer(handle#).  converts handle# to handle^
;;            IY+ : 00     01        02 03      04 05     06 07
;;  Handle records: Byte   Byte      Word       Word      Word
;;                  code   filepage  filebegin  filesize  filepos
          iy=fh_ptr(A=file#)
0000:1291 6F     ld l,a      
0000:1292 2600   ld h,00    
0000:1294 29     add hl,hl  
0000:1295 29     add hl,hl  
0000:1296 29     add hl,hl  
0000:1297 1126D9 ld de,fh.code  
0000:129A 19     add hl,de  
0000:129B E5     push hl    
0000:129C FDE1   pop iy      ;; IY = 8*a + #d926
0000:129E C9     ret        

;; seekguts(iy=filehandle^, bc=offset, de=???, a=origin).
;; Called from 14 lines above to actually do the seek.
;; Unknown just why a call needed, rather than just inlining it.
0000:129F 60     ld h,b      ;; hl = par2'  (seekoffset)
0000:12A0 69     ld l,c      
0000:12A1 FD5E04 ld e,(iy+04);; de = filesize   (whomps par4' , par4' not used?????)
0000:12A4 FD5605 ld d,(iy+05)
0000:12A7 FD4E06 ld c,(iy+06);; bc = filepos    (whatis???) it's current position in file
0000:12AA FD4607 ld b,(iy+07)
;;
;; is origin 0, 1, or more?
0000:12AD FE00   cp 00       ;; orign = 0 ?
0000:12AF 2024   jr nz,12D5  
;;
;; here when origin is 0 (Seek From Beginning of file) --------------------------------------------------------------
0000:12B1 CB7C   bit 7,h     ;; check sign of seekoffset
0000:12B3 2809   jr z,12BE  
;;
;; when seekoffset >= 8000 (negative), then zero filepos
0000:12B5 AF     xor a      
0000:12B6 FD7706 ld (iy+06),a;; filepos = 0
0000:12B9 FD7707 ld (iy+07),a
0000:12BC 1834   jr 12F2     ;; outta here, ret hl = filepos
;;
;; seekoffset < 8000 (positive), then make filepos lesser of seekoffset or filesize
0000:12BE AF     xor a      
0000:12BF E5     push hl    
0000:12C0 ED52   sbc hl,de   ;; seekoffset - filesize
0000:12C2 E1     pop hl      
0000:12C3 3808   jr c,12CD   ;; jp if filesize > seekoffset
;;
;; here when filesize <= seekoffset
0000:12C5 FD7306 ld (iy+06),e;; filepos = filesize
0000:12C8 FD7207 ld (iy+07),d
0000:12CB 1825   jr 12F2     ;; outta here, ret hl = filepos
;;
;; here when filesize > seekoffset
0000:12CD FD7506 ld (iy+06),l;; filepos = seekoffset
0000:12D0 FD7407 ld (iy+07),h
0000:12D3 181D   jr 12F2     ;; outta here, ret hl = filepos
;;
;;
;; here when origin is not 0
0000:12D5 FE01   cp 01       ;; orign = 1 ?
0000:12D7 200E   jr nz,12E7  
;;
;; here when origin is 1 (Seek From Current position of file) ------------------------------------------------------
0000:12D9 09     add hl,bc   ;; if seekoffset + filepos >= 8000 , then filepos = 0 , outta here
0000:12DA CB7C   bit 7,h     ;; that seems right for seeking back past start of file,  <**************************
0000:12DC 20D7   jr nz,12B5  ;; BUT, what if it rolled over past end, shouldnt the ret value be filesize????
;;
;; here when seekoffset + filepos  was < 8000
0000:12DE AF     xor a       ;; There is a small posibility that a seek off end would be negative!! see above note.
0000:12DF E5     push hl    
0000:12E0 ED52   sbc hl,de   ;; (seekoffset + filepos)  - filesize  (did we seek off the end ?)
0000:12E2 E1     pop hl      
0000:12E3 30E0   jr nc,12C5  ;; filepos = lesser of compared
0000:12E5 18E6   jr 12CD    
;;
;;
;; here when origin is > 1 (Seek From End of file???) --------------------------------------------------
0000:12E7 CB7C   bit 7,h    
0000:12E9 28DA   jr z,12C5   ;; if seekoffset < 8000 (positive), then filepos = filesize, outta here
;;
0000:12EB 19     add hl,de   ;; hl = seekoffset + filesize
0000:12EC CB7C   bit 7,h    
0000:12EE 20C5   jr nz,12B5  ;; if seekoffset + filesize > 8000 (neg), then filepos = 0, outta here
0000:12F0 18DB   jr 12CD     ;; else filepos = seekoffset , outta here
;;
;; outta here, ret hl = filepos
0000:12F2 FD6E06 ld l,(iy+06)
0000:12F5 FD6607 ld h,(iy+07)
0000:12F8 C9     ret        






          [05E1] readfile(fh, dest^, n)
0000:12F9 DD210200 ld ix,0002  
0000:12FD DD39   add ix,sp  
0000:12FF DD7E00 ld a,(ix+00);; a = par0  (array index) (could this be a file handle?????????)
0000:1302 FE1E   cp 1E       ;; par0 - #1e
0000:1304 3806   jr c,130C   ;; jp if par0 < #1e
0000:1306 210000 ld hl,0000  ;; else ret hl=0
0000:1309 7C     ld a,h      
0000:130A B5     or l        
0000:130B C9     ret        
;;
0000:130C CD9112 call iy=fh_ptr(A=file#)  
;;           IY+ : 00     01        02 03      04 05     06 07
;; Handle records: Byte   Byte      Word       Word      Word
;;                 code   filepage  filebegin  filesize  filepos
;;                                             hl        de
0000:130F FD6E04 ld l,(iy+04);; hl = array col 3  (filesize)
0000:1312 FD6605 ld h,(iy+05)
0000:1315 FD5E06 ld e,(iy+06);; de = array col 4  (filepos)
0000:1318 FD5607 ld d,(iy+07)
;;
0000:131B DD4E04 ld c,(ix+04);; bc = par4 (n)
0000:131E DD4605 ld b,(ix+05);;
;;
0000:1321 CD4613 call Clip_n_to_eof(hl=filesize, de=filepos, bc=n)  
0000:1324 E5     push hl     ;; clipped_n
;;
0000:1325 CD5813 call get_file_dev_page_offset(hl=clipped_n,de=curr_filepos)  
0000:1328 E5     push hl     ;; sourceoffset
;;
0000:1329 68     ld l,b      
0000:132A 2600   ld h,00    
0000:132C E5     push hl     ;; sourcepg
;;
0000:132D 69     ld l,c      
0000:132E E5     push hl     ;; sourcedev
;;
0000:132F DD4E02 ld c,(ix+02);; bc = par2  (dest^)
0000:1332 DD4603 ld b,(ix+03)
0000:1335 CD8E13 call h_l_bc=device_page_offset_of(BC)  
0000:1338 C5     push bc     ;; dest offset
0000:1339 E5     push hl     ;; dest dev_pg
0000:133A CDA311 call copy_anydev_to_virt_ram(destpg, destoff, srcdev, srcpg, srcoff, n)  
0000:133D C1     pop bc      
0000:133E C1     pop bc      
0000:133F C1     pop bc      
0000:1340 C1     pop bc      
0000:1341 C1     pop bc      
0000:1342 C1     pop bc      
0000:1343 7C     ld a,h      
0000:1344 B5     or l        
0000:1345 C9     ret        








;;           iy+ : 00        01        02 03       04 05  06 07
;;                 col0      col1      col2        col3   col4
;; Handle records: codeByte, pageByte, offsetWord, nWord, ???Word
;;                                     begin??     size   filepos
;;  regs on call:                                  hl     de

          Clip_n_to_eof(hl=filesize, de=filepos, bc=n)  
;; called from 2 places, one 24 lines above, one a ways down.
;; This just clips n if there is less than n bytes left before eof.
;;  first we calc num of bytes left before eof
0000:1346 AF     xor a      
0000:1347 ED52   sbc hl,de   ;; if hl < de then hl = #0000   (hl = size - cur_position)
0000:1349 3003   jr nc,134E  ;; else hl = hl - de            (if col2 < col3, then hl = #0000)
0000:134B 210000 ld hl,0000  
;;
;; now hl is num bytes left before eof, and we compare it to n
0000:134E AF     xor a       ;; clear carry
0000:134F E5     push hl     ;;                              (left)
0000:1350 ED42   sbc hl,bc   ;; if hl < n then hl = n        (hl = left - n)
0000:1352 E1     pop hl      ;;                              (hl = left)
0000:1353 3802   jr c,1357   ;; cy means n bigger            (if n > left, ret left)  ((ie. clip n to num left))
;;
0000:1355 69     ld l,c      ;; no cy means n smaller or same, so we are ret hl = n
0000:1356 60     ld h,b      
0000:1357 C9     ret         ;; ret clipped hl = clipped_n








;;           iy+ : 00        01        02 03       04 05  06 07
;;                 col0      col1      col2        col3   col4
;; Handle records: codeByte, pageByte, offsetWord, nWord, ???Word
;;                                    begin??     size   filepos
;; regs on call:                                         de
;; hl is clipped_n

          get_file_dev_page_offset(hl=clipped_n,de=curr_filepos)
;;  rets c=device, b=page, de=offset to current position in file.  (advances filepos too)
;; called from 2 places, one 34 lines above, one a ways down.
;; advance the current file position by clipped n bytes
0000:1358 19     add hl,de   ;; clipped_n + cur_filepos
0000:1359 FD7506 ld (iy+06),l;; array06 = clipped_n + cur_filepos    (advance cur_filepos)
0000:135C FD7407 ld (iy+07),h
;;
;; pick up address of begining of file
0000:135F FD6E02 ld l,(iy+02);; hl = offset_to_beginfile
0000:1362 FD6603 ld h,(iy+03)
;;
0000:1365 FD4601 ld b,(iy+01);; b = file_page
;;
;; normalize start_of_file page & offset
0000:1368 7A     ld a,d      
0000:1369 FE40   cp 40       ;; de - #4000
0000:136B 3806   jr c,1373   ;; jp if de < #4000
;;
0000:136D D640   sub 40      
0000:136F 57     ld d,a      ;; de = de - 4000  (src_address - 4000) 136F  57        LD      D,A
0000:1370 04     inc b       ;; b = b + 1  {src_page +1)
0000:1371 18F5   jr 1368     ;; keep adjusting till de < 4000
;;
;; add in the filepos (filepos value from before we advanced it), and normalize again
0000:1373 19     add hl,de   ;; adjusted offset + array02
0000:1374 7C     ld a,h      
0000:1375 FE40   cp 40      
0000:1377 3804   jr c,137D   ;; if (array02 + adjusted offset) > 4000 ...
;;
0000:1379 D640   sub 40      ;; ... then adjust once more
0000:137B 67     ld h,a      
0000:137C 04     inc b      
;;
;; figure out what device file is in, ram or codeflash.  
;; Funny that dataflash is not a choice!?!?
0000:137D FD7E00 ld a,(iy+00);; if array00 = #0B , ret c = #01
0000:1380 FE0B   cp 0B      
0000:1382 2807   jr z,138B   ;; #0b means use ram device
;;
0000:1384 FE14   cp 14       ;; if array00 = #14 , ret c = #01
0000:1386 2803   jr z,138B   ;; #14 means use ram device
;;
0000:1388 0E00   ld c,00     ;; else ret c = 0
0000:138A C9     ret         ;; use codeflash device
;;
0000:138B 0E01   ld c,01     ;; use ram device
0000:138D C9     ret        







          h_l_bc=device_page_offset_of(BC)
;; BC is a pointer to memory in z80 space.
;; figure out what device/page bc is pointing at, and remove slot offset from bc.
;; iow, change bc from a pointer to an offset in it's respective page.
;; called from two places , one above, and one below
0000:138E 78     ld a,b      
0000:138F FEC0   cp C0       ;; pointing to slot #C000 ?
0000:1391 3808   jr c,139B   ;; jp if bc < c000
;;
;; it is slot #C000
0000:1393 D6C0   sub C0      ;; remove slot offset (bc = bc - c000)
0000:1395 47     ld b,a      
0000:1396 2E00   ld l,00     ;; L = page# inhabiting slot #C000   (0 = page 0)
0000:1398 2601   ld h,01     ;; H = device# inhabiting slot #C000 (1 = ram)
0000:139A C9     ret         ;; this one was easy, slot#C000 is always page 0 of ram
;;
0000:139B FE80   cp 80       ;; pointing to slot #8000 ?
0000:139D 380A   jr c,13A9   ;; jp if bc < 8000
;;
;; it is slot #8000
0000:139F D680   sub 80      ;; remove slot offset  (bc = bc - 8000)
0000:13A1 47     ld b,a      
0000:13A2 DB07   in a,(07)   ;; L = slot8000page
0000:13A4 6F     ld l,a      
0000:13A5 DB08   in a,(08)   ;; H = slot8000device
0000:13A7 67     ld h,a      
0000:13A8 C9     ret        
;;
0000:13A9 FE40   cp 40       ;; pointing to slot #4000 ?
0000:13AB 380A   jr c,13B7   ;; jp if bc < 4000
;;
;; it is slot #4000
0000:13AD D640   sub 40      ;; remove slot offset  (bc = bc - 4000)
0000:13AF 47     ld b,a      
0000:13B0 DB05   in a,(05)   ;; L = slot4000page
0000:13B2 6F     ld l,a      
0000:13B3 DB06   in a,(06)   ;; H = slot4000device
0000:13B5 67     ld h,a      
0000:13B6 C9     ret        
;;
;; it is slot #0000
0000:13B7 2E00   ld l,00     ;; L = slot0000page  (codepage 0)
0000:13B9 2600   ld h,00     ;; H = slot0000device  (codeflash)
0000:13BB C9     ret         ;; the easiest, slot #0000 is always codeflash page 0, and slot offset is 0000h





          [0860] Read_Romdisk(iy=twoLoBytesofAddress, ix=page???, bc=n, hl=dest)
0000:13BC D5     push de     ;; * save de  (de not used here, just makin room)
;;
0000:13BD F5     push af    
0000:13BE DB06   in a,(06)   ;; ** save slot4000
0000:13C0 E60F   and 0F      
0000:13C2 57     ld d,a      
0000:13C3 DB05   in a,(05)  
0000:13C5 5F     ld e,a      
0000:13C6 F1     pop af      
0000:13C7 D5     push de    
;;
0000:13C8 FDE5   push iy    
0000:13CA D1     pop de      ;; de = iy    (lo 2 bytes of address)
0000:13CB 7A     ld a,d      
0000:13CC E6C0   and C0      ;; keep 2 hi bits of iy  (page bits???)
0000:13CE CB07   rlc a      
0000:13D0 CB07   rlc a      
0000:13D2 5F     ld e,a      
0000:13D3 1600   ld d,00     ;; now in 2 lo bits of de
0000:13D5 DD19   add ix,de   ;; ix = ix + (2 bits from iy (lo pg bits???)) don't make sense???
;;                                  ;; iy:                   XXxx xxxx xxxx xxxx
;;                                  ;; ix:  XXXX XXXX XXXX XXXX
;;
0000:13D7 FDE5   push iy    
0000:13D9 D1     pop de      ;; de = iy
0000:13DA 7A     ld a,d      
0000:13DB E63F   and 3F      ;; keep sectoroffset bits
0000:13DD F640   or 40       ;; add slot4000 offset
0000:13DF 57     ld d,a      ;; de points at something (in slot4000)
;;
0000:13E0 E5     push hl     ;; *** save hl (hl value on call)
;;
;; Set iy = excess n
0000:13E1 FD210000 ld iy,0000  ;; iy = #0000  (excess)
0000:13E5 6B     ld l,e      
0000:13E6 62     ld h,d      
0000:13E7 09     add hl,bc   ;; hl = pointer + n
0000:13E8 7C     ld a,h      
0000:13E9 FE80   cp 80       ;; (pointer + n) - #8000    carries when h is less than #80
0000:13EB 380E   jr c,13FB   ;; jp if (pointer + n) is < #80
;;
;; here if (pointer + n) went past #7fff (outside of slot4000)
0000:13ED D680   sub 80      
0000:13EF 67     ld h,a      
0000:13F0 E5     push hl    
0000:13F1 FDE1   pop iy      ;; iy = (pointer + n) - #8000  (excess n)
;;
0000:13F3 B7     or a        
0000:13F4 210080 ld hl,8000  
0000:13F7 ED52   sbc hl,de  
0000:13F9 4D     ld c,l      
0000:13FA 44     ld b,h      ;; bc = #8000 - pointer (n in first page)
;;
;; here when (pointer + n) was less than #8000
0000:13FB E1     pop hl      ;; *** restore hl  (hl value on call)
;;
;; Put page in slot4000
0000:13FC C5     push bc     ;; *** save bc  (n)
0000:13FD DDE5   push ix    
0000:13FF C1     pop bc      ;; bc = ix  (page)
0000:1400 F5     push af    
0000:1401 AF     xor a      
0000:1402 D306   out (06),a  ;; slot4000 device is codeflash
0000:1404 79     ld a,c      
0000:1405 D305   out (05),a  ;; slot4000 page is IX
0000:1407 F1     pop af      
0000:1408 C1     pop bc      ;; *** restore bc  (n)
;;
0000:1409 EB     ex de,hl    ;; use hl as dest, de as source
0000:140A EDB0   ldir        ;; copy first part
;;
;; if excess = 0 , then done
0000:140C FDE5   push iy    
0000:140E C1     pop bc      ;; bc is excess n
0000:140F 78     ld a,b      
0000:1410 B7     or a        
0000:1411 2003   jr nz,1416  
0000:1413 B1     or c        
0000:1414 2813   jr z,1429  
;;
;; here when excess n was not 0.  Do second page.
0000:1416 C5     push bc     ;; *** save bc  (excess n)
0000:1417 DDE5   push ix    
0000:1419 C1     pop bc      ;; page is ix+1  (next page)
0000:141A 03     inc bc      
;;
0000:141B F5     push af    
0000:141C AF     xor a      
0000:141D D306   out (06),a  ;; slot4000 = codeflash
0000:141F 79     ld a,c      
0000:1420 D305   out (05),a  ;; slot4000 = ix + 1
0000:1422 F1     pop af      
;;
0000:1423 C1     pop bc      ;; *** restore bc  (excess n)
0000:1424 210040 ld hl,4000  
0000:1427 EDB0   ldir        ;; copy second part
;;
;; done.  here when excess = 0
0000:1429 C1     pop bc      ;; restore slot4000
0000:142A F5     push af    
0000:142B 78     ld a,b      
0000:142C D306   out (06),a  
0000:142E 79     ld a,c      
0000:142F D305   out (05),a  
0000:1431 F1     pop af      
;;
0000:1432 D1     pop de      ;; * restore de
0000:1433 C9     ret        







          [05E4] writefile(fh, source^, n)
0000:1434 DD210200 ld ix,0002  
0000:1438 DD39   add ix,sp  
0000:143A DD7E00 ld a,(ix+00)
0000:143D FE1E   cp 1E      
0000:143F 3806   jr c,1447  
0000:1441 210000 ld hl,0000  
0000:1444 7C     ld a,h      
0000:1445 B5     or l        
0000:1446 C9     ret        
;;
0000:1447 CD9112 call iy=fh_ptr(A=file#)   ;; IY = Handle_pointer(handle#)
;;
;;                              (IY= 8 * par0 + D926, iy points to array data)
;;
;;           IY+ : 00     01        02 03      04 05     06 07
;; Handle records: Byte   Byte      Word       Word      Word
;;                 code   filepage  filebegin  filesize  filepos
;;
0000:144A FD6E04 ld l,(iy+04);; filesize
0000:144D FD6605 ld h,(iy+05)
0000:1450 FD5E06 ld e,(iy+06);; filepos
0000:1453 FD5607 ld d,(iy+07)
;;
0000:1456 DD4E04 ld c,(ix+04);; par4   n
0000:1459 DD4605 ld b,(ix+05)
0000:145C CD4613 call Clip_n_to_eof(hl=filesize, de=filepos, bc=n)  
0000:145F E5     push hl     ;; n
0000:1460 D9     exx        
0000:1461 DD4E02 ld c,(ix+02);; bc = par2 (source^)
0000:1464 DD4603 ld b,(ix+03)
0000:1467 CD8E13 call h_l_bc=device_page_offset_of(BC)  
0000:146A C5     push bc     ;; sourceoffset
0000:146B 4D     ld c,l      
0000:146C 0600   ld b,00    
0000:146E C5     push bc     ;; sourcepg
0000:146F 4C     ld c,h      
0000:1470 C5     push bc     ;; sourcedev
0000:1471 D9     exx        
0000:1472 CD5813 call get_file_dev_page_offset(hl=clipped_n,de=curr_filepos)  
0000:1475 E5     push hl     ;; destoffset
0000:1476 68     ld l,b      
0000:1477 2600   ld h,00    
0000:1479 E5     push hl     ;; destpg
0000:147A CDA311 call copy_anydev_to_virt_ram(destpg, destoff, srcdev, srcpg, srcoff, n)  
0000:147D C1     pop bc      
0000:147E C1     pop bc      
0000:147F C1     pop bc      
0000:1480 C1     pop bc      
0000:1481 C1     pop bc      
0000:1482 C1     pop bc      
0000:1483 7C     ld a,h      
0000:1484 B5     or l        
0000:1485 C9     ret        






;; This might be "open"????????
;;
          [05DB] get_filehandle(???, code, n)
;;
0000:1486 DD210200 ld ix,0002  ;;IX points at pars
0000:148A DD39   add ix,sp  
0000:148C FD2116DA ld iy,larry03  ;; IY points at ?????? address used 5 other places below
;;
;;   #da16+6 is page, #da16+7&8 is offset (free space address)
;;   #da16+3&4&5 is address of limit, or in use space.  circular buffer???
;;
0000:1490 DD7E02 ld a,(ix+02);; A = par2 (code)
0000:1493 FE0B   cp 0B       ; Param = 0B? Call 14AE  ;; code = #0b means file is/will be in ram????
0000:1495 2006   jr nz,149D  
0000:1497 CDAE14 call 14AE   ;; get handle#
0000:149A 7C     ld a,h      
0000:149B B5     or l        
0000:149C C9     ret        
;;
;; not #0B
0000:149D FE14   cp 14       ; Param = 14? Call 14AE ;; 14Fe  code = #14 means file is/will be in ram????
0000:149F 2006   jr nz,14A7  
0000:14A1 CDFE14 call 14FE  
0000:14A4 7C     ld a,h      
0000:14A5 B5     or l        
0000:14A6 C9     ret        
;;
;; not #14
0000:14A7 3D     dec a      
0000:14A8 6F     ld l,a      ; Return par - 1  ;;  (code - 1)
0000:14A9 2600   ld h,00    
0000:14AB 7C     ld a,h      
0000:14AC B5     or l        
0000:14AD C9     ret        





;; called from directly above, when par2 was #0B
;; returns handle# for existing file, or creates a new empty file and handle.
;; It's still not clear if there can be more than one handle with code = #0B.
;; MAYBE #0B means empty file???????
;; scans a table 0f 30 8 byte entries for #0B, and if found rets the index of
;; that entry.
;; if not found, scans for a #00 entry, and sets that to #0B, copies 3 bytes
;; from DA16 (freespace address???), and zeroes the filesize & filepos,
;; and rets index (handle#).
;;
0000:14AE 0600   ld b,00     ;; i=0
0000:14B0 2126D9 ld hl,fh.code  ;; scan every 8 bytes for #0b  (same table as earlier, filehandles)
;;
;; loop_0B   for i = 0 to 29 do
0000:14B3 78     ld a,b      
0000:14B4 FE1E   cp 1E      
0000:14B6 300C   jr nc,14C4  ;; if B >= #1E , jump 14c4
;;
0000:14B8 7E     ld a,(hl)   ;; A = (d926 + i*8)
0000:14B9 FE0B   cp 0B      
0000:14BB 283D   jr z,14FA   ;; if (d926 + i*8) = #0B , ret i  (row num)
;;
0000:14BD 110800 ld de,0008  ;; next line in table
0000:14C0 19     add hl,de  
0000:14C1 04     inc b       ;; i++
0000:14C2 18EF   jr 14B3     ;; loop_0B
;;
;; no #0B found in handle table
0000:14C4 0600   ld b,00     ;; i=0
0000:14C6 2126D9 ld hl,fh.code  ;; scan file handle table for #00  (#00 means available handle????)
;;
;; loop_00   for i=0 to 29 do
0000:14C9 78     ld a,b      
0000:14CA FE1E   cp 1E      
0000:14CC 3028   jr nc,14F6  ;; if B >= 30 , ret ff

0000:14CE 7E     ld a,(hl)  
0000:14CF B7     or a        
0000:14D0 201D   jr nz,14EF  ;; code = #00 ?
;;
;; #00 found
0000:14D2 360B   ld (hl),0B  ;; make the #00 into #0B  (1st 0f 8)  (code???)
;;
0000:14D4 23     inc hl      
0000:14D5 FD5E06 ld e,(iy+06);; get  page# x (iy was set = DA16 before call)
0000:14D8 73     ld (hl),e   ;; 2nd entry in table row is that page# x
;;
0000:14D9 23     inc hl      
0000:14DA FD5E07 ld e,(iy+07)
0000:14DD 73     ld (hl),e  
0000:14DE 23     inc hl      
0000:14DF FD5608 ld d,(iy+08)
0000:14E2 72     ld (hl),d   ;; 3rd & 4th are the offset x, that goes with that page x
;;
0000:14E3 23     inc hl      
0000:14E4 AF     xor a      
0000:14E5 77     ld (hl),a  
0000:14E6 23     inc hl      
0000:14E7 77     ld (hl),a   ;; 5th & 6th = #0000   (filesize)
;;
0000:14E8 23     inc hl      
0000:14E9 77     ld (hl),a  
0000:14EA 23     inc hl      
0000:14EB 77     ld (hl),a   ;; 7th & 8th = #0000   (filepos)
;;
0000:14EC 23     inc hl      
0000:14ED 180B   jr 14FA    
;;
;; current line not #00
0000:14EF 110800 ld de,0008  ;; next line in table
0000:14F2 19     add hl,de  
0000:14F3 04     inc b       ;; i++
0000:14F4 18D3   jr 14C9     ;; loop_00
;;
0000:14F6 21FF00 ld hl,00FF  ;; error, no handle available
0000:14F9 C9     ret        
;;
0000:14FA 68     ld l,b      ;; ret i  (table row #)
0000:14FB 2600   ld h,00    
0000:14FD C9     ret        







;; called from two above, when par2 was #14
;; returns handle# for NEWLY created handle and file of size "n".  
;;  
;; also allocates ram (or dataflash, but not likely).
;;
;; It's still not clear if there can be more than one handle with code = #14.
;; MAYBE #14 means new or in use file???????
;; allocating space in ram or dataflash???
;;
0000:14FE FD4E06 ld c,(iy+06);; C = (DA16+6)      (page# of x) (I think x might represent free ram address?????)
;;
0000:1501 DD5E04 ld e,(ix+04)
0000:1504 DD5605 ld d,(ix+05);; de = par4' (n)    (num of bytes to allocate)
;;
0000:1507 7A     ld a,d      ;; normalize n       (really adding n to address x, by pagefulls)
0000:1508 FE40   cp 40      
0000:150A 3806   jr c,1512   ;; jp if par4' < #4000
0000:150C D640   sub 40      ;; subtract #4000
0000:150E 57     ld d,a      
0000:150F 0C     inc c       ;; inc C  (inc'ing page is like adding #4000)
0000:1510 18F5   jr 1507     ;; loop till DE < #4000
;;
0000:1512 FD6E07 ld l,(iy+07);; HL = (DA16+7)      (an offset in page x)
0000:1515 FD6608 ld h,(iy+08);;
0000:1518 19     add hl,de   ;; offset + whats_left_of_n   (x+n)  (adding in partial page)
;;
0000:1519 7C     ld a,h      ;; normalize again, in case it became > #4000
0000:151A FE40   cp 40      
0000:151C 3804   jr c,1522  
0000:151E D640   sub 40      
0000:1520 67     ld h,a      
0000:1521 0C     inc c      
;;
0000:1522 E5     push hl     ;; save new offset x  (original address + n bytes)
0000:1523 C5     push bc     ;; save new page x
;;
0000:1524 FD4603 ld b,(iy+03);; another page# y   (limit????)
0000:1527 79     ld a,c      
0000:1528 B8     cp b        ;; new_page - y page
0000:1529 200F   jr nz,153A  ;; jp if not same page
;;
;; same page, but might still be ok if doesn't overtake limit  (circular buffer???)
0000:152B AF     xor a      
0000:152C FD5E04 ld e,(iy+04);; another offset y  (limit????)
0000:152F FD5605 ld d,(iy+05)
0000:1532 ED52   sbc hl,de   ;; new_offset - y  (zero or borrow should mean ok)
;;
0000:1534 2806   jr z,153C   ;; jp if x+n = y
;;
0000:1536 303C   jr nc,1574  ;; if x+n > y , ret ff
;;
0000:1538 1802   jr 153C     ;; jp if x+n < y
;;
;; not same page
0000:153A 3038   jr nc,1574  ;; if new_page > y page , ret ff  (didn't hit limit, but we may have went past it!)
;;
;; not same page and y_page greater  OR  same page and y_offset greater
;; iow, x+n will not overrun y
;;
;; now we need to find an unused handle
0000:153C 0600   ld b,00     ;; for b=0 to 29
0000:153E 2126D9 ld hl,fh.code  ;; same fh table as above
;;
;; find_00_loop
0000:1541 78     ld a,b      
0000:1542 FE1E   cp 1E      
0000:1544 302E   jr nc,1574  ;; if b=30, ret ff
;;
0000:1546 7E     ld a,(hl)  
0000:1547 B7     or a        
0000:1548 2023   jr nz,156D  ;; next if not #00
;;
;; found #00
0000:154A 3614   ld (hl),14  ;; 1st = #14
0000:154C 23     inc hl      
0000:154D FD5E06 ld e,(iy+06)
0000:1550 73     ld (hl),e   ;; 2nd = page x
0000:1551 23     inc hl      
0000:1552 FD5E07 ld e,(iy+07)
0000:1555 73     ld (hl),e   ;; 3rd & 4th = offset x
0000:1556 23     inc hl      
0000:1557 FD5608 ld d,(iy+08)
0000:155A 72     ld (hl),d  
0000:155B 23     inc hl      
0000:155C DD5E04 ld e,(ix+04)
0000:155F 73     ld (hl),e   ;; 5th & 6th = par4' (n) (filesize)
0000:1560 23     inc hl      
0000:1561 DD5605 ld d,(ix+05)
0000:1564 72     ld (hl),d  
0000:1565 23     inc hl      
0000:1566 AF     xor a      
0000:1567 77     ld (hl),a   ;; 7th & 8th = #0000  (filepos)
0000:1568 23     inc hl      
0000:1569 77     ld (hl),a  
0000:156A 23     inc hl      
0000:156B 180D   jr 157A    
;;
0000:156D 110800 ld de,0008  ;; index++8
0000:1570 19     add hl,de  
0000:1571 04     inc b       ;; B++
0000:1572 18CD   jr 1541     ;; find_00_loop
;;
0000:1574 C1     pop bc      ;; ret ff
0000:1575 E1     pop hl      
0000:1576 21FF00 ld hl,00FF  
0000:1579 C9     ret        
;;
0000:157A 68     ld l,b      
0000:157B 2600   ld h,00     ;; hl = index (ret value)
;;
;; advance free space address
0000:157D D1     pop de      ;; E = new_page
0000:157E FD7306 ld (iy+06),e
0000:1581 D1     pop de      ;; DE = new_offset
0000:1582 FD7307 ld (iy+07),e
0000:1585 FD7208 ld (iy+08),d;; x = x + n
0000:1588 C9     ret        





;; this might be close??????????????????????????
;;
          [05EA] idunnoyet_close????(file#)
0000:1589 DD210200 ld ix,0002  
0000:158D DD39   add ix,sp  
0000:158F DD7E00 ld a,(ix+00); Read param            ;; a = file#
0000:1592 FE1E   cp 1E       ; More than 1E? -> 1625 ;; file - #1E
0000:1594 300E   jr nc,15A4  ;; nc is error, fh# out of range, ret hl = #0001
;;
0000:1596 CD9112 call iy=fh_ptr(A=file#)  
;;
;;           IY+ : 00     01        02 03      04 05     06 07
;; Handle records: Byte   Byte      Word       Word      Word
;;                 code   filepage  filebegin  filesize  filepos
;;
0000:1599 FD7E00 ld a,(iy+00);; test codebyte
0000:159C FE0B   cp 0B       ; 11 or 20? -> Skip ahead
0000:159E 2807   jr z,15A7   ;; jp if codebute is #0B or #14
0000:15A0 FE14   cp 14      
0000:15A2 2803   jr z,15A7  
0000:15A4 C32516 jp 1625     ;; otherwise, ret hl = #0001
;;
;; codebyte was #0B  or #14    (is it ever anything else????)
0000:15A7 FD5E04 ld e,(iy+04)
0000:15AA FD5605 ld d,(iy+05);; de = filesize
0000:15AD 7A     ld a,d      
0000:15AE B3     or e        ;; if filesize - 0 ...
0000:15AF 2870   jr z,1621   ;; ...then  set codebyte = #00, and ret hl = #0001
;;
;; here when fh.filesize was not 0.
;; we are gonna calc the end address of the file buffer, which is the sum
;; of the size & startaddress.
0000:15B1 0E00   ld c,00     ;; page count = #00
;;
;; loop   normalize filesize into pages, and part page.
0000:15B3 7A     ld a,d      
0000:15B4 FE40   cp 40      
0000:15B6 3806   jr c,15BE   ;; jp if filesize > #4000
;;
0000:15B8 D640   sub 40      ;; filesize = filesize - #4000
0000:15BA 57     ld d,a      
0000:15BB 0C     inc c       ;; pagecount++
0000:15BC 18F5   jr 15B3     ;; loop
;;
0000:15BE D5     push de     ;; push filesize residue
0000:15BF C5     push bc     ;; push pagecount
0000:15C0 FDE5   push iy     ;; push fh^
;;
0000:15C2 FD7E01 ld a,(iy+01);; C = pagecount + filepage   (page of first byte after file????)
0000:15C5 81     add a,c    
0000:15C6 4F     ld c,a      
;;
0000:15C7 FD6E02 ld l,(iy+02);; hl = filebegin + filesize_residue
0000:15CA FD6603 ld h,(iy+03)
0000:15CD 19     add hl,de  
;;
0000:15CE 7C     ld a,h      ;; normalize again
0000:15CF FE40   cp 40      
0000:15D1 3804   jr c,15D7  
0000:15D3 D640   sub 40      
0000:15D5 67     ld h,a      
0000:15D6 0C     inc c       ;; now CHL is address of 1st byte after file
;;
0000:15D7 EB     ex de,hl    ;; now CDE is address of 1st byte after file
;;
;;
;; OK, we have the end address of file buffer, now we will move the freespace
;; pointer back????
;;
0000:15D8 DD2116DA ld ix,larry03  ;; point ix at larry moe & curly
0000:15DC DD4606 ld b,(ix+06);; curlypg   (freespace address???)
0000:15DF 78     ld a,b      
0000:15E0 91     sub c      
0000:15E1 47     ld b,a      ;; B = freepage - C   (freepage - (pagecount + filepage))   whyyyy????
;;
0000:15E2 DD6E07 ld l,(ix+07);; curlyoffset
0000:15E5 DD6608 ld h,(ix+08)
0000:15E8 E5     push hl    
0000:15E9 DDE1   pop ix      ;; ix = freeoffset
;;
0000:15EB FD6E02 ld l,(iy+02)
0000:15EE FD6603 ld h,(iy+03)
0000:15F1 E5     push hl     ;; push filebegin_offset
;;
0000:15F2 FD6E01 ld l,(iy+01);; L = filebeginpage
0000:15F5 FDE1   pop iy      ;; IY = filebegin_offset
;;
0000:15F7 AF     xor a       ;; a = 0 (direction??????)
0000:15F8 CD2B16 call aaaaaaaaaaaa  
;;
0000:15FB FDE1   pop iy      ;; IY =fh^
0000:15FD C1     pop bc      ;; BC = pagecount
0000:15FE D1     pop de      ;; DE = filesize_residue
;;
;;
;; curly = curly - cde
;; freespace = freespace - filesize
0000:15FF DD2116DA ld ix,larry03  
0000:1603 DD4606 ld b,(ix+06);; bhl = curly
0000:1606 DD6E07 ld l,(ix+07)
0000:1609 DD6608 ld h,(ix+08)
;;
0000:160C AF     xor a       ;; a = 0 means backwards.  ( bhl = bhl - cde)
0000:160D CDDE16 call advance_bhl_by_cde(a=dir)  
;;
0000:1610 DD7006 ld (ix+06),b
0000:1613 DD7507 ld (ix+07),l
0000:1616 DD7408 ld (ix+08),h
;;
;;
0000:1619 DD2126D9 ld ix,fh.code  ;; ix = fh table
0000:161D AF     xor a       ;; a = 0
0000:161E CDFD16 call move_all_buffers_higher_than_fh_iy  
;;
;;
;; here when filesize was 0
0000:1621 AF     xor a       ;; set codebyte = #00   (frees handle????)
0000:1622 FD7700 ld (iy+00),a
;;
0000:1625 210100 ld hl,0001  ;; ret hl = #0001
0000:1628 7C     ld a,h      
0000:1629 B5     or l        
0000:162A C9     ret        





;; called by above with a=0, and once from below with a=1
;; IX = freeoffset,
;; IY = filebegin_offset,
;; L = filebeginpage,
;; B = ????
;;
          aaaaaaaaaaaa
0000:162B DDE5   push ix     ;; push freeoffset
0000:162D 2600   ld h,00    
0000:162F E5     push hl     ;; push L = filebeginpage
0000:1630 DDE1   pop ix      ;; ix = filebeginpage
;;
0000:1632 B7     or a        ;; is this a direction flag????
0000:1633 2803   jr z,1638  
0000:1635 C38716 jp 1687    
;;
;;
;; here when a = 0   (backward???)
0000:1638 2100C0 ld hl,fn09DD_row  ;; hl = #c000  (- #4000 ???  or #c000)
;;
;; loop1                      b is param
0000:163B 78     ld a,b      ;; B = (freepage - (pagecount + filepage))
0000:163C FE04   cp 04       ;; B - 4
0000:163E 381F   jr c,165F   ;; break when B < 4
;;
;; b >= 4
0000:1640 E5     push hl     ;; n
0000:1641 D5     push de     ;; source_offset = DE  (CDE is address of 1st byte after file)
0000:1642 C5     push bc     ;; source_page = C
0000:1643 FDE5   push iy     ;; dest_offset = filebegin_offset
0000:1645 DDE5   push ix     ;; dest_page = filebegin_page
0000:1647 CDAB05 call Copy_virtual(dst_pg, dst_off, src_pg, src_off, n)  
0000:164A DDE1   pop ix      
0000:164C FDE1   pop iy      
0000:164E C1     pop bc      
0000:164F D1     pop de      
0000:1650 E1     pop hl      
;;
0000:1651 0C     inc c       ;; source_page = sourcepage + 3
0000:1652 0C     inc c      
0000:1653 0C     inc c      
0000:1654 DD23   inc ix      ;; destpage = destpage + 3
0000:1656 DD23   inc ix      
0000:1658 DD23   inc ix      
0000:165A 05     dec b       ;; pagecount = pagecount - 3
0000:165B 05     dec b      
0000:165C 05     dec b      
0000:165D 18DC   jr 163B     ;; loop1
;;
;; b < 4
0000:165F E1     pop hl      
0000:1660 78     ld a,b      
0000:1661 B7     or a        
0000:1662 280A   jr z,166E   ;; jp if b = 0
;;
;; b is 1, 2, or 3
0000:1664 C5     push bc    
0000:1665 AF     xor a       ;; a = 0
0000:1666 0E40   ld c,40    
;;
0000:1668 81     add a,c     ;; a = a + #40
0000:1669 10FD   djnz 1668  
;;
0000:166B 84     add a,h     ;; hl = hl + (b * #4000)
0000:166C 67     ld h,a      
0000:166D C1     pop bc      
;;
0000:166E AF     xor a      
0000:166F ED52   sbc hl,de   ;; hl = hl - ???
;;
0000:1671 7C     ld a,h      
0000:1672 B5     or l        
0000:1673 2811   jr z,1686   ;; if hl = 0, ret
;;
0000:1675 E5     push hl    
0000:1676 D5     push de    
0000:1677 C5     push bc    
0000:1678 FDE5   push iy    
0000:167A DDE5   push ix    
0000:167C CDAB05 call Copy_virtual(dst_pg, dst_off, src_pg, src_off, n)  
0000:167F DDE1   pop ix      
0000:1681 FDE1   pop iy      
0000:1683 C1     pop bc      
0000:1684 D1     pop de      
0000:1685 E1     pop hl      
0000:1686 C9     ret        
;;
;;
;; here when a <> 0   (forward???)
0000:1687 E1     pop hl      
0000:1688 AF     xor a      
0000:1689 ED52   sbc hl,de  
0000:168B D5     push de    
0000:168C 110040 ld de,4000  
0000:168F AF     xor a      
0000:1690 3006   jr nc,1698  
;;
0000:1692 19     add hl,de  
0000:1693 AF     xor a      
0000:1694 DD2B   dec ix      
0000:1696 0D     dec c      
0000:1697 05     dec b      
;;
0000:1698 78     ld a,b      
0000:1699 B7     or a        
0000:169A 280E   jr z,16AA  
;;
;; loop
0000:169C 19     add hl,de  
0000:169D 3807   jr c,16A6  
;;
0000:169F DD2B   dec ix      
0000:16A1 0D     dec c      
0000:16A2 10F8   djnz 169C  
;;
0000:16A4 1804   jr 16AA    
;;
0000:16A6 AF     xor a      
0000:16A7 ED52   sbc hl,de  
0000:16A9 AF     xor a      
;;
0000:16AA D1     pop de      
0000:16AB 7C     ld a,h      
0000:16AC B5     or l        
0000:16AD 282E   jr z,16DD   ;; if hl = 0, ret
;;
0000:16AF E5     push hl    
0000:16B0 D5     push de    
0000:16B1 C5     push bc    
0000:16B2 FDE5   push iy    
0000:16B4 DDE5   push ix    
0000:16B6 CDAE05 call Copy_virtual_overlapsafe(dst_pg, dst_off, src_pg, src_off, n)  
0000:16B9 DDE1   pop ix      
0000:16BB FDE1   pop iy      
0000:16BD C1     pop bc      
0000:16BE D1     pop de      
0000:16BF E1     pop hl      
;;
0000:16C0 210040 ld hl,4000  
0000:16C3 78     ld a,b      
0000:16C4 B7     or a        
0000:16C5 2816   jr z,16DD   ;; ret if z
;;
;; loop
0000:16C7 DD2B   dec ix      
0000:16C9 0D     dec c      
0000:16CA E5     push hl    
0000:16CB D5     push de    
0000:16CC C5     push bc    
0000:16CD FDE5   push iy    
0000:16CF DDE5   push ix    
0000:16D1 CDAE05 call Copy_virtual_overlapsafe(dst_pg, dst_off, src_pg, src_off, n)  
0000:16D4 DDE1   pop ix      
0000:16D6 FDE1   pop iy      
0000:16D8 C1     pop bc      
0000:16D9 D1     pop de      
0000:16DA E1     pop hl      
0000:16DB 10EA   djnz 16C7   ;; loop
0000:16DD C9     ret        




          advance_bhl_by_cde(a=dir)
;; called from 1 place above, and 2 places below
0000:16DE B7     or a        
0000:16DF 200E   jr nz,16EF  
;;
;; here when a = 0
;; bhl = bhl - cde
0000:16E1 AF     xor a      
0000:16E2 ED52   sbc hl,de   ;; hl = hl - de
0000:16E4 3005   jr nc,16EB  
;;
;; hl negative
0000:16E6 7C     ld a,h      ;; hl = hl + #4000
0000:16E7 C640   add a,40    
0000:16E9 67     ld h,a      
0000:16EA 05     dec b       ;; b--
;;
0000:16EB 78     ld a,b      ;; b = b - c
0000:16EC 91     sub c      
0000:16ED 47     ld b,a      
;;
0000:16EE C9     ret        
;;
;;
;; here when a <> 0
;; bhl = bhl + cde
0000:16EF 19     add hl,de   ;; hl = hl + de
0000:16F0 7C     ld a,h      
0000:16F1 FE40   cp 40       ;; hl - #4000
0000:16F3 3804   jr c,16F9   ;; jp if hl < #4000
;;
;; hl was >= #4000
0000:16F5 D640   sub 40      ;; hl = hl - #4000
0000:16F7 67     ld h,a      
0000:16F8 04     inc b       ;; b++
;;
0000:16F9 78     ld a,b      ;; b = b + c
0000:16FA 81     add a,c    
0000:16FB 47     ld b,a      
0000:16FC C9     ret        




          move_all_buffers_higher_than_fh_iy
;; I really do not know what the heck this is doing.  It seems to be moving
;; pointers to ram???????  It does not move any data????
;; called from 1 place above, with a=0,
;;         and 1 place below, with a=1.  
;; ix points at top of fh table
;; iy points at a particular fh
;; cde = filesize?????
;;
0000:16FD F5     push af    
0000:16FE 0600   ld b,00    
;;
;; loop   for b = 0 to 29 dec
0000:1700 78     ld a,b      
0000:1701 FE1E   cp 1E      
0000:1703 3067   jr nc,176C  ;; pop af and return
;;
0000:1705 DD7E00 ld a,(ix+00);; .code[loop]
0000:1708 FE14   cp 14      
0000:170A 2806   jr z,1712  
0000:170C FE0B   cp 0B      
0000:170E 2802   jr z,1712  
0000:1710 1850   jr 1762     ;; continue if not #0b or #14
;;
;;           IY+ : 00     01        02 03      04 05     06 07
;; Handle records: Byte   Byte      Word       Word      Word
;;                 code   filepage  filebegin  filesize  filepos
;;
;; we only get here when .code[loop]
;; is #14 or #0b, So, this is like
;; "for each #14 or #0B fh"
0000:1712 DD6E01 ld l,(ix+01);; .filepage[loopindex]
0000:1715 FD7E01 ld a,(iy+01);; .filepage[particular]
0000:1718 BD     cp l        ;; .filepage[par] - .filepage[loop]
;;
0000:1719 DD6E02 ld l,(ix+02);; hl = filebegin[loop]
0000:171C DD6603 ld h,(ix+03)
;;
0000:171F 2804   jr z,1725   ;; if .page's match
;;
0000:1721 303F   jr nc,1762  ;; if .page[loop] smaller, continue
;;
0000:1723 182A   jr 174F     ;; else .page[loop] bigger
;;
;; .page's match
0000:1725 E5     push hl    
0000:1726 D5     push de    
0000:1727 FD5E02 ld e,(iy+02)
0000:172A FD5603 ld d,(iy+03);; de = filebegin[par]
0000:172D AF     xor a      
0000:172E ED52   sbc hl,de   ;; filebegin[loop] - filebegin[par]
0000:1730 D1     pop de      
0000:1731 E1     pop hl      
0000:1732 382E   jr c,1762   ;; continue if filebegin[loop] smaller
;;
0000:1734 2019   jr nz,174F  ;; jp when filebegin[loop] bigger
;;
;; here when .filebegin's match, check if it is same fh!
0000:1736 E5     push hl    
0000:1737 D5     push de    
;;
0000:1738 DDE5   push ix    
0000:173A E1     pop hl      
;;
0000:173B FDE5   push iy    
0000:173D D1     pop de      
;;
0000:173E ED52   sbc hl,de   ;; loopptr - parptr
0000:1740 D1     pop de      
0000:1741 E1     pop hl      ;; hl = filebegin[loop]
0000:1742 281E   jr z,1762   ;; continue if loop is on same row as particular.
;;
;; different fh's, but they happen to have same start????
0000:1744 E5     push hl    
0000:1745 DD7E04 ld a,(ix+04);; filesize[loop]
0000:1748 DD6E05 ld l,(ix+05)
0000:174B B5     or l        
0000:174C E1     pop hl      ;; hl = filebegin[loop]
0000:174D 2813   jr z,1762   ;; continue if filesize[loop] = 0
;;
;; here when .page[loop] bigger
;; here when .pages match, but .filebegin[loop] bigger
;; here when .pages & .filebegin match, different fh's, & filesize[loop] <> 0
;;
;; Seems we get here for any fh row that has code #0b or #14, and an
;; address higher than the particular fh from caller, and we adjust
;; the address (up or down???) by the "filesize" amount from caller.
;;
0000:174F F1     pop af      ;; calling a val  (up/down)
0000:1750 F5     push af    
;;
;; advance begining of file[loop] by cde (filesize????)
0000:1751 C5     push bc    
0000:1752 DD4601 ld b,(ix+01);; b = .filepage[loop]  hl = filebegin[loop]
0000:1755 CDDE16 call advance_bhl_by_cde(a=dir)  
0000:1758 DD7001 ld (ix+01),b
0000:175B DD7502 ld (ix+02),l
0000:175E DD7403 ld (ix+03),h
0000:1761 C1     pop bc      
;;
;; continue
0000:1762 D5     push de    
0000:1763 110800 ld de,0008  
0000:1766 DD19   add ix,de   ;; ix points at next fh
0000:1768 D1     pop de      
0000:1769 04     inc b       ;; b++
0000:176A 1894   jr 1700     ;; loop
;;
;;
0000:176C F1     pop af      
0000:176D C9     ret        





          [05DE] nutherunknown(fh, n)
0000:176E DD210200 ld ix,0002  
0000:1772 DD39   add ix,sp  
0000:1774 DD7E00 ld a,(ix+00);; par0
0000:1777 FE1E   cp 1E       ;; fh - #1e
0000:1779 3806   jr c,1781   ;; jp if < 30 dec
;;
0000:177B 210000 ld hl,0000  
0000:177E 7C     ld a,h      
0000:177F B5     or l        
0000:1780 C9     ret        
;;
;; fh# was less than 30, convert it to fhptr
0000:1781 CD9112 call iy=fh_ptr(A=file#)  
;;
;;           IY+ : 00     01        02 03      04 05     06 07
;; Handle records: Byte   Byte      Word       Word      Word
;;                 code   filepage  filebegin  filesize  filepos
;;
0000:1784 FD7E00 ld a,(iy+00); Read byte from (IY)
0000:1787 FE14   cp 14       ; 20 or 11? -> Skip ahead
0000:1789 2807   jr z,1792  
0000:178B FE0B   cp 0B      
0000:178D 2803   jr z,1792  
0000:178F C38018 jp 1880     ; Else 1880  ;; ret err
;;
;; fh.code is #0B or #14
0000:1792 FD5E04 ld e,(iy+04)
0000:1795 FD5605 ld d,(iy+05);; de = fh.size
;;
0000:1798 DD6E02 ld l,(ix+02)
0000:179B DD6603 ld h,(ix+03);; hl = par2  (n)
;;
0000:179E AF     xor a      
0000:179F ED52   sbc hl,de   ;; n - fh.size     nc when n >= size
0000:17A1 3003   jr nc,17A6  
0000:17A3 C37318 jp 1873     ;; jp if n < size , set fh.pos = 0, and ret fh.code
;;
;; here when n >= fh.size
0000:17A6 DDE5   push ix     ;; *
0000:17A8 FDE5   push iy     ;; **
0000:17AA DD2116DA ld ix,larry03  ;; ix points at larry
;;
0000:17AE 0E00   ld c,00     ;; c is number of pages
;;
;; loop1
0000:17B0 7C     ld a,h      ;; hl is still n - size,
0000:17B1 FE40   cp 40       ;; diff - #4000
0000:17B3 3806   jr c,17BB   ;; jp if diff < #4000
;;
0000:17B5 D640   sub 40      ;; sub #4000, and bump pg count
0000:17B7 67     ld h,a      
0000:17B8 0C     inc c      
0000:17B9 18F5   jr 17B0     ;; loop1
;;
0000:17BB C5     push bc     ;; ***    diffpg
0000:17BC E5     push hl     ;; ****   diffoff
0000:17BD DD7E06 ld a,(ix+06);; curlypg
0000:17C0 81     add a,c    
0000:17C1 4F     ld c,a      ;; c = diffpgs + curlypg  (end page???)
;;
0000:17C2 DD5E07 ld e,(ix+07)
0000:17C5 DD5608 ld d,(ix+08)
0000:17C8 19     add hl,de   ;; hl = diffoffset + curlyoffset
;;
0000:17C9 7C     ld a,h      ;; normalize again
0000:17CA FE40   cp 40      
0000:17CC 3804   jr c,17D2  
0000:17CE D640   sub 40      
0000:17D0 67     ld h,a      
0000:17D1 0C     inc c      
;;
0000:17D2 79     ld a,c      
0000:17D3 FE08   cp 08       ;; endpg - 8
0000:17D5 3814   jr c,17EB   ;; jp if endpg < #08    (only 7 pgs of ram!!!)
;;
;; here if endpage goes past existing ram, ret err
0000:17D7 E1     pop hl      ;; ****
0000:17D8 C1     pop bc      ;; ***
0000:17D9 FDE1   pop iy      ;; **     fh_ptr
0000:17DB DDE1   pop ix      ;; *      param_ptr
;;
0000:17DD DD4E00 ld c,(ix+00);; par0
0000:17E0 DD4601 ld b,(ix+01)
0000:17E3 C5     push bc    
0000:17E4 CDEA05 call idunnoyet_close????(file#)  
0000:17E7 C1     pop bc      
0000:17E8 C38018 jp 1880     ;; ret err
;;
;; here when endpage is not past end of ram.
0000:17EB C5     push bc     ;; *****    c is endpg
0000:17EC FD5E04 ld e,(iy+04)
0000:17EF FD5605 ld d,(iy+05);; de = fh.filesize
;;
0000:17F2 FD4601 ld b,(iy+01);; b = fh.page
;;
0000:17F5 7A     ld a,d      ;; normalize
0000:17F6 FE40   cp 40      
0000:17F8 3806   jr c,1800  
0000:17FA D640   sub 40      
0000:17FC 57     ld d,a      
0000:17FD 04     inc b      
0000:17FE 18F5   jr 17F5    

0000:1800 FD6E02 ld l,(iy+02);; fh.filebegin
0000:1803 FD6603 ld h,(iy+03)
0000:1806 19     add hl,de  
;;
0000:1807 7C     ld a,h      ;; normalize
0000:1808 FE40   cp 40      
0000:180A 3804   jr c,1810  
0000:180C D640   sub 40      
0000:180E 67     ld h,a      
0000:180F 04     inc b      
;;
;;
0000:1810 DD2116DA ld ix,larry03  
0000:1814 DD4E06 ld c,(ix+06);; curlypg
0000:1817 79     ld a,c      
0000:1818 90     sub b      
0000:1819 47     ld b,a      ;; b = curlypg - b
;;
0000:181A E5     push hl    
0000:181B D1     pop de      
;;
0000:181C DD6E07 ld l,(ix+07);; curlyoffset
0000:181F DD6608 ld h,(ix+08)
0000:1822 E5     push hl    
0000:1823 DDE1   pop ix      
;;
0000:1825 FDE1   pop iy      ;; *****         endpg
;;
0000:1827 E1     pop hl      ;; ****          diffoff
0000:1828 E5     push hl     ;; ****
0000:1829 19     add hl,de  
;;
0000:182A 7C     ld a,h      ;; normalize
0000:182B FE40   cp 40      
0000:182D 3803   jr c,1832  
0000:182F D640   sub 40      
0000:1831 67     ld h,a      
;;
0000:1832 E5     push hl    
0000:1833 FDE5   push iy    
0000:1835 E1     pop hl      
0000:1836 FDE1   pop iy      
0000:1838 3E01   ld a,01    
0000:183A CD2B16 call aaaaaaaaaaaa  
0000:183D D1     pop de      
0000:183E C1     pop bc      
0000:183F FDE1   pop iy      
;;
0000:1841 DD2116DA ld ix,larry03  
0000:1845 DD4606 ld b,(ix+06);; bhl = curly  (freespace???)
0000:1848 DD6E07 ld l,(ix+07)
0000:184B DD6608 ld h,(ix+08)
0000:184E 3E01   ld a,01    
0000:1850 CDDE16 call advance_bhl_by_cde(a=dir)  
0000:1853 DD7006 ld (ix+06),b
0000:1856 DD7507 ld (ix+07),l
0000:1859 DD7408 ld (ix+08),h
;;
0000:185C 3E01   ld a,01    
0000:185E DD2126D9 ld ix,fh.code  
0000:1862 CDFD16 call move_all_buffers_higher_than_fh_iy  
0000:1865 DDE1   pop ix      
;;
0000:1867 DD6E02 ld l,(ix+02)
0000:186A DD6603 ld h,(ix+03)
0000:186D FD7504 ld (iy+04),l
0000:1870 FD7405 ld (iy+05),h
;;
;;
;; set fh.pos = #0000, and ret fh
0000:1873 AF     xor a      
0000:1874 FD7706 ld (iy+06),a;; fh.pos = #0000
0000:1877 FD7707 ld (iy+07),a
;;
0000:187A DD6E00 ld l,(ix+00);; par0  fh
0000:187D 67     ld h,a      
0000:187E 1803   jr 1883    
;;
;; ret err
0000:1880 21FF00 ld hl,00FF  
;;
;; ret hl
0000:1883 7C     ld a,h      
0000:1884 B5     or l        
0000:1885 C9     ret        





;;Interrupt service routine (both maskable and nonmaskable jump here)
;; ((I wonder why they point both types here???))
;; also, there is another level of masking.  port 3, and its shadow at #dba3,
;; appear to be mask bits.
          interrupt_svc:
0000:1886 F5     push af    
0000:1887 C5     push bc    
0000:1888 D5     push de    
0000:1889 E5     push hl    
0000:188A DDE5   push ix    
0000:188C FDE5   push iy    
0000:188E DB03   in a,(03)  
;;
;; These are the 8 possible interrupts, in priority of handling order.
;; each bit of p3/#dba3 is either a mask, or maybe an ack.
;; These bits of p3 are not necessarily indicating the source of int.  
;; There might just be a timer creating all ints.    
;; in that case, these bits are just to enable various things to happen
;; at that standard interval.
;; The following bit test/jumps sort out the highest priority that is enabled,
;; jumps to a sort of wrapper that is either acking/reseting the int,
;; or else masking further int, maybe both.
;;
0000:1890 CB7F   bit 7,a    
0000:1892 C24019 jp nz,1940  ;;jump if p3.7    CALLs #3B19     (caller_id_handler)
0000:1895 CB6F   bit 5,a    
0000:1897 C21719 jp nz,1917  ;;jump if p3.5    sets bit 0 of #D631 (whatisit???) (related to rtc???)
0000:189A CB77   bit 6,a    
0000:189C C22E19 jp nz,192E  ;;jump if p3.6    CALLs #3532     (Modem handler)
0000:189F CB67   bit 4,a    
0000:18A1 C20519 jp nz,1905  ;;jump if p3.4    CALLS #1CAF     (increment time16)

0000:18A4 CB5F   bit 3,a    
0000:18A6 C2F618 jp nz,18F6  ;;jump if p3.3    null
0000:18A9 CB47   bit 0,a    
0000:18AB C2C518 jp nz,18C5  ;;jump if p3.0    null

0000:18AE DB03   in a,(03)  
0000:18B0 CB4F   bit 1,a    
0000:18B2 C2D418 jp nz,18D4  ;;jump if p3.1    ; KB scan
0000:18B5 CB57   bit 2,a    
0000:18B7 C2E718 jp nz,18E7  ;;jump if p3.2    null

;; Exit from interrupts  (common to all 8)
0000:18BA FDE1   pop iy      
0000:18BC DDE1   pop ix      
0000:18BE E1     pop hl      
0000:18BF D1     pop de      
0000:18C0 C1     pop bc      
0000:18C1 F1     pop af      
0000:18C2 FB     ei          
0000:18C3 ED4D   reti        

;;isr 3.0 , null
0000:18C5 3AA2DB ld a,(p3shadow) ;; toggle p3.0 low, then high
0000:18C8 E6FE   and FE      
0000:18CA D303   out (03),a  
0000:18CC 3AA2DB ld a,(p3shadow)
0000:18CF D303   out (03),a  
0000:18D1 C3BA18 jp 18BA     ;;reti

;;isr 3.1 , keyscan
0000:18D4 3AA2DB ld a,(p3shadow) ;; toggle p3.1 low ...    (i.e. disable keyscan interrupt while scaning kb)
0000:18D7 E6FD   and FD      
0000:18D9 D303   out (03),a  ;; mask, to prevent isr being interrupted???
0000:18DB CDB71C call 1CB7   ; Keyboard scan  ;; this is the only one that uses the masking.
0000:18DE F3     di          ;; and STAY masked! (til ret code reenables.)((at least the maskable int stays masked.))
0000:18DF 3AA2DB ld a,(p3shadow) ;; ... and then high.      (reenable)  ((this seems to imply kb uses maskable int?))
0000:18E2 D303   out (03),a  ;;
0000:18E4 C3BA18 jp 18BA     ;;reti

;;isr 3.2 , null
0000:18E7 3AA2DB ld a,(p3shadow) ;; toggle p3.2 low, then high.  There seems to be unused interupts.
0000:18EA E6FB   and FB      
0000:18EC D303   out (03),a  
0000:18EE 3AA2DB ld a,(p3shadow)
0000:18F1 D303   out (03),a  
0000:18F3 C3BA18 jp 18BA     ;;reti

;;isr 3.3 , null
0000:18F6 3AA2DB ld a,(p3shadow) ;; toggle p3.3 low, then high
0000:18F9 E6F7   and F7      
0000:18FB D303   out (03),a  
0000:18FD 3AA2DB ld a,(p3shadow)
0000:1900 D303   out (03),a  
0000:1902 C3BA18 jp 18BA     ;;reti

;;isr 3.4 , increment #e612  (time16)
0000:1905 3AA2DB ld a,(p3shadow) ;; toggle p3.4 low, then high.  The toggling of the mask may be reseting the int???
0000:1908 E6EF   and EF      ;; otherwide why do it here, where the masking is not used?
0000:190A D303   out (03),a  
0000:190C 3AA2DB ld a,(p3shadow)
0000:190F D303   out (03),a  ;; reenabled, BEFORE the business part of the int happens!
0000:1911 CDAF1C call 1CAF   ;; increments time16_counter
0000:1914 C3BA18 jp 18BA     ;; reti

;;isr 3.5 , set bit 0 of #d631
0000:1917 3AA2DB ld a,(p3shadow) ;; toggle p3.5 low, then high
0000:191A E6DF   and DF      
0000:191C D303   out (03),a  
0000:191E 3AA2DB ld a,(p3shadow)
0000:1921 D303   out (03),a  
0000:1923 3A31D6 ld a,(flagz) ;; set bit 0 of #d631.  (whatisit???)
0000:1926 CBC7   set 0,a    
0000:1928 3231D6 ld (flagz),a
0000:192B C3BA18 jp 18BA     ;;reti

;;isr 3.6
0000:192E 3AA2DB ld a,(p3shadow) ;; toggle p3.6 low, then high
0000:1931 E6BF   and BF      
0000:1933 D303   out (03),a  
0000:1935 3AA2DB ld a,(p3shadow)
0000:1938 D303   out (03),a  
0000:193A CD3235 call Modem_handler   ;; modem handler
0000:193D C3BA18 jp 18BA     ;; reti

;;isr 3.7
0000:1940 3AA2DB ld a,(p3shadow) ;; toggle p3.7 low, then high
0000:1943 E67F   and 7F      
0000:1945 D303   out (03),a  
0000:1947 3AA2DB ld a,(p3shadow)
0000:194A D303   out (03),a  
0000:194C CD193B call caller_id_handler   ;;whatisit???  it's caller_id_handler!!!!!
0000:194F C3BA18 jp 18BA     ;; reti



          [05ED] Call_Far(page, address, params...)
;; bank switch.  rom page  and jump address on stack.
;; (used by other pages, to call arbitrary page.)
;; This is almost identical to routine at #19AE, which is used
;; to call routines via the huge jump table at #06xx-0Cxx.
;; This version does not use such a table, it receives page
;; and address as parameters.
;; Seems a bit redundant.  The other may be faster, at the
;; expense of trashing HL & DE, and requiring the jump table.
;; Both require the compiler to push the params on stack.
;; Maybe the difference is that the table based calls are just
;; for the "library" code, and here we can access "user" code???
;; It's sort of like a run time link, maybe??????  But not
;; really, coz the called addresses are compiled in to the
;; calling code.  They're just not known here.
0000:1952 32A0DB ld (banksw_saveA),a ;; save A
0000:1955 D9     exx         ;; swap BCDEHL with BCDEHL'
0000:1956 D1     pop de      ;; grab ret add off stack
;;
;; save retadd & current slot4000 inhabitant in special "stack" pointed to by (#DB1E)
0000:1957 2A1DDB ld hl,(bank_save_ptr);; get bank switch savearea pointer
0000:195A 73     ld (hl),e   ;; save return address
0000:195B 23     inc hl      
0000:195C 72     ld (hl),d  
0000:195D 23     inc hl      
0000:195E DB05   in a,(05)   ;; save slot4000 page
0000:1960 77     ld (hl),a  
0000:1961 23     inc hl      
0000:1962 DB06   in a,(06)   ;; save slot4000 device
0000:1964 E60F   and 0F      ;; low 4 bits only??? what is in the hi 4 bits?????
0000:1966 77     ld (hl),a  
0000:1967 23     inc hl      
0000:1968 221DDB ld (bank_save_ptr),hl;; put the updated pointer back where we got it
;;
0000:196B D1     pop de      ;; get page param off stack  (par0)
0000:196C 7A     ld a,d      ;; device byte to p6
0000:196D D306   out (06),a  
0000:196F CB67   bit 4,a    
0000:1971 280D   jr z,1980   ;; bit 4 of device byte zero?
;;
;; device bit 4 was 1.  lookup wozthis in the magicsector, add looked up value to page.
0000:1973 2A19D7 ld hl,(wozthis);; wozthis???
0000:1976 D5     push de     ;; save page byte (E)
0000:1977 E5     push hl     ;; L is byte to scan for...
0000:1978 CDD60A call L = Scan_Magicsector(who)   ;; scan for wozthis
0000:197B 7D     ld a,l      ;; ret val in A, to be added to page byte
0000:197C E1     pop hl      ;; lose param
0000:197D D1     pop de      ;; page byte in E
0000:197E 83     add a,e    
0000:197F 5F     ld e,a      ;; page = page + lookup
;;
;; device bit 4 was 0. (and 1, after adjusting page)
0000:1980 7B     ld a,e      ;; possibly adjusted page# to slot4000page
0000:1981 D305   out (05),a  ;;
0000:1983 E1     pop hl      ;; jump address in that bank  (par2)
0000:1984 118E19 ld de,198E  
0000:1987 D5     push de     ;; push address of unbank routine (cleanup)
0000:1988 E5     push hl     ;; push the address of the selected code in the new bank (ret will jump there!)
0000:1989 D9     exx         ;; swap the regs back
0000:198A 3AA0DB ld a,(banksw_saveA) ;; restore A
0000:198D C9     ret         ;; funny way to jump, now ret add is unbank, when the referenced code returns!!!

;; unbank for above routine
0000:198E 32A0DB ld (banksw_saveA),a ;; save A
0000:1991 D9     exx         ;; swap BCDEHL with BCDEHL'
0000:1992 2A1DDB ld hl,(bank_save_ptr);; get bank switch savearea pointer
0000:1995 2B     dec hl      
0000:1996 7E     ld a,(hl)  
0000:1997 D306   out (06),a  ;; restore p6  (we ANDed with 0F before saving.  why???  so as not to change ram???)
0000:1999 2B     dec hl      
0000:199A 7E     ld a,(hl)  
0000:199B D305   out (05),a  ;; restore p5
0000:199D 2B     dec hl      
0000:199E 46     ld b,(hl)   ;; get saved return address into BC
0000:199F 2B     dec hl      
0000:19A0 4E     ld c,(hl)  
0000:19A1 221DDB ld (bank_save_ptr),hl;; put the updated pointer back where we got it
0000:19A4 C5     push bc     ;; put dummy params back (so caller can pop something, make the shit come out right)
0000:19A5 C5     push bc     ;; 2nd dummy param
0000:19A6 C5     push bc     ;; now, put that saved return address on stack
0000:19A7 D9     exx         ;; swap the regs back
0000:19A8 7C     ld a,h      ;; set flags
0000:19A9 B5     or l        
0000:19AA 3AA0DB ld a,(banksw_saveA) ;; restore A (I guess we don't trust A to be always "H or L",
;;                                  ;;                      even if we set flags based on that)
0000:19AD C9     ret         ;; FINALLY, return to whoever called the routine that was banked in!


          Thru_Stargate
;;This is almost identical to the "call_far" above.  The difference is this one
;;gets the dest address in registers, not on stack.  It seems to be used only
;;for calling code that is compiled into the page 0 jumptable, where the other
;;routine can call code compiled AFTER the page 0 has been fixed in rom???
;;
;; System_Call_Far(D = device, E = page, HL = offset, actualparams.....)
;; Banks in rom page number in DE, and jumps to address in HL.
;; (used by the jump table at begining of rom.)
0000:19AE 32A0DB ld (banksw_saveA),a ;; save A
0000:19B1 D9     exx         ;; swap BCDEHL with BCDEHL'
0000:19B2 D1     pop de      ;; grab ret add
0000:19B3 2A1DDB ld hl,(bank_save_ptr);; get bank switch savearea pointer (another stack? is the SP stack banked out???)
0000:19B6 73     ld (hl),e   ;; save return address
0000:19B7 23     inc hl      
0000:19B8 72     ld (hl),d  
0000:19B9 23     inc hl      
0000:19BA DB05   in a,(05)   ;; save p5  (page#)
0000:19BC 77     ld (hl),a  
0000:19BD 23     inc hl      
0000:19BE DB06   in a,(06)   ;; save low 4 bits of p6  (device#)
0000:19C0 E60F   and 0F      
0000:19C2 77     ld (hl),a  
0000:19C3 23     inc hl      
0000:19C4 221DDB ld (bank_save_ptr),hl;; put the updated pointer back where we got it
0000:19C7 D9     exx         ;; swap the regs back
0000:19C8 7A     ld a,d      ;;        the bank references at the begining of this seg all zero in D byte of DE
0000:19C9 D306   out (06),a  ;; calling D value to p6  ;; D is usually 00 , at least in that first jump table.
0000:19CB CB67   bit 4,a    
0000:19CD 280F   jr z,19DE   ;; bit 4 of D = 0??  , then adjust E.  but why???
;;
;; bit 4 was 1.  lookup wozthis in the magicsector, add looked up value to page.
0000:19CF E5     push hl     ;; save HL, DE
0000:19D0 D5     push de    
0000:19D1 2A19D7 ld hl,(wozthis);; wozthis???
0000:19D4 E5     push hl     ;; push param for scan
0000:19D5 CDD60A call L = Scan_Magicsector(who)   ;; L = Scan_Magicsector(wozthis)
0000:19D8 7D     ld a,l      ;; ret val in A, to be added to E
0000:19D9 E1     pop hl      ;; lose param
0000:19DA D1     pop de      ;; restore DE, HL
0000:19DB E1     pop hl      
0000:19DC 83     add a,e    
0000:19DD 5F     ld e,a      
;;
;; bit 4 was 0. (and 1, after adjusting page)
0000:19DE 7B     ld a,e      ;; jumps in here when bit 4 of D is zero
0000:19DF D305   out (05),a  ;; possibly adjusted E to p5
0000:19E1 11EA19 ld de,19EA  
0000:19E4 D5     push de     ;; push address of unbank routine (cleanup)
0000:19E5 E5     push hl     ;; push the address of the selected code in the new bank (ret will jump there!)
0000:19E6 3AA0DB ld a,(banksw_saveA) ;; restore A
0000:19E9 C9     ret         ;; funny way to jump, now ret add is unbank, when the referenced code returns!!!

;; Unbank  (undoes what the above routine did)
0000:19EA 32A0DB ld (banksw_saveA),a ;; save A
0000:19ED D9     exx         ;; swap BCDEHL with BCDEHL'
0000:19EE 2A1DDB ld hl,(bank_save_ptr);; get bank switch savearea pointer
0000:19F1 2B     dec hl      
0000:19F2 7E     ld a,(hl)  
0000:19F3 D306   out (06),a  ;; restore p6  (we ANDed with 0F before saving.  why???  so as not to change ram???)
0000:19F5 2B     dec hl      
0000:19F6 7E     ld a,(hl)  
0000:19F7 D305   out (05),a  ;; restore p5
0000:19F9 2B     dec hl      
0000:19FA 46     ld b,(hl)   ;; get saved return address into BC
0000:19FB 2B     dec hl      
0000:19FC 4E     ld c,(hl)  
0000:19FD 221DDB ld (bank_save_ptr),hl;; put the updated pointer back where we got it
0000:1A00 C5     push bc     ;; put that return address on stack
0000:1A01 D9     exx         ;; swap the regs back
0000:1A02 7C     ld a,h      ;; set flags
0000:1A03 B5     or l        
0000:1A04 3AA0DB ld a,(banksw_saveA) ;; restore A
0000:1A07 C9     ret         ;; FINALLY, return to whoever called the routine that was banked in!

          Read_printer_data()
; Read data from printer port?
0000:1A08 3E00   ld a,00     ;; I can't find any reference to this routine in the first 4 pages (64k)
0000:1A0A D32C   out (2C),a  ;; Parallel Port DDR = #00
0000:1A0C DB2D   in a,(2D)   ;; A = Parallel Port Data
0000:1A0E 6F     ld l,a      
0000:1A0F 2600   ld h,00    
0000:1A11 B4     or h        
0000:1A12 C9     ret        

          Write_printer_data(abyte)
; Write_printer_data(abyte)
0000:1A13 210200 ld hl,0002  
0000:1A16 39     add hl,sp  
0000:1A17 3EFF   ld a,FF    
0000:1A19 D32C   out (2C),a  ; DDR = Out  ;;(Parallel Port)
0000:1A1B 7E     ld a,(hl)  
0000:1A1C D32D   out (2D),a  ; Write to printer data port
0000:1A1E C9     ret        

          Read_printer_status()
; Read printer status
0000:1A1F DB21   in a,(21)   ; Return (PORT(21) & 0xF8)
0000:1A21 E6F8   and F8      
0000:1A23 6F     ld l,a      
0000:1A24 2600   ld h,00    
0000:1A26 B4     or h        
0000:1A27 C9     ret        

          Write_printer_control(abyte)
0000:1A28 210200 ld hl,0002  
0000:1A2B 39     add hl,sp  
0000:1A2C 3E0F   ld a,0F    
0000:1A2E D30A   out (0A),a  ;; printer control direction = #0F
0000:1A30 7E     ld a,(hl)  
0000:1A31 D309   out (09),a  ;; printer control = parameter
0000:1A33 C9     ret        


;; My best guess is this is a pseudo-random function.
          [0839] random(limit)
0000:1A34 210200 ld hl,0002  
0000:1A37 39     add hl,sp  
;;
0000:1A38 5E     ld e,(hl)   ;; DE = par0
0000:1A39 23     inc hl      
0000:1A3A 56     ld d,(hl)  
;;
0000:1A3B ED4B5ED4 ld bc,(time32);; bc = time32
0000:1A3F 2A1BDB ld hl,(random??????);; hl = somethin???
0000:1A42 09     add hl,bc  
0000:1A43 EB     ex de,hl    ;;   (de = time32 + somethin , hl = param )
0000:1A44 CDE001 call de=de/hl,hl=rem,unsigned   ;;   (DE = time32 + somethin / param ,  HL = remainder)
0000:1A47 221BDB ld (random??????),hl;; somethin = time32 + somethin mod param
0000:1A4A 7C     ld a,h      
0000:1A4B B5     or l        
0000:1A4C C9     ret        

;; this, and next 1, are not called iffp, at least not directly.
;; get4000device().   returns current device in slot4000
0000:1A4D DB06   in a,(06)  
0000:1A4F 6F     ld l,a      
0000:1A50 2600   ld h,00    
0000:1A52 B4     or h        
0000:1A53 C9     ret        

;; set4000device(newdevice)    sets new, returns old device in slot4000
0000:1A54 210200 ld hl,0002  
0000:1A57 39     add hl,sp  
0000:1A58 DB06   in a,(06)  
0000:1A5A 4F     ld c,a      
0000:1A5B 7E     ld a,(hl)  
0000:1A5C D306   out (06),a  
0000:1A5E 69     ld l,c      
0000:1A5F 2600   ld h,00    
0000:1A61 B4     or h        
0000:1A62 C9     ret        

;; set4000codepage(newpage)    sets device = coderom, page = newpage, returns oldpage
[05F6]
0000:1A63 210200 ld hl,0002  
0000:1A66 39     add hl,sp  
0000:1A67 3E00   ld a,00    
0000:1A69 D306   out (06),a  
0000:1A6B DB05   in a,(05)  
0000:1A6D 4F     ld c,a      
0000:1A6E 7E     ld a,(hl)  
0000:1A6F D305   out (05),a  
0000:1A71 69     ld l,c      
0000:1A72 2600   ld h,00    
0000:1A74 7D     ld a,l      
0000:1A75 B4     or h        
0000:1A76 C9     ret        

;; Code4000().   sets slot4000 device = coderom, returns current page
[05F9]
0000:1A77 3E00   ld a,00    
0000:1A79 D306   out (06),a  
0000:1A7B DB05   in a,(05)  
0000:1A7D 6F     ld l,a      
0000:1A7E 2600   ld h,00    
0000:1A80 B4     or h        
0000:1A81 C9     ret        

;; [05F0] Rampage(newpage).  sets slot8000 device = ram, page = newpage, returns oldpage
          [05F0]  Rampage!(new)
0000:1A82 210200 ld hl,0002  
0000:1A85 39     add hl,sp  
0000:1A86 3E01   ld a,01     ;; set8000device = ram
0000:1A88 D308   out (08),a  
0000:1A8A DB07   in a,(07)   ;; grab oldpage
0000:1A8C 4F     ld c,a      
0000:1A8D 7E     ld a,(hl)   ;; set8000page(par0)
0000:1A8E D307   out (07),a  
0000:1A90 69     ld l,c      ;; ret HL, A = oldpage
0000:1A91 2600   ld h,00    
0000:1A93 7C     ld a,h      
0000:1A94 B5     or l        
0000:1A95 C9     ret        

;; [05F3] What_Rampage().  sets slot8000device = ram , no change to page, rets currentpage
          [05F3] What_Rampage?
0000:1A96 3E01   ld a,01    
0000:1A98 D308   out (08),a  ;; set8000device = ram
0000:1A9A DB07   in a,(07)  
0000:1A9C 6F     ld l,a      ;; L = curpage
0000:1A9D 2600   ld h,00    
0000:1A9F B4     or h        
0000:1AA0 C9     ret         ;; ret HL, A = curpage

;; set4000datapage(newpage).   sets slot4000 device = dataflash, page = newpage, rets oldpage
[05FC]
0000:1AA1 210200 ld hl,0002  
0000:1AA4 39     add hl,sp  
0000:1AA5 3E03   ld a,03     ;; set4000device = dataflash
0000:1AA7 D306   out (06),a  
0000:1AA9 DB05   in a,(05)  
0000:1AAB 4F     ld c,a      ;; grab oldpage
0000:1AAC 7E     ld a,(hl)  
0000:1AAD D305   out (05),a  ;; set4000page = param
0000:1AAF 69     ld l,c      
0000:1AB0 2600   ld h,00    
0000:1AB2 7C     ld a,h      
0000:1AB3 B5     or l        
0000:1AB4 C9     ret         ;; ret HL, A = oldpage

;; set4000data().   sets slot4000 device = dataflash, returns current page.
[05FF]
0000:1AB5 3E03   ld a,03     ;; set4000device = dataflash
0000:1AB7 D306   out (06),a  
0000:1AB9 DB05   in a,(05)   ;; grab curpage
0000:1ABB 6F     ld l,a      
0000:1ABC 2600   ld h,00    
0000:1ABE B4     or h        
0000:1ABF C9     ret         ;; ret HL, A = curpage



          powerdown
;; called in test mode.  also sometimes called from keyscan, indirectly
;; Shuts off the +5v to most of the board, then puts CPU to sleep.
0000:1AC0 F3     di          
;;
0000:1AC1 3A9FDB ld a,(p28shadow) ;; set p28.0  either modem reset, or I am a pin off on Vcc control bit?????
0000:1AC4 CBC7   set 0,a     ;; Yeah, this makes more sense as "power off"
0000:1AC6 47     ld b,a      
0000:1AC7 D328   out (28),a  
;;
0000:1AC9 11E803 ld de,03E8  
0000:1ACC D5     push de    
0000:1ACD CD5C0A call Delay(msec)   ;; delay
0000:1AD0 D1     pop de      
;;
0000:1AD1 78     ld a,b      ;; reset p28.0
0000:1AD2 CB87   res 0,a    
0000:1AD4 D328   out (28),a  
;;
0000:1AD6 76     halt        ;; stop cpu.  interrupts can wake it, I guess.
0000:1AD7 C9     ret        



;; Set_yougotmail_LED(on_or_off).  (1=on)
; Set/clear P2.4 based on passed value
          [0A77] set_yougotmail_LED(newstate)
0000:1AD8 210200 ld hl,0002  
0000:1ADB 39     add hl,sp  
0000:1ADC 6E     ld l,(hl)   ;
0000:1ADD 3AA1DB ld a,(p2shadow) ; A=P2 shadow
0000:1AE0 67     ld h,a      
0000:1AE1 7D     ld a,l      
0000:1AE2 FE01   cp 01       ; param=1?
0000:1AE4 7C     ld a,h      
0000:1AE5 2004   jr nz,1AEB  ; No -> Clear P2.4
0000:1AE7 CBE7   set 4,a    
0000:1AE9 1802   jr 1AED     ; Else Set P2.4
0000:1AEB CBA7   res 4,a    
0000:1AED 32A1DB ld (p2shadow),a
0000:1AF0 D302   out (02),a  
0000:1AF2 C9     ret        

; Table
0000:1AF3 01     defb 01    
0000:1AF4 02     defb 02    
0000:1AF5 04     defb 04    
0000:1AF6 08     defb 08    
0000:1AF7 10     defb 10    
0000:1AF8 20     defb 20    
0000:1AF9 40     defb 40    
0000:1AFA 80     defb 80     ;DB       01 02 04 08 10 20 40 80     ;; (DB meaning "Define Byte", not #DB)

;; If b = 1, set bit c of p3, else reset bit c of p3  (enable or disable interrupt)
; Translate bit position given in C (0-7) to bit mask and apply it to A
; before writing to P3
; If C out of range (>8) return 0
; If C=1, Clear bit 2
; Else OR mask with A
          [0A2F] set_interrupt(int#=C, enable=B)
0000:1AFB 79     ld a,c      
0000:1AFC FE08   cp 08      
0000:1AFE 3025   jr nc,1B25  ;; ret 0 if c > 7
0000:1B00 C5     push bc    
0000:1B01 0600   ld b,00    
0000:1B03 21F31A ld hl,1AF3  
0000:1B06 09     add hl,bc  
0000:1B07 66     ld h,(hl)   ;; h has table(c)
0000:1B08 F1     pop af      ;; a is calling b
0000:1B09 FE01   cp 01      
0000:1B0B 2006   jr nz,1B13  ;; test if b = 1
0000:1B0D 3AA2DB ld a,(p3shadow) ;; if b was 1, set bit c of p3 shadow.  enable interrupt?
0000:1B10 B4     or h        
0000:1B11 1807   jr 1B1A    
0000:1B13 7C     ld a,h      ;; if b was not 1, reset bit c of p3 shadow.  disable interrupt?
0000:1B14 2F     cpl        
0000:1B15 67     ld h,a      
0000:1B16 3AA2DB ld a,(p3shadow)
0000:1B19 A4     and h      
0000:1B1A 32A2DB ld (p3shadow),a
0000:1B1D D303   out (03),a  
0000:1B1F 210100 ld hl,0001  ;; ret 1
0000:1B22 7C     ld a,h      
0000:1B23 B5     or l        
0000:1B24 C9     ret        
0000:1B25 210000 ld hl,0000  ;; ret 0
0000:1B28 7C     ld a,h      
0000:1B29 B5     or l        
0000:1B2A C9     ret        


; Init ports and memory locations
;; NOTE: ((prolly any bidir ports have dir out BEFORE init value??? yes??? no???  ok, maybe???))
;; NOTE2: this board allows turning on/off certain devices, so there is surely at least one port
;; for power control bits???
;; I wanna call this section "The Loadout"   :^] :^] :^]  (with appology to Jackson Browne)
          The_Loadout
0000:1B2B 3E01   ld a,01     ; P8=1 (4000h)    ;; slot8000 device is ram
0000:1B2D D308   out (08),a  
;;
0000:1B2F 3E01   ld a,01     ; P7=1 (4000h)???  ;; slot8000 page = 1  (page 1 of the ram, tho!)
0000:1B31 D307   out (07),a  
;;
0000:1B33 3E00   ld a,00     ; P1=0 (keyboard lines low???)
0000:1B35 D301   out (01),a  
;;
0000:1B37 3E30   ld a,30     ; E610=30h  ;; why does this "out" crash debugger???????
0000:1B39 320FE6 ld (p0Dshadow),a ;; Because it changes the CPU clock rate!!!  (And that, um, uh, changes
0000:1B3C D30D   out (0D),a  ; Port D = 30h  ;; the serial baud rate.  <shuffle> heh.  So sue me.)
;;
0000:1B3E 3E80   ld a,80     ;; Related to above.  Possibly (in conjunction with above) this makes 12MHz?????
0000:1B40 3210E6 ld (p2Fshadow),a ; E611=80h        ;; There is routine that sets both P0D & P2F, at #0A23.
0000:1B43 D32F   out (2F),a  ; Port 2F = 80h   ;; I tested various vals for Port #0d, and #30 made 10 MHz, but I
;;                                                    ;; think P2F was #00 when I tested.
0000:1B45 3EFF   ld a,FF    
0000:1B47 D30B   out (0B),a  ; Port B = FF    ;; direction for port 2
0000:1B49 3E24   ld a,24    
0000:1B4B 32A1DB ld (p2shadow),a ; Port 2 = 24h   ;; (2.5 & 2.2 set)
0000:1B4E D302   out (02),a  
;;
0000:1B50 3E00   ld a,00     ; Port 3 = 0  ;; disable all interrupts (software mask)
0000:1B52 32A2DB ld (p3shadow),a
0000:1B55 D303   out (03),a  
;;
0000:1B57 3E0F   ld a,0F     ; Port A = F   ;;(4in/4out)
0000:1B59 D30A   out (0A),a  ;; parallel control direction = #0F  (ins are power detects, & power button)
0000:1B5B 3E0F   ld a,0F     ; Port 9 = F
0000:1B5D D309   out (09),a  ;; parallel control = #0F
;;
0000:1B5F 3E03   ld a,03     ; Port 29 = 3  ;; probably dir for p28???
0000:1B61 D329   out (29),a  
0000:1B63 3E00   ld a,00     ; Port 28 = 0  ;; callid, power, modem reset
0000:1B65 329FDB ld (p28shadow),a
0000:1B68 D328   out (28),a  
;;
0000:1B6A 3EFF   ld a,FF     ; Port 2C = FF
0000:1B6C D32C   out (2C),a  ;; parallel port DDR
;;
0000:1B6E DB1F   in a,(1F)   ; Port 1F |= 0x0C
0000:1B70 F60C   or 0C      
0000:1B72 D31F   out (1F),a  
;;
0000:1B74 AF     xor a      
0000:1B75 3231D6 ld (flagz),a ; D631 = 0    ;; clear flags (bit 3 & 4 used by keyboard int, 0 by rtc?????)
;;
0000:1B78 211FDB ld hl,banksavearea  ;; hl = beginning address of bank-switch routine's savearea (a stack)
0000:1B7B 221DDB ld (bank_save_ptr),hl; DB1E=DB20   ;; init (#DB1E), the bank-switch savearea stack pointer.
0000:1B7E C9     ret        


; Return state of P2.7
          [0A71] is_lcd_on?
0000:1B7F 3AA1DB ld a,(p2shadow)
0000:1B82 CB7F   bit 7,a    
0000:1B84 2006   jr nz,1B8C  
0000:1B86 210000 ld hl,0000  
0000:1B89 7C     ld a,h      
0000:1B8A B5     or l        
0000:1B8B C9     ret        
0000:1B8C 210100 ld hl,0001  
0000:1B8F 7C     ld a,h      
0000:1B90 B5     or l        
0000:1B91 C9     ret        


;; ret 1 if +6 volts exists, 0 if not (port9.7).
;; I believe it also means the powerpack is powering unit.
          [0A74] Wall_Adaptor_detect
0000:1B92 DB09   in a,(09)  
0000:1B94 CB7F   bit 7,a    
0000:1B96 2006   jr nz,1B9E  ;;jump if 9.7 = 1
0000:1B98 210000 ld hl,0000  
0000:1B9B 7C     ld a,h      
0000:1B9C B5     or l        
0000:1B9D C9     ret         ;;if p9.7 = 0, then return hl=0000, a=00, z flag = 1
;;
0000:1B9E 210100 ld hl,0001  
0000:1BA1 7C     ld a,h      
0000:1BA2 B5     or l        
0000:1BA3 C9     ret         ;;if p9.7 = 1, then return hl=0001, a=01, z flag = 0

; Return state of P9, bits 5 and 6
; P5 = 0, P6=X? -> Return 2
; P5 = 1, P6=0? -> Return 1
; P5 = 1, P6=1? -> Return 0
;;
;; Low_battery_detect().  tests p9.5 & p9.6 ,  rets 0, 1, or 2.
;; there seems to be two diferent ideas of "low" here.
;; The signal that the dc-dc calls "low" seems to be the "lower" of the two!
;;*** I have a vauge notion that I might have got the low/dead reversed, but
;;*** I'm too tired right now to check it.  BEWARE!!!!!!!
          [0A7A] Low_battery_detect()
0000:1BA4 DB09   in a,(09)   ;;
0000:1BA6 CB6F   bit 5,a     ;; p9.5 is lo-battery signal from dc-dc converter chip
0000:1BA8 2006   jr nz,1BB0  ;; jp if dc-dc = 1
;;
;; here if dc-dc sez bat low
0000:1BAA 210200 ld hl,0002  ;; else, ret 2  (i think this is "battery dead, or missing")
0000:1BAD 7C     ld a,h      
0000:1BAE B5     or l        
0000:1BAF C9     ret        
;;
;; here if dc-dc sez bat not low (good enough to make +5v, but how good is that?  the next test seems to test that!
;; I think this is testing if batt is above some threshold, prob higher than dc-dc idea of low batt.
0000:1BB0 CB77   bit 6,a     ;; test "battery good" signal
0000:1BB2 2006   jr nz,1BBA  ;; jp if good
;;
0000:1BB4 210100 ld hl,0001  ;; else, ret 1   (i think this is "battery low")
0000:1BB7 7C     ld a,h      
0000:1BB8 B5     or l        
0000:1BB9 C9     ret        
;;
0000:1BBA 210000 ld hl,0000  ;; both were = 1 , ret 0  (i think this is "battery good")
0000:1BBD 7C     ld a,h      ;;   YES, ret of 0 is as good as wallwart when
0000:1BBE B5     or l        ;;   downloading mail.
0000:1BBF C9     ret        



          Reflash!
; Copy reprogram routine to RAM, then execute  ;; called from routine at #03:451C
0000:1BC0 F3     di          
;;
0000:1BC1 3AA1DB ld a,(p2shadow) ; P2.7=1  ;; Turn LCD on
0000:1BC4 CBFF   set 7,a    
0000:1BC6 32A1DB ld (p2shadow),a
0000:1BC9 D302   out (02),a  
;;
0000:1BCB CD850A call Clear_LCD   ; Clear LCD
;;
0000:1BCE 3AA1DB ld a,(p2shadow)
0000:1BD1 CBE7   set 4,a    
0000:1BD3 32A1DB ld (p2shadow),a
0000:1BD6 D302   out (02),a  ; P2.4=1 ;; yougotmail_LED on
;;
0000:1BD8 3E01   ld a,01    
0000:1BDA D308   out (08),a  ; P8=1   ;; slot #8000 device = ram
0000:1BDC 3E05   ld a,05    
0000:1BDE D307   out (07),a  ; P7=5   ;; slot #8000 page = 5 (of ram)
;;
0000:1BE0 3E00   ld a,00    
0000:1BE2 D306   out (06),a  ; P6=0   ;; slot #4000 device = codeflash
0000:1BE4 3E01   ld a,01    
0000:1BE6 D305   out (05),a  ; P5=1   ;; slot #4000 page = 1  (of codeflash)
;;
0000:1BE8 21434F ld hl,4F43  ;; end addr of flash routine
0000:1BEB 010040 ld bc,4000  ;; start addr of flash routine
0000:1BEE B7     or a        
0000:1BEF ED42   sbc hl,bc   ;; end - start
0000:1BF1 4D     ld c,l      ;; BC = length
0000:1BF2 44     ld b,h      
0000:1BF3 210040 ld hl,4000  ;; point at routine
0000:1BF6 110080 ld de,8000  ;; point at dest
0000:1BF9 EDB0   ldir        ; Copy F43 bytes from 4000h (ROM) to 8000h (RAM)
0000:1BFB C30080 jp 8000     ; Jump to RAM



;; (( I think this might be looking up a string in dataflash ))
;; Hey! maybe this is accessing the loaded app data!!!  
;; It seems to match the data format for app, and, DOH! the "magicsector"
;; is dataflash pg #08 sect #00, which we know holds data regarding the loaded
;; applications.  So, now we know a bit about the format of the mystery data
;; in #08:00:xx.  (iow, #08:00:xx *is* the magicsector)
;;
          [0AD9] get_app_caption(who, stringnum, dest^, n)
0000:1BFE DD210200 ld ix,0002  
0000:1C02 DD39   add ix,sp  
;;
0000:1C04 DB06   in a,(06)   ; D=P6
0000:1C06 57     ld d,a      
0000:1C07 DB05   in a,(05)   ; E=P5
0000:1C09 5F     ld e,a      
0000:1C0A D5     push de     ; Save bank state
;;
0000:1C0B DD4E00 ld c,(ix+00); Read param
0000:1C0E DD4601 ld b,(ix+01)
0000:1C11 DDE5   push ix     ; Save param pointer
;;
0000:1C13 C5     push bc     ; Save param ;;push param as byte to scan for
0000:1C14 CDD60A call L = Scan_Magicsector(who)  
0000:1C17 C1     pop bc      ; Clean up stack
;;
0000:1C18 DDE1   pop ix      
0000:1C1A 3E03   ld a,03     ;; slot4000 = dataflash page L  (magicpage)
0000:1C1C D306   out (06),a  ; P6=3
0000:1C1E 7D     ld a,l      
0000:1C1F D305   out (05),a  ; P5=L
;;
0000:1C21 DD6E02 ld l,(ix+02); HL=param2   ;; string number???
0000:1C24 DD6603 ld h,(ix+03)
0000:1C27 110080 ld de,8000  ; Subtract 8000h from HL
0000:1C2A B7     or a        
0000:1C2B ED52   sbc hl,de  
0000:1C2D 29     add hl,hl   ; HL=HL*4+2
0000:1C2E 29     add hl,hl  
0000:1C2F 110200 ld de,0002  
0000:1C32 19     add hl,de  
0000:1C33 EB     ex de,hl    ; DE=HL       ;; de = 4 * (par2 - 8000) + 2   (point at a record)
;;
0000:1C34 2A0540 ld hl,(4005); HL=(4005)   ;; hl = dataflash(magicpage, bytes 0005 & 0006)  addr of first record???
0000:1C37 19     add hl,de   ; Add DE
0000:1C38 4E     ld c,(hl)   ; Read BC from (HL)   ;; BC, DE = record(par2)
0000:1C39 23     inc hl      
0000:1C3A 46     ld b,(hl)  
0000:1C3B 23     inc hl      
0000:1C3C 5E     ld e,(hl)   ; Read DE from (HL)
0000:1C3D 23     inc hl      
0000:1C3E 56     ld d,(hl)  
;;
0000:1C3F 2A0540 ld hl,(4005); Add to value at (4005)
0000:1C42 19     add hl,de  
0000:1C43 EB     ex de,hl    ; Swap HL, DE
;;
0000:1C44 DD6E06 ld l,(ix+06); Set param = new value ;;???  hl = par6
0000:1C47 DD6607 ld h,(ix+07)
0000:1C4A B7     or a        
0000:1C4B E5     push hl     ;; push par6
0000:1C4C ED42   sbc hl,bc   ; First param >= second? -> 1C53 ;;reeleeis, par6 - firstwordinrecord
0000:1C4E E1     pop hl      
0000:1C4F 2802   jr z,1C53   ;; jp if par6 = firstwordinrecord
0000:1C51 3003   jr nc,1C56  ; First param < second? -> 1C56  ;;reeleeis, jp if
;;
;; here if equal, or carried (par6 within limit)
0000:1C53 2B     dec hl      ; Back one byte?
0000:1C54 4D     ld c,l      
0000:1C55 44     ld b,h      ; Save as BC  ;; bc = par6 - 1
;;
;; here if no carry.  bc is either par6 - 1, or limit if par6 was too high
0000:1C56 DD6E04 ld l,(ix+04); HL=param  ;; par4 (dest)
0000:1C59 DD6605 ld h,(ix+05)
0000:1C5C C5     push bc     ; Save BC    ;; (n) (par6-1 or limit)
0000:1C5D D5     push de     ; Save DE    ;; (src)
0000:1C5E E5     push hl     ; Save HL    ;; (dest)
0000:1C5F CD9F05 call memcpy(dst,src,n)   ; memcpy(dest, src, numbytes)
0000:1C62 E1     pop hl      ; Clean up stack
0000:1C63 D1     pop de      
0000:1C64 C1     pop bc      
;;
0000:1C65 09     add hl,bc   ;; hl = dest + n   (1 past last)
0000:1C66 3E00   ld a,00    
0000:1C68 77     ld (hl),a   ; Write 0 to (HL+BC) ;; it's now a null term string!!!!!
;;
0000:1C69 D1     pop de      
0000:1C6A 7B     ld a,e      
0000:1C6B D305   out (05),a  ; Restore banks
0000:1C6D 7A     ld a,d      
0000:1C6E D306   out (06),a  
;;
0000:1C70 69     ld l,c      
0000:1C71 60     ld h,b      
0000:1C72 7C     ld a,h      
0000:1C73 B5     or l        ; Exit
0000:1C74 C9     ret        



; Delay(n)
          [0A5C] Delay(msec)
0000:1C75 210200 ld hl,0002  ;; seems to be roughly n millisec delay
0000:1C78 39     add hl,sp   ;; but maybe I counted wrong???  there is
0000:1C79 4E     ld c,(hl)   ;; enough res to get a lot closer, right?????
0000:1C7A 23     inc hl      
0000:1C7B 46     ld b,(hl)  
0000:1C7C 78     ld a,b      
0000:1C7D B1     or c        
0000:1C7E 2001   jr nz,1C81  ; Delay BC times
0000:1C80 C9     ret        

; Delay BC times
0000:1C81 CD8A1C call 1C8A   ;; 17 + 61 + 5239 = 5317 T states
0000:1C84 CD8A1C call 1C8A   ;; twice makes 10634 t's.
0000:1C87 0B     dec bc      ;; or @8MHz, 10634 * 0.125 usec = 1.33 msec
0000:1C88 18F2   jr 1C7C     ;; or @12MHz 10634 * 0.083 usec = 0.886 msec

; Delay body
0000:1C8A C5     push bc     ;; 11
0000:1C8B 0600   ld b,00     ;;  7
0000:1C8D 10FE   djnz 1C8D   ;; 13 * 256  + 8
0000:1C8F 0693   ld b,93     ;;  7
0000:1C91 10FE   djnz 1C91   ;; 13 * 147  + 8
0000:1C93 C1     pop bc      ;; 10
0000:1C94 C9     ret         ;; 10



;; I'm pretty sure this has something to do with real time clock.  But not
;; sure just what it is doing yet.
          [0A4A] tweak_rtc_ports???
0000:1C95 DB1D   in a,(1D)   ; Port 1D &= 0x09
0000:1C97 E609   and 09      
0000:1C99 D31D   out (1D),a  
0000:1C9B AF     xor a      
0000:1C9C D31E   out (1E),a  ; Port 1E = 0
0000:1C9E 3E0D   ld a,0D    
0000:1CA0 D31F   out (1F),a  ; Port 1F = #0D
0000:1CA2 3E0C   ld a,0C    
0000:1CA4 D31F   out (1F),a  ; Port 1F = #0C
0000:1CA6 C9     ret        



          [0A4D] enable_interrupt_3.5
0000:1CA7 0E05   ld c,05    
0000:1CA9 0601   ld b,01    
0000:1CAB CD2F0A call set_interrupt(int#=C, enable=B)   ; Translate bit position given in C (0-7) to bit mask and apply it to A
0000:1CAE C9     ret        

;; time16_counter.  called by isr 3.4  (16 bit counter, counts number of times interrupt 3.4 serviced.)
0000:1CAF 2A11E6 ld hl,(time16)
0000:1CB2 23     inc hl      
0000:1CB3 2211E6 ld (time16),hl
0000:1CB6 C9     ret        


; Keyscan  ;; called by isr 3.1 wrapper.  This IS isr 3.1
;; (could this be the event loop that watches for update commands???)
;; I think keyscan is just part of what this does.
;; It increments the software RTC, which I believe is in milliseconds, by 16.
;; So maybe int 3.1 is a 16ms heartbeat???
;;
;; Interesting little fact, 1/60 = .0166666,
;; so this would be real close to a 60Hz interrupt.
;;
;; time32 is a 32 bit timer, counting interupts x 16.
0000:1CB7 2A5ED4 ld hl,(time32); Long at D45E += #00000010
0000:1CBA 111000 ld de,0010  ;; time32 counts by 16 each int???
0000:1CBD 19     add hl,de  
0000:1CBE 225ED4 ld (time32),hl
0000:1CC1 2A60D4 ld hl,(D460);; carry into hi 16 bits
0000:1CC4 110000 ld de,0000  
0000:1CC7 ED5A   adc hl,de  
0000:1CC9 2260D4 ld (D460),hl
;;
0000:1CCC FB     ei          ; Enable ints
;;
;; there are ten more (16 bit) timers, every 6 bytes, starting ar D64E.
;; D46E, D474, D47A, D480, D486, D48C, D492, D498, D49E, D4A4.
;; They are part of a table
0000:1CCD 216ED4 ld hl,Timer.counter  ;; point at first timer
0000:1CD0 060A   ld b,0A     ;; loop 10x
;;
;; loop
0000:1CD2 5E     ld e,(hl)   ;; timer++
0000:1CD3 23     inc hl      
0000:1CD4 56     ld d,(hl)  
0000:1CD5 13     inc de      
0000:1CD6 72     ld (hl),d  
0000:1CD7 2B     dec hl      
0000:1CD8 73     ld (hl),e  
;;
0000:1CD9 110600 ld de,0006  
0000:1CDC 19     add hl,de   ;; move pointer ahead 6 bytes to the next timer.
0000:1CDD 10F3   djnz 1CD2   ; Loop 10x
;;
0000:1CDF CDE32F call 2FE3   ; Keyscan
0000:1CE2 C9     ret         ;; return



          [0A7F] LCD_on
0000:1CE3 3AA1DB ld a,(p2shadow) ; P2.7=1
0000:1CE6 F680   or 80      
0000:1CE8 32A1DB ld (p2shadow),a
0000:1CEB D302   out (02),a  
0000:1CED C9     ret        



          [0A82] LCD_off
0000:1CEE 3AA1DB ld a,(p2shadow) ; P2.7=0
0000:1CF1 E67F   and 7F      
0000:1CF3 32A1DB ld (p2shadow),a
0000:1CF6 D302   out (02),a  
0000:1CF8 C9     ret        



          drawicon2(unused, x0, y0, x1, y1, iconnum)
0000:1CF9 E1     pop hl      
0000:1CFA 2253D4 ld (x1),hl  ;; save ret address in x1 ???
;;
0000:1CFD C1     pop bc      
0000:1CFE CD071D call drawicon(x0, y0, x1, y1, iconnum)  
0000:1D01 E5     push hl    
;;
0000:1D02 2A53D4 ld hl,(x1)  ;; restore return address
0000:1D05 E5     push hl    
0000:1D06 C9     ret        


;; this is called by above and pg05
          drawicon(x0, y0, x1, y1, iconnum)
0000:1D07 DD210200 ld ix,0002  
0000:1D0B DD39   add ix,sp  
;;
0000:1D0D B7     or a        
0000:1D0E DD5E00 ld e,(ix+00); DE = value passed on stack ;; de = par0  (X0 pixel coord)
0000:1D11 DD5601 ld d,(ix+01)
0000:1D14 213F01 ld hl,013F  ;; 319 dec  (max col #)
0000:1D17 ED52   sbc hl,de  
0000:1D19 DA4E1E jp c,1E4E   ; DE > 013F? -> 1E4E ;; if X > 319, then return, were done.
0000:1D1C EB     ex de,hl    
0000:1D1D E5     push hl     ; Push DE's value  ;; x0
0000:1D1E 29     add hl,hl   ; Multiply by four
0000:1D1F 29     add hl,hl  
0000:1D20 11E32A ld de,bitcolumns  ; Point to table   ;;  maps bitcolumns to lcd buffer addresses
0000:1D23 19     add hl,de   ; Add offset
;;
0000:1D24 56     ld d,(hl)   ; Read table entry into DE  ;; de = offset of column in lcd buff
0000:1D25 23     inc hl      ;; Notice that the lower address byte is going into D, and the
0000:1D26 5E     ld e,(hl)   ;; higher byte is going into E, which is backwards from how you
0000:1D27 23     inc hl      ;; might expect.
0000:1D28 7E     ld a,(hl)   ; Read table byte into A ;; column bitmask
0000:1D29 325DD4 ld (cursorbit),a ; Save at D45D  ;; it's the bitmask this time, not bit pos
;;
0000:1D2C 2110C0 ld hl,lcdbuff  ;; start of LCD buffer
0000:1D2F 19     add hl,de   ;; hl = address of column x0 in lcd buff
0000:1D30 DD5E02 ld e,(ix+02);; E = par2  y0 coord)
0000:1D33 3E7F   ld a,7F    
0000:1D35 93     sub e      
0000:1D36 DA4E1E jp c,1E4E   ;; if Y0 > 127, then return, were done.
0000:1D39 1600   ld d,00    
0000:1D3B 19     add hl,de   ;; add y coord  (consecutive addrs are vertical!)
0000:1D3C 2246D4 ld (bytecursor),hl;; (#D446) is address of (x,y) in lcd buff
;;
0000:1D3F DD6E06 ld l,(ix+06);; y1
0000:1D42 2600   ld h,00    
0000:1D44 ED52   sbc hl,de   ;; y1 - y0
0000:1D46 7D     ld a,l      ;; delta y
;;
0000:1D47 D1     pop de      ;; de = x0
;;
0000:1D48 CA4E1E jp z,1E4E   ;; done if delta_y = 0
0000:1D4B 3256D4 ld (delta_y),a
0000:1D4E DD6E04 ld l,(ix+04)
0000:1D51 DD6605 ld h,(ix+05);; hl = par4  (x1)
0000:1D54 ED52   sbc hl,de   ;; x1 - x0
0000:1D56 CA4E1E jp z,1E4E   ;; delta x = 0? then done
0000:1D59 2257D4 ld (delta_x),hl
;;
0000:1D5C DD4608 ld b,(ix+08);; B = par8    (icon num)
0000:1D5F CD0A28 call dispatchme(B,C)   ;; dispatchme    is this a font lookup?????  (i thin its icon lookup)
;;
;; single char buff is at #D410,
;; icon format in buffer is DIFFERENT than font characters !!!!!!!
0000:1D62 DD2110D4 ld ix,fontbuff.charwidth  
0000:1D66 DD6E00 ld l,(ix+00);;
0000:1D69 DD6601 ld h,(ix+01);; hl = icon width
0000:1D6C 114001 ld de,0140  ;; 320 dec
0000:1D6F EB     ex de,hl    ;; hl is 320 , de is width
0000:1D70 B7     or a        
0000:1D71 ED52   sbc hl,de   ;; 320 - width
0000:1D73 DA381E jp c,1E38   ;; if width > 320, then cleanupgohome
;;
0000:1D76 7A     ld a,d      
0000:1D77 B3     or e        
0000:1D78 CA381E jp z,1E38   ;; if width = 0 , then cleanupgohome
;;
0000:1D7B DD7E02 ld a,(ix+02);; A = icon height
0000:1D7E FE00   cp 00      
0000:1D80 CA381E jp z,1E38   ;; if height = 0, then cleanupgohome
;;
0000:1D83 6F     ld l,a      
0000:1D84 3E80   ld a,80    
0000:1D86 95     sub l       ;; #80 - height
0000:1D87 DA381E jp c,1E38   ;; if height >= 128, then cleanupgohome
;;
0000:1D8A DD6E00 ld l,(ix+00);; hl = width
0000:1D8D DD6601 ld h,(ix+01)
0000:1D90 E5     push hl     ;; push width
0000:1D91 ED5B57D4 ld de,(delta_x);; de = delta x
0000:1D95 B7     or a        
0000:1D96 ED52   sbc hl,de   ;; width - delta_x
0000:1D98 DA9F1D jp c,1D9F   ;; jp if delta_x greater
;;
0000:1D9B E1     pop hl      ;; icon width > window, hl is width, not used.
0000:1D9C C3A01D jp 1DA0     ;; de is delta_x  (width of window)
;;
0000:1D9F D1     pop de      ;; window was greater, de is icon width
;;
0000:1DA0 ED535AD4 ld (clippedwidth),de
0000:1DA4 ED5357D4 ld (delta_x),de
;;
0000:1DA8 DD5602 ld d,(ix+02);; icon height, looks like do same as with width
0000:1DAB 3A56D4 ld a,(delta_y)
0000:1DAE BA     cp d        ;; delta_y - iconwidth
0000:1DAF DAB31D jp c,1DB3   ;; if window too small, use delta_y
0000:1DB2 7A     ld a,d      ;; else window is big enough, use icon width
;;
0000:1DB3 325CD4 ld (clippedheight),a
0000:1DB6 3256D4 ld (delta_y),a
;;
0000:1DB9 CD6029 call read_dispatch   ;; copy 1 row of icon pix to fontbuffer.
;;
0000:1DBC 3A5DD4 ld a,(cursorbit) ;; check if icon dest is on byte boundary
0000:1DBF 57     ld d,a      
0000:1DC0 FE01   cp 01      
0000:1DC2 CAE61D jp z,1DE6   ;; jp if alligned, do faster copy
;;
;; render non-byte_alligned icon
0000:1DC5 2A46D4 ld hl,(bytecursor)
0000:1DC8 3A5CD4 ld a,(clippedheight)
0000:1DCB 5F     ld e,a      
0000:1DCC ED4B5AD4 ld bc,(clippedwidth)
;;
;; rowloop   for e = clipped height downto 0     (do each pix row of icon)
0000:1DD0 FD2110D4 ld iy,fontbuff.charwidth  ;; point at font buffer
0000:1DD4 E5     push hl    
0000:1DD5 D5     push de    
0000:1DD6 C5     push bc     ;; num of bits
0000:1DD7 CD4F1E call 1E4F   ;; render 1 row of icon into LCD buffer
;;
0000:1DDA CD6029 call read_dispatch   ;; copy next row of icon pix to fontbuffer.
0000:1DDD C1     pop bc      
0000:1DDE D1     pop de      
0000:1DDF E1     pop hl      
0000:1DE0 23     inc hl      ;; advance bytecursor 1 pix down
0000:1DE1 1D     dec e       ;; e--
0000:1DE2 C2D01D jp nz,1DD0  ;; rowloop
;;
0000:1DE5 C9     ret        
;;
;;
;; fastrowloop
0000:1DE6 3A5CD4 ld a,(clippedheight)
0000:1DE9 FE00   cp 00      
0000:1DEB CA381E jp z,1E38   ;; if clipped to 0, were done, cleanupgohome
;;
0000:1DEE 3D     dec a       ;; numrows--
0000:1DEF 325CD4 ld (clippedheight),a
;;
0000:1DF2 FD2110D4 ld iy,fontbuff.charwidth  
0000:1DF6 DD2A46D4 ld ix,(bytecursor)
0000:1DFA 2A5AD4 ld hl,(clippedwidth)
;;
;; byteloop
0000:1DFD 4D     ld c,l      ;; whole byte of this row left?
0000:1DFE 110800 ld de,0008  
0000:1E01 ED52   sbc hl,de  
0000:1E03 DA161E jp c,1E16   ;; jp if less than 8 bits left
;;
0000:1E06 FD7E00 ld a,(iy+00);; copy a byte to lcdbuff
0000:1E09 DD7700 ld (ix+00),a
0000:1E0C FD23   inc iy      
0000:1E0E 118000 ld de,0080  
0000:1E11 DD19   add ix,de  
0000:1E13 C3FD1D jp 1DFD     ;; jp byteloop
;;
;; less than 8 bits left
0000:1E16 0600   ld b,00     ;; bc is 0..7 here
0000:1E18 214125 ld hl,bitmasks  
0000:1E1B 09     add hl,bc   ;; bitmask[bc]
0000:1E1C 7E     ld a,(hl)  
0000:1E1D 5F     ld e,a      ;; e = bitmask
;;
0000:1E1E FDA600 and (iy+00) ;; render last 0 to 7 pixels of row (wouldn't 1 to 8 make more sense???)
0000:1E21 57     ld d,a      
0000:1E22 7B     ld a,e      
0000:1E23 2F     cpl        
0000:1E24 DDA600 and (ix+00)
0000:1E27 B2     or d        
0000:1E28 DD7700 ld (ix+00),a
;;
0000:1E2B 2A46D4 ld hl,(bytecursor)
0000:1E2E 23     inc hl      
0000:1E2F 2246D4 ld (bytecursor),hl
0000:1E32 CD6029 call read_dispatch   ;; copy a block from page found by dispatchme
0000:1E35 C3E61D jp 1DE6     ;; fastrowloop
;;
;; cleanupgohome
0000:1E38 3A4FD4 ld a,(lcd_bytecol) ;; sumthin  (whether to restore rampage)
0000:1E3B FE01   cp 01      
0000:1E3D 280F   jr z,1E4E   ;; return
0000:1E3F FE08   cp 08      
0000:1E41 280B   jr z,1E4E   ;; return
;;
0000:1E43 3A50D4 ld a,(x0)   ;; page#
0000:1E46 6F     ld l,a      
0000:1E47 2600   ld h,00    
0000:1E49 E5     push hl    
0000:1E4A CDF005 call Rampage!(new)   ;; Rampage(page#)  sets slot8000device = ram, page = page#
0000:1E4D E1     pop hl      
0000:1E4E C9     ret        


;; called by above
;; byteloop
0000:1E4F 1E08   ld e,08     ;; bitcount.  do all 8 bits of (IY)
;;
;; bitloop
0000:1E51 FDCB000E rrc (iy+00) rotate a pixel into carry flag
0000:1E55 7A     ld a,d      ;; pen???
0000:1E56 3804   jr c,1E5C   ;; is pixel gonna be on or off?
;;
;; off
0000:1E58 2F     cpl        
0000:1E59 A6     and (hl)    
0000:1E5A 1801   jr 1E5D    
;;
;; on
0000:1E5C B6     or (hl)    
0000:1E5D 77     ld (hl),a   ;; put mod byte back where it came from
;;
0000:1E5E CB02   rlc d       ;; move pen 1 bit
0000:1E60 3008   jr nc,1E6A  ;; skip ahead if pen still in same byte
;;
;; advance byte pointer when pen wraps around
0000:1E62 3E80   ld a,80     ;; hl = hl + 128 dec  (next col of lcd buff?????)
0000:1E64 85     add a,l    
0000:1E65 6F     ld l,a      
0000:1E66 3E00   ld a,00    
0000:1E68 8C     adc a,h    
0000:1E69 67     ld h,a      
;;
;; here if same byte, or after advance.
0000:1E6A 0B     dec bc      
0000:1E6B 78     ld a,b      
0000:1E6C B1     or c        
0000:1E6D CA791E jp z,1E79   ;; if BC = 0, ret
;;
0000:1E70 1D     dec e       ;; bitcount--
0000:1E71 C2511E jp nz,1E51  ;; bitloop
;;
0000:1E74 FD23   inc iy      ;; next byte of source
0000:1E76 C34F1E jp 1E4F     ;; jp byteloop
;;
0000:1E79 C9     ret        



;; This draws the string within screen coords found in box, starting at
;; upper left corner of the box.
;; It clips the bottom pixels if char height is too high for box.  
;; Also clips end of string to fit box.
;;
;; The box record has abs screen coords x0, y0, x1, y1, and the font
;;
          drawstring_screenbox(box&font^, string^, n)
0000:1E7A FD210200 ld iy,0002  
0000:1E7E FD39   add iy,sp  
0000:1E80 FD6E00 ld l,(iy+00);; par0
0000:1E83 FD6601 ld h,(iy+01)
0000:1E86 E5     push hl    
0000:1E87 DDE1   pop ix      ;; ix points at box record now
;;
0000:1E89 AF     xor a      
0000:1E8A 324FD4 ld (lcd_bytecol),a ;; lcd_bytecol = #00
;;
0000:1E8D DD6E00 ld l,(ix+00);; box.x0
0000:1E90 DD6601 ld h,(ix+01)
0000:1E93 54     ld d,h      
0000:1E94 5D     ld e,l      ;; save box.x0 for later...
;;
0000:1E95 29     add hl,hl  
0000:1E96 29     add hl,hl  
0000:1E97 01E32A ld bc,bitcolumns  ;; table,  maps bitcolumns to lcd buffer addresses
0000:1E9A 09     add hl,bc  
0000:1E9B 46     ld b,(hl)   ;; byte order reversed, fixin' it here.
0000:1E9C 23     inc hl      
0000:1E9D 4E     ld c,(hl)   ;; bc has bit column offset.
0000:1E9E 23     inc hl      
0000:1E9F 7E     ld a,(hl)  
0000:1EA0 325DD4 ld (cursorbit),a ;; bitmask
0000:1EA3 2110C0 ld hl,lcdbuff  
0000:1EA6 09     add hl,bc   ;; hl points at col in lcd buff
0000:1EA7 DD4E02 ld c,(ix+02)
0000:1EAA 0600   ld b,00     ;; bc = box.y0
0000:1EAC 09     add hl,bc   ;; hl points at row,col in lcd buff
0000:1EAD 2246D4 ld (bytecursor),hl
;;
0000:1EB0 DD6E06 ld l,(ix+06);; box.y1
0000:1EB3 2600   ld h,00    
0000:1EB5 ED42   sbc hl,bc   ;; box.y1 - box.y0
0000:1EB7 45     ld b,l      ;; b = box height
;;
0000:1EB8 DD4E08 ld c,(ix+08);; c = box.font
;;
0000:1EBB 78     ld a,b      ;; box height
0000:1EBC 3256D4 ld (delta_y),a
;;
0000:1EBF DD6E04 ld l,(ix+04);; box.x1
0000:1EC2 DD6605 ld h,(ix+05)
0000:1EC5 ED52   sbc hl,de   ;; box.x1 - box.x0
0000:1EC7 2257D4 ld (delta_x),hl ;; save box width in delta_x
;;
;; render the char, so we can get height & width
0000:1ECA FDE5   push iy     ;; *
0000:1ECC C5     push bc     ;; **   box height
0000:1ECD FD6E02 ld l,(iy+02);; hl = stringptr
0000:1ED0 FD6603 ld h,(iy+03)
0000:1ED3 46     ld b,(hl)   ;; b = next char
0000:1ED4 CD6127 call render_char(B=char, C=font)  
0000:1ED7 C1     pop bc      ;; **
0000:1ED8 FDE1   pop iy      ;; *
;;
;; This is where we clip to the bootom of box
0000:1EDA 2110D4 ld hl,fontbuff.charwidth  
0000:1EDD 23     inc hl      ;; hl = @fontbuff.charheight
0000:1EDE 7E     ld a,(hl)   ;; a = charheight
0000:1EDF B8     cp b        ;; charheight - boxheight
0000:1EE0 DAE41E jp c,1EE4   ;; jp if charheight smaller
;;
0000:1EE3 78     ld a,b      ;; or use boxheight if it was smaller (or equal)
;;
;; save smaller of the two, and if it is 0, just return
0000:1EE4 325CD4 ld (clippedheight),a
0000:1EE7 FE00   cp 00      
0000:1EE9 CA6D1F jp z,1F6D   ;; ret if 0
;;
;; point hl at string, load b with n, and if n=0, then just return.
0000:1EEC FD6E02 ld l,(iy+02);; hl = stringptr
0000:1EEF FD6603 ld h,(iy+03)
0000:1EF2 FD4604 ld b,(iy+04);; n
0000:1EF5 78     ld a,b      
0000:1EF6 FE00   cp 00      
0000:1EF8 CA6D1F jp z,1F6D   ;; ret if n=0
;;
;; loop  (for each char in string)
0000:1EFB C5     push bc     ;; #   (n is num chars in string)
0000:1EFC E5     push hl     ;; ##  (stringptr)
0000:1EFD 46     ld b,(hl)   ;; b = next char from string
0000:1EFE CD6127 call render_char(B=char, C=font)   ;; render_char(B=char, C=font)
0000:1F01 2110D4 ld hl,fontbuff.charwidth  ;; buff (pix_wide, pix_high, bytes_wide, pix_data...)
0000:1F04 4E     ld c,(hl)  
0000:1F05 AF     xor a      
0000:1F06 47     ld b,a      ;; bc = pixels_wide
0000:1F07 23     inc hl      
0000:1F08 23     inc hl      
0000:1F09 7E     ld a,(hl)  
0000:1F0A 324ED4 ld (lcdhalf),a ;; bytes_wide (reuse a temp var)
;;
;; Now we will clip to right edge of box
0000:1F0D AF     xor a      
0000:1F0E 2A57D4 ld hl,(delta_x);; pixels till end of box
0000:1F11 ED42   sbc hl,bc   ;; boxwidth - char_pixels_wide
0000:1F13 D21D1F jp nc,1F1D  ;; jp if boxwidth >= char_pixel_wide
;;
0000:1F16 ED4B57D4 ld bc,(delta_x);; else use all thats left as "pixels_wide"
0000:1F1A 210000 ld hl,0000  
;;
0000:1F1D 2257D4 ld (delta_x),hl;; decrease "pixels till end"
0000:1F20 B1     or c        
0000:1F21 CA6B1F jp z,1F6B   ;; if pixels_wide = 0, then jp done_early
;;
0000:1F24 79     ld a,c      
0000:1F25 3252D4 ld (y0),a   ;; y0
0000:1F28 FD2113D4 ld iy,fontbuff.charbitmap  
0000:1F2C 2A46D4 ld hl,(bytecursor)
0000:1F2F 3A5CD4 ld a,(clippedheight)
0000:1F32 47     ld b,a      
;;
0000:1F33 E5     push hl     ;; ##$
0000:1F34 FDE5   push iy     ;; ##$$
0000:1F36 3A52D4 ld a,(y0)   ;; y0
0000:1F39 4F     ld c,a      
0000:1F3A 3A5DD4 ld a,(cursorbit)
0000:1F3D 57     ld d,a      
0000:1F3E CD6E1F call 1F6E  
0000:1F41 05     dec b      
0000:1F42 CA521F jp z,1F52  
0000:1F45 FDE1   pop iy      ;; ##$$
0000:1F47 ED5B4ED4 ld de,(lcdhalf)
0000:1F4B FD19   add iy,de  
0000:1F4D E1     pop hl      ;; ##$
0000:1F4E 23     inc hl      
0000:1F4F C3331F jp 1F33    
;;
0000:1F52 FDE1   pop iy      ;; ##$$
0000:1F54 7A     ld a,d      
0000:1F55 325DD4 ld (cursorbit),a
0000:1F58 3A5CD4 ld a,(clippedheight)
0000:1F5B 5F     ld e,a      
0000:1F5C AF     xor a      
0000:1F5D 57     ld d,a      
0000:1F5E 23     inc hl      
0000:1F5F ED52   sbc hl,de  
0000:1F61 2246D4 ld (bytecursor),hl
0000:1F64 E1     pop hl      ;; ##$
;;
0000:1F65 E1     pop hl      ;; ##   (stringptr)
0000:1F66 C1     pop bc      ;; #    (n)
0000:1F67 23     inc hl      ;; point at next char in string
0000:1F68 1091   djnz 1EFB   ;; loop for each char in string
;;
;; done
0000:1F6A C9     ret        
;;
;; done early
0000:1F6B E1     pop hl      
0000:1F6C C1     pop bc      
0000:1F6D C9     ret        




;; called by above, and looped to from below.
0000:1F6E FD5E00 ld e,(iy+00)
0000:1F71 CB0B   rrc e      
0000:1F73 7A     ld a,d      
0000:1F74 3804   jr c,1F7A  
0000:1F76 2F     cpl        
0000:1F77 A6     and (hl)    
0000:1F78 1801   jr 1F7B    
0000:1F7A B6     or (hl)    
0000:1F7B 77     ld (hl),a  
0000:1F7C CB02   rlc d      
0000:1F7E 3008   jr nc,1F88  
0000:1F80 3E80   ld a,80    
0000:1F82 85     add a,l    
0000:1F83 6F     ld l,a      
0000:1F84 3E00   ld a,00    
0000:1F86 8C     adc a,h    
0000:1F87 67     ld h,a      
0000:1F88 0D     dec c      
0000:1F89 CA4D20 jp z,204D  
0000:1F8C CB0B   rrc e      
0000:1F8E 7A     ld a,d      
0000:1F8F 3804   jr c,1F95  
0000:1F91 2F     cpl        
0000:1F92 A6     and (hl)    
0000:1F93 1801   jr 1F96    
0000:1F95 B6     or (hl)    
0000:1F96 77     ld (hl),a  
0000:1F97 CB02   rlc d      
0000:1F99 3008   jr nc,1FA3  
0000:1F9B 3E80   ld a,80    
0000:1F9D 85     add a,l    
0000:1F9E 6F     ld l,a      
0000:1F9F 3E00   ld a,00    
0000:1FA1 8C     adc a,h    
0000:1FA2 67     ld h,a      
0000:1FA3 0D     dec c      
0000:1FA4 CA4D20 jp z,204D  
0000:1FA7 CB0B   rrc e      
0000:1FA9 7A     ld a,d      
0000:1FAA 3804   jr c,1FB0  
0000:1FAC 2F     cpl        
0000:1FAD A6     and (hl)    
0000:1FAE 1801   jr 1FB1    
0000:1FB0 B6     or (hl)    
0000:1FB1 77     ld (hl),a  
0000:1FB2 CB02   rlc d      
0000:1FB4 3008   jr nc,1FBE  
0000:1FB6 3E80   ld a,80    
0000:1FB8 85     add a,l    
0000:1FB9 6F     ld l,a      
0000:1FBA 3E00   ld a,00    
0000:1FBC 8C     adc a,h    
0000:1FBD 67     ld h,a      
0000:1FBE 0D     dec c      
0000:1FBF CA4D20 jp z,204D  
0000:1FC2 CB0B   rrc e      
0000:1FC4 7A     ld a,d      
0000:1FC5 3804   jr c,1FCB  
0000:1FC7 2F     cpl        
0000:1FC8 A6     and (hl)    
0000:1FC9 1801   jr 1FCC    
0000:1FCB B6     or (hl)    
0000:1FCC 77     ld (hl),a  
0000:1FCD CB02   rlc d      
0000:1FCF 3008   jr nc,1FD9  
0000:1FD1 3E80   ld a,80    
0000:1FD3 85     add a,l    
0000:1FD4 6F     ld l,a      
0000:1FD5 3E00   ld a,00    
0000:1FD7 8C     adc a,h    
0000:1FD8 67     ld h,a      
0000:1FD9 0D     dec c      
0000:1FDA CA4D20 jp z,204D  
0000:1FDD CB0B   rrc e      
0000:1FDF 7A     ld a,d      
0000:1FE0 3804   jr c,1FE6  
0000:1FE2 2F     cpl        
0000:1FE3 A6     and (hl)    
0000:1FE4 1801   jr 1FE7    

0000:1FE6 B6     or (hl)    
0000:1FE7 77     ld (hl),a  
0000:1FE8 CB02   rlc d      
0000:1FEA 3008   jr nc,1FF4  
0000:1FEC 3E80   ld a,80    
0000:1FEE 85     add a,l    
0000:1FEF 6F     ld l,a      
0000:1FF0 3E00   ld a,00    
0000:1FF2 8C     adc a,h    
0000:1FF3 67     ld h,a      
0000:1FF4 0D     dec c      
0000:1FF5 CA4D20 jp z,204D  
0000:1FF8 CB0B   rrc e      
0000:1FFA 7A     ld a,d      
0000:1FFB 3804   jr c,2001  
0000:1FFD 2F     cpl        
0000:1FFE A6     and (hl)    
0000:1FFF 1801   jr 2002    
0000:2001 B6     or (hl)    
0000:2002 77     ld (hl),a  
0000:2003 CB02   rlc d      
0000:2005 3008   jr nc,200F  
0000:2007 3E80   ld a,80    
0000:2009 85     add a,l    
0000:200A 6F     ld l,a      
0000:200B 3E00   ld a,00    
0000:200D 8C     adc a,h    
0000:200E 67     ld h,a      
0000:200F 0D     dec c      
0000:2010 CA4D20 jp z,204D  
0000:2013 CB0B   rrc e      
0000:2015 7A     ld a,d      
0000:2016 3804   jr c,201C  
0000:2018 2F     cpl        
0000:2019 A6     and (hl)    
0000:201A 1801   jr 201D    
0000:201C B6     or (hl)    
0000:201D 77     ld (hl),a  
0000:201E CB02   rlc d      
0000:2020 3008   jr nc,202A  
0000:2022 3E80   ld a,80    
0000:2024 85     add a,l    
0000:2025 6F     ld l,a      
0000:2026 3E00   ld a,00    
0000:2028 8C     adc a,h    
0000:2029 67     ld h,a      
0000:202A 0D     dec c      
0000:202B CA4D20 jp z,204D  
0000:202E CB0B   rrc e      
0000:2030 7A     ld a,d      
0000:2031 3804   jr c,2037  
0000:2033 2F     cpl        
0000:2034 A6     and (hl)    
0000:2035 1801   jr 2038    
0000:2037 B6     or (hl)    
0000:2038 77     ld (hl),a  
0000:2039 CB02   rlc d      
0000:203B 3008   jr nc,2045  
0000:203D 3E80   ld a,80    
0000:203F 85     add a,l    
0000:2040 6F     ld l,a      
0000:2041 3E00   ld a,00    
0000:2043 8C     adc a,h    
0000:2044 67     ld h,a      
0000:2045 0D     dec c      
0000:2046 2805   jr z,204D  
0000:2048 FD23   inc iy      
0000:204A C36E1F jp 1F6E    
0000:204D C9     ret        



;; called from 3 places below here
          gotoxy????(ix=boxptr)
0000:204E B7     or a        
0000:204F DD6E00 ld l,(ix+00);; x coord
0000:2052 DD6601 ld h,(ix+01)
0000:2055 E5     push hl     ;; save x coord
0000:2056 29     add hl,hl  
0000:2057 29     add hl,hl   ;;4 * x  (4 bytes per row)
0000:2058 11E32A ld de,bitcolumns  ;; table,  maps bitcolumns to lcd buffer
0000:205B 19     add hl,de  
0000:205C 56     ld d,(hl)  
0000:205D 23     inc hl      
0000:205E 5E     ld e,(hl)   ;; de is lcd buff offset
0000:205F 23     inc hl      
0000:2060 23     inc hl      
0000:2061 7E     ld a,(hl)   ;; a is bitshift
0000:2062 325DD4 ld (cursorbit),a
0000:2065 2110C0 ld hl,lcdbuff  ;; start of lcd buffer
0000:2068 19     add hl,de   ;; hl points at top of column in lcd buff
0000:2069 DD5E02 ld e,(ix+02);; y coord
0000:206C 1600   ld d,00    
0000:206E 19     add hl,de   ;; hl points at x,y in lcd buff
0000:206F 2246D4 ld (bytecursor),hl
0000:2072 DD6E06 ld l,(ix+06)
0000:2075 2600   ld h,00    
0000:2077 ED52   sbc hl,de  
0000:2079 7D     ld a,l      
0000:207A 3256D4 ld (delta_y),a
0000:207D D1     pop de      ;; get x coord
0000:207E DD6E04 ld l,(ix+04)
0000:2081 DD6605 ld h,(ix+05)
0000:2084 ED52   sbc hl,de  
0000:2086 2257D4 ld (delta_x),hl
0000:2089 C9     ret        



;; called from lots of places, mostly in test mode???
          erasebox(x0, y0, x1, y1)
0000:208A DD210200 ld ix,0002  
0000:208E DD39   add ix,sp  
;;
0000:2090 CD4E20 call gotoxy????(ix=boxptr)  
0000:2093 3A56D4 ld a,(delta_y)
0000:2096 FE00   cp 00      
0000:2098 CA3B21 jp z,213B   ;; ret if delta y = 0
;;
0000:209B 3A5DD4 ld a,(cursorbit)
0000:209E FE00   cp 00      
0000:20A0 CAD620 jp z,20D6  
;;
0000:20A3 B7     or a        
0000:20A4 5F     ld e,a      
0000:20A5 1600   ld d,00    
0000:20A7 2A57D4 ld hl,(delta_x)
0000:20AA 19     add hl,de   ;; hl = delta_x + cursorbit
0000:20AB 110800 ld de,0008  
0000:20AE ED52   sbc hl,de   ;; hl = cursorbit + delta_x - 8
0000:20B0 DA1521 jp c,2115   ;; jp if < 8
;;
0000:20B3 2257D4 ld (delta_x),hl
;;
0000:20B6 214125 ld hl,bitmasks  
0000:20B9 5F     ld e,a      
0000:20BA 1600   ld d,00    
0000:20BC 19     add hl,de  
0000:20BD 7E     ld a,(hl)  
0000:20BE 4F     ld c,a      
;;
0000:20BF 3A56D4 ld a,(delta_y)
0000:20C2 47     ld b,a      ;; b = delta y
;;
0000:20C3 2A46D4 ld hl,(bytecursor)
;;
;; loop0       (do leading partial col)
0000:20C6 79     ld a,c      
0000:20C7 A6     and (hl)    
0000:20C8 77     ld (hl),a  
0000:20C9 23     inc hl      
0000:20CA 10FA   djnz 20C6  
;;
;; next col
0000:20CC 118000 ld de,0080  
0000:20CF 2A46D4 ld hl,(bytecursor)
0000:20D2 19     add hl,de  
0000:20D3 2246D4 ld (bytecursor),hl
;;
;; cursorbit was 0  (start with whole col)
0000:20D6 2A57D4 ld hl,(delta_x)
0000:20D9 110800 ld de,0008  
0000:20DC ED52   sbc hl,de  
0000:20DE DAF420 jp c,20F4  
0000:20E1 2257D4 ld (delta_x),hl
0000:20E4 3A56D4 ld a,(delta_y)
0000:20E7 47     ld b,a      
0000:20E8 2A46D4 ld hl,(bytecursor)
0000:20EB 3E00   ld a,00    
0000:20ED 77     ld (hl),a  
0000:20EE 23     inc hl      
0000:20EF 10FA   djnz 20EB  
0000:20F1 C3CC20 jp 20CC    
0000:20F4 B7     or a        
0000:20F5 ED5B57D4 ld de,(delta_x)
0000:20F9 7B     ld a,e      
0000:20FA B2     or d        
0000:20FB CA3B21 jp z,213B  
0000:20FE 214125 ld hl,bitmasks  
0000:2101 19     add hl,de  
0000:2102 7E     ld a,(hl)  
0000:2103 4F     ld c,a      
0000:2104 3A56D4 ld a,(delta_y)
0000:2107 47     ld b,a      
0000:2108 2A46D4 ld hl,(bytecursor)
;;
;; loop      (do trailing partial col???)
0000:210B 79     ld a,c      
0000:210C 2F     cpl        
0000:210D A6     and (hl)    
0000:210E 77     ld (hl),a  
0000:210F 23     inc hl      
0000:2110 10F9   djnz 210B   ;; loop
0000:2112 C33B21 jp 213B     ;; ret
;;
;; here when single byte col wide, with partial on lead and trail edges.
0000:2115 214125 ld hl,bitmasks  
;;
0000:2118 3A5DD4 ld a,(cursorbit)
0000:211B 5F     ld e,a      
0000:211C 1600   ld d,00    
0000:211E 19     add hl,de  
;;
0000:211F 7E     ld a,(hl)  
0000:2120 4F     ld c,a      
;;
0000:2121 2A57D4 ld hl,(delta_x)
0000:2124 19     add hl,de  
0000:2125 EB     ex de,hl    
0000:2126 214125 ld hl,bitmasks  
0000:2129 19     add hl,de  
0000:212A 7E     ld a,(hl)  
0000:212B 2F     cpl        
0000:212C B1     or c        
0000:212D 4F     ld c,a      
;;
0000:212E 3A56D4 ld a,(delta_y)
0000:2131 47     ld b,a      
0000:2132 2A46D4 ld hl,(bytecursor)
;;
;; loop2
0000:2135 79     ld a,c      
0000:2136 A6     and (hl)    
0000:2137 77     ld (hl),a  
0000:2138 23     inc hl      
0000:2139 10FA   djnz 2135   ;; loop2
0000:213B C9     ret        



          fillbox(x0, y0, x1, y1)
0000:213C DD210200 ld ix,0002  
0000:2140 DD39   add ix,sp  
0000:2142 CD4E20 call gotoxy????(ix=boxptr)  
0000:2145 3A56D4 ld a,(delta_y)
0000:2148 FE00   cp 00      
0000:214A CAED21 jp z,21ED   ;; ret
;;
0000:214D 3A5DD4 ld a,(cursorbit)
0000:2150 FE00   cp 00      
0000:2152 CA8921 jp z,2189   ;; start with whole col
;;
0000:2155 B7     or a        
0000:2156 5F     ld e,a      
0000:2157 1600   ld d,00    
0000:2159 2A57D4 ld hl,(delta_x)
0000:215C 19     add hl,de  
0000:215D 110800 ld de,0008  
0000:2160 ED52   sbc hl,de  
0000:2162 DAC721 jp c,21C7  
;;
0000:2165 2257D4 ld (delta_x),hl
0000:2168 214125 ld hl,bitmasks  
0000:216B 5F     ld e,a      
0000:216C 1600   ld d,00    
0000:216E 19     add hl,de  
0000:216F 7E     ld a,(hl)  
0000:2170 2F     cpl        
0000:2171 4F     ld c,a      
0000:2172 3A56D4 ld a,(delta_y)
0000:2175 47     ld b,a      
0000:2176 2A46D4 ld hl,(bytecursor)
0000:2179 79     ld a,c      
0000:217A B6     or (hl)    
0000:217B 77     ld (hl),a  
0000:217C 23     inc hl      
0000:217D 10FA   djnz 2179  
0000:217F 118000 ld de,0080  
0000:2182 2A46D4 ld hl,(bytecursor)
0000:2185 19     add hl,de  
0000:2186 2246D4 ld (bytecursor),hl
;;
;; whole col
0000:2189 2A57D4 ld hl,(delta_x)
0000:218C 110800 ld de,0008  
0000:218F ED52   sbc hl,de  
0000:2191 DAA721 jp c,21A7  
0000:2194 2257D4 ld (delta_x),hl
0000:2197 3A56D4 ld a,(delta_y)
0000:219A 47     ld b,a      
0000:219B 2A46D4 ld hl,(bytecursor)
0000:219E 3EFF   ld a,FF    
0000:21A0 77     ld (hl),a  
0000:21A1 23     inc hl      
0000:21A2 10FA   djnz 219E  
0000:21A4 C37F21 jp 217F    
0000:21A7 B7     or a        
0000:21A8 ED5B57D4 ld de,(delta_x)
0000:21AC 7B     ld a,e      
0000:21AD B2     or d        
0000:21AE CAED21 jp z,21ED  
0000:21B1 214125 ld hl,bitmasks  
0000:21B4 19     add hl,de  
0000:21B5 7E     ld a,(hl)  
0000:21B6 4F     ld c,a      
0000:21B7 3A56D4 ld a,(delta_y)
0000:21BA 47     ld b,a      
0000:21BB 2A46D4 ld hl,(bytecursor)
0000:21BE 79     ld a,c      
0000:21BF B6     or (hl)    
0000:21C0 77     ld (hl),a  
0000:21C1 23     inc hl      
0000:21C2 10FA   djnz 21BE  
0000:21C4 C3ED21 jp 21ED     ;; ret
;;
;;
0000:21C7 214125 ld hl,bitmasks  
0000:21CA 3A5DD4 ld a,(cursorbit)
0000:21CD 5F     ld e,a      
0000:21CE 1600   ld d,00    
0000:21D0 19     add hl,de  
0000:21D1 7E     ld a,(hl)  
0000:21D2 2F     cpl         ;; 00001111
0000:21D3 4F     ld c,a      
0000:21D4 2A57D4 ld hl,(delta_x)
0000:21D7 19     add hl,de  
0000:21D8 EB     ex de,hl    
0000:21D9 214125 ld hl,bitmasks  
0000:21DC 19     add hl,de  
0000:21DD 7E     ld a,(hl)   ;; 11111110
0000:21DE A1     and c      
0000:21DF 4F     ld c,a      ;; 00001110
;;
0000:21E0 3A56D4 ld a,(delta_y)
0000:21E3 47     ld b,a      
0000:21E4 2A46D4 ld hl,(bytecursor)
;;
0000:21E7 79     ld a,c      ;; 00001110
0000:21E8 B6     or (hl)    
0000:21E9 77     ld (hl),a  
0000:21EA 23     inc hl      
0000:21EB 10FA   djnz 21E7  
;;
0000:21ED C9     ret        


          invert_screen(x0, y0, x1, y1)
0000:21EE DD210200 ld ix,0002  
0000:21F2 DD39   add ix,sp  
0000:21F4 CD4E20 call gotoxy????(ix=boxptr)  
0000:21F7 3A56D4 ld a,(delta_y)
0000:21FA FE00   cp 00      
0000:21FC CAA022 jp z,22A0   ;; ret if 0
0000:21FF 3A5DD4 ld a,(cursorbit)
0000:2202 FE00   cp 00      
0000:2204 CA3B22 jp z,223B  
0000:2207 B7     or a        
0000:2208 5F     ld e,a      
0000:2209 1600   ld d,00    
0000:220B 2A57D4 ld hl,(delta_x)
0000:220E 19     add hl,de  
0000:220F 110800 ld de,0008  
0000:2212 ED52   sbc hl,de  
0000:2214 DA7A22 jp c,227A  
0000:2217 2257D4 ld (delta_x),hl
0000:221A 214125 ld hl,bitmasks  
0000:221D 5F     ld e,a      
0000:221E 1600   ld d,00    
0000:2220 19     add hl,de  
0000:2221 7E     ld a,(hl)  
0000:2222 2F     cpl        
0000:2223 4F     ld c,a      
0000:2224 3A56D4 ld a,(delta_y)
0000:2227 47     ld b,a      
0000:2228 2A46D4 ld hl,(bytecursor)
0000:222B 79     ld a,c      
0000:222C AE     xor (hl)    
0000:222D 77     ld (hl),a  
0000:222E 23     inc hl      
0000:222F 10FA   djnz 222B  
0000:2231 118000 ld de,0080  
0000:2234 2A46D4 ld hl,(bytecursor)
0000:2237 19     add hl,de  
0000:2238 2246D4 ld (bytecursor),hl
0000:223B 2A57D4 ld hl,(delta_x)
0000:223E 110800 ld de,0008  
0000:2241 ED52   sbc hl,de  
0000:2243 DA5A22 jp c,225A  
0000:2246 2257D4 ld (delta_x),hl
0000:2249 3A56D4 ld a,(delta_y)
0000:224C 47     ld b,a      
0000:224D 2A46D4 ld hl,(bytecursor)
0000:2250 3EFF   ld a,FF    
0000:2252 AE     xor (hl)    
0000:2253 77     ld (hl),a  
0000:2254 23     inc hl      
0000:2255 10F9   djnz 2250  
0000:2257 C33122 jp 2231    
0000:225A B7     or a        
0000:225B ED5B57D4 ld de,(delta_x)
0000:225F 7B     ld a,e      
0000:2260 B2     or d        
0000:2261 CAA022 jp z,22A0  
0000:2264 214125 ld hl,bitmasks  
0000:2267 19     add hl,de  
0000:2268 7E     ld a,(hl)  
0000:2269 4F     ld c,a      
0000:226A 3A56D4 ld a,(delta_y)
0000:226D 47     ld b,a      
0000:226E 2A46D4 ld hl,(bytecursor)
0000:2271 79     ld a,c      
0000:2272 AE     xor (hl)    
0000:2273 77     ld (hl),a  
0000:2274 23     inc hl      
0000:2275 10FA   djnz 2271  
0000:2277 C3A022 jp 22A0    
0000:227A 214125 ld hl,bitmasks  
0000:227D 3A5DD4 ld a,(cursorbit)
0000:2280 5F     ld e,a      
0000:2281 1600   ld d,00    
0000:2283 19     add hl,de  
0000:2284 7E     ld a,(hl)  
0000:2285 2F     cpl        
0000:2286 4F     ld c,a      
0000:2287 2A57D4 ld hl,(delta_x)
0000:228A 19     add hl,de  
0000:228B EB     ex de,hl    
0000:228C 214125 ld hl,bitmasks  
0000:228F 19     add hl,de  
0000:2290 7E     ld a,(hl)  
0000:2291 A1     and c      
0000:2292 4F     ld c,a      
0000:2293 3A56D4 ld a,(delta_y)
0000:2296 47     ld b,a      
0000:2297 2A46D4 ld hl,(bytecursor)
0000:229A 79     ld a,c      
0000:229B AE     xor (hl)    
0000:229C 77     ld (hl),a  
0000:229D 23     inc hl      
0000:229E 10FA   djnz 229A  
0000:22A0 C9     ret        


          draw_box_inverted(x0,y0,x1,y1)
0000:22A1 FD210200 ld iy,0002  
0000:22A5 FD39   add iy,sp  
0000:22A7 CDFF22 call set_box(iy = boxptr)  
;;
;; draw west side of box
0000:22AA 2600   ld h,00    
0000:22AC 3A56D4 ld a,(delta_y) ;; n
0000:22AF 6F     ld l,a      
0000:22B0 E5     push hl    
0000:22B1 3A52D4 ld a,(y0)   ;; y
0000:22B4 6F     ld l,a      
0000:22B5 E5     push hl    
0000:22B6 2A50D4 ld hl,(x0)  ;; x
0000:22B9 E5     push hl    
0000:22BA CD3223 call draw_vert_inverted_line(x, y, n)  
0000:22BD D1     pop de      
0000:22BE D1     pop de      
0000:22BF D1     pop de      
;;
;; north side
0000:22C0 2A57D4 ld hl,(delta_x)
0000:22C3 E5     push hl    
0000:22C4 3A52D4 ld a,(y0)   ;; y0
0000:22C7 6F     ld l,a      
0000:22C8 E5     push hl    
0000:22C9 2A50D4 ld hl,(x0)  
0000:22CC E5     push hl     ;; push x0
0000:22CD CD5623 call draw_horiz_inverted_dashed_line(x, y, n)  
0000:22D0 D1     pop de      
0000:22D1 D1     pop de      
0000:22D2 D1     pop de      
;;
;; south side
0000:22D3 2A57D4 ld hl,(delta_x)
0000:22D6 E5     push hl    
0000:22D7 3A55D4 ld a,(y1)  
0000:22DA 3D     dec a      
0000:22DB 6F     ld l,a      
0000:22DC E5     push hl    
0000:22DD 2A50D4 ld hl,(x0)  
0000:22E0 E5     push hl     ;; push x0
0000:22E1 CD5623 call draw_horiz_inverted_dashed_line(x, y, n)  
0000:22E4 D1     pop de      
0000:22E5 D1     pop de      
0000:22E6 D1     pop de      
;;
;; east side
0000:22E7 2600   ld h,00    
0000:22E9 3A56D4 ld a,(delta_y)
0000:22EC 6F     ld l,a      
0000:22ED E5     push hl    
0000:22EE 3A52D4 ld a,(y0)   ;; y0
0000:22F1 6F     ld l,a      
0000:22F2 E5     push hl    
0000:22F3 2A53D4 ld hl,(x1)  
0000:22F6 2B     dec hl      
0000:22F7 E5     push hl     ;; push x1 - 1
0000:22F8 CD3223 call draw_vert_inverted_line(x, y, n)  
0000:22FB D1     pop de      
0000:22FC D1     pop de      
0000:22FD D1     pop de      
0000:22FE C9     ret        


          set_box(iy = boxptr)
set_bound_box(x0, y0, x1, y1)
;; this sets screen coords for bound box, and deltas.
0000:22FF B7     or a        
0000:2300 FD6E00 ld l,(iy+00)
0000:2303 FD6601 ld h,(iy+01)
0000:2306 2250D4 ld (x0),hl  ;; (#D450) = x0       (word)
;;
0000:2309 FD5E04 ld e,(iy+04)
0000:230C FD5605 ld d,(iy+05)
0000:230F EB     ex de,hl    
0000:2310 2253D4 ld (x1),hl  ;; (#D453) = x1       (word)
;;
0000:2313 ED52   sbc hl,de  
0000:2315 2257D4 ld (delta_x),hl;; (#D457) = delta x  (word)
;;
0000:2318 FD7E02 ld a,(iy+02)
0000:231B 3252D4 ld (y0),a   ;; (#D452) = y0       (byte)
;;
0000:231E 6F     ld l,a      
0000:231F 2600   ld h,00    
0000:2321 FD5E06 ld e,(iy+06)
0000:2324 1600   ld d,00    
0000:2326 EB     ex de,hl    
0000:2327 7D     ld a,l      
0000:2328 3255D4 ld (y1),a   ;; (#D455) = y1       (byte)
;;
0000:232B ED52   sbc hl,de  
0000:232D 7D     ld a,l      
0000:232E 3256D4 ld (delta_y),a ;; (#D456) = delta y  (byte)
0000:2331 C9     ret        


          draw_vert_inverted_line(x, y, n)
;; (inverts, not nec. a black line!  would undraw a prev draw, too.)
0000:2332 FD210200 ld iy,0002  
0000:2336 FD39   add iy,sp  
0000:2338 CD3B24 call set_lcd_pointer(x, y, n)   ;;  (sets hl = lcd buff addr, a = bitmask, and bc = n pix)
;;
0000:233B 57     ld d,a      ;; d has bitmask
;; loop
0000:233C 78     ld a,b      
0000:233D B1     or c        
0000:233E CA5523 jp z,2355   ;; done if n = 0
0000:2341 CB78   bit 7,b    
0000:2343 C25523 jp nz,2355  ;; done if n negative
0000:2346 7A     ld a,d      
0000:2347 AE     xor (hl)    
0000:2348 77     ld (hl),a   ;; apply bitmask at pointer loc
0000:2349 23     inc hl      ;; advance pointer two pixels (dashed line????)
0000:234A 23     inc hl      
0000:234B 0B     dec bc      ;; n = n - 1  (need to test if blank pix is end)
0000:234C 78     ld a,b      
0000:234D B1     or c        
0000:234E CA5523 jp z,2355   ;; done if n = 0  (if blank pix is last)
0000:2351 0B     dec bc      ;; n = n - 1
0000:2352 C33C23 jp 233C    
0000:2355 C9     ret        

          draw_horiz_inverted_dashed_line(x, y, n)
;; (inverts, not nec. a black line!  would undraw a prev draw, too.)
0000:2356 FD210200 ld iy,0002  
0000:235A FD39   add iy,sp  
0000:235C CD3B24 call set_lcd_pointer(x, y, n)  
;;
0000:235F 1E80   ld e,80     ;; lcd horiz byte offset = 128 dec (consecutive bytes are vertical!!!!)
;; loop
0000:2361 57     ld d,a      ;; d has bitmask
;;
0000:2362 78     ld a,b      
0000:2363 B1     or c        
0000:2364 CA8723 jp z,2387   ;; done if n = 0
0000:2367 CB78   bit 7,b    
0000:2369 C28723 jp nz,2387  ;; done if n negative
;;
0000:236C 0B     dec bc      ;; n = n - 1
;;
0000:236D 7A     ld a,d      ;; apply bitmask at pointer loc
0000:236E AE     xor (hl)    
0000:236F 77     ld (hl),a  
;;
0000:2370 7A     ld a,d      ;; rotate bitmask
0000:2371 07     rlca        
0000:2372 FE01   cp 01      
0000:2374 C27A23 jp nz,237A  ;; jp if not rolled over,
0000:2377 1600   ld d,00    
0000:2379 19     add hl,de   ;; else advance to next col  (when bitmask rolls around)
;;
0000:237A 0B     dec bc      ;; skip blank pixel  (dashed line)
0000:237B 07     rlca        
0000:237C FE01   cp 01      
0000:237E C26123 jp nz,2361  
0000:2381 1600   ld d,00    
0000:2383 19     add hl,de  
0000:2384 C36123 jp 2361    
0000:2387 C9     ret        

          draw_vert_black_line(x, y, n)
0000:2388 FD210200 ld iy,0002  
0000:238C FD39   add iy,sp  
0000:238E CD3B24 call set_lcd_pointer(x, y, n)  
0000:2391 57     ld d,a      
0000:2392 78     ld a,b      
0000:2393 B1     or c        
0000:2394 CA9F23 jp z,239F  
0000:2397 7A     ld a,d      
0000:2398 B6     or (hl)     ;; black line this time
0000:2399 77     ld (hl),a  
0000:239A 23     inc hl      
0000:239B 0B     dec bc      
0000:239C C39223 jp 2392    
0000:239F C9     ret        

          draw_vert_white_line(x, y, n)
0000:23A0 FD210200 ld iy,0002  
0000:23A4 FD39   add iy,sp  
0000:23A6 CD3B24 call set_lcd_pointer(x, y, n)  
0000:23A9 2F     cpl        
0000:23AA 57     ld d,a      
0000:23AB 78     ld a,b      
0000:23AC B1     or c        
0000:23AD CAB823 jp z,23B8  
0000:23B0 7A     ld a,d      
0000:23B1 A6     and (hl)    
0000:23B2 77     ld (hl),a  
0000:23B3 23     inc hl      
0000:23B4 0B     dec bc      
0000:23B5 C3AB23 jp 23AB    
0000:23B8 C9     ret        

          draw_vert_inverted_line(x, y, n)
0000:23B9 FD210200 ld iy,0002  
0000:23BD FD39   add iy,sp  
0000:23BF CD3B24 call set_lcd_pointer(x, y, n)  
0000:23C2 57     ld d,a      
0000:23C3 78     ld a,b      
0000:23C4 B1     or c        
0000:23C5 CAD023 jp z,23D0  
0000:23C8 7A     ld a,d      
0000:23C9 AE     xor (hl)    
0000:23CA 77     ld (hl),a  
0000:23CB 23     inc hl      
0000:23CC 0B     dec bc      
0000:23CD C3C323 jp 23C3    
0000:23D0 C9     ret        

          draw_horiz_black_line(x, y, n)
0000:23D1 FD210200 ld iy,0002  
0000:23D5 FD39   add iy,sp  
0000:23D7 CD3B24 call set_lcd_pointer(x, y, n)  
0000:23DA 1E80   ld e,80    
0000:23DC 57     ld d,a      
0000:23DD 78     ld a,b      
0000:23DE B1     or c        
0000:23DF CAF323 jp z,23F3  
0000:23E2 0B     dec bc      
0000:23E3 7A     ld a,d      
0000:23E4 B6     or (hl)    
0000:23E5 77     ld (hl),a  
0000:23E6 7A     ld a,d      
0000:23E7 07     rlca        
0000:23E8 FE01   cp 01      
0000:23EA C2DC23 jp nz,23DC  
0000:23ED 1600   ld d,00    
0000:23EF 19     add hl,de  
0000:23F0 C3DC23 jp 23DC    
0000:23F3 C9     ret        

          draw_horiz_white_line(x, y, n)
0000:23F4 FD210200 ld iy,0002  
0000:23F8 FD39   add iy,sp  
0000:23FA CD3B24 call set_lcd_pointer(x, y, n)  
0000:23FD 2F     cpl        
0000:23FE 1E80   ld e,80    
0000:2400 57     ld d,a      
0000:2401 78     ld a,b      
0000:2402 B1     or c        
0000:2403 CA1724 jp z,2417  
0000:2406 0B     dec bc      
0000:2407 7A     ld a,d      
0000:2408 A6     and (hl)    
0000:2409 77     ld (hl),a  
0000:240A 7A     ld a,d      
0000:240B 07     rlca        
0000:240C FEFE   cp FE      
0000:240E C20024 jp nz,2400  
0000:2411 1600   ld d,00    
0000:2413 19     add hl,de  
0000:2414 C30024 jp 2400    
0000:2417 C9     ret        

          draw_horiz_invert_line(x, y, n)
0000:2418 FD210200 ld iy,0002  
0000:241C FD39   add iy,sp  
0000:241E CD3B24 call set_lcd_pointer(x, y, n)  
0000:2421 1E80   ld e,80    
0000:2423 57     ld d,a      
0000:2424 78     ld a,b      
0000:2425 B1     or c        
0000:2426 CA3A24 jp z,243A  
0000:2429 0B     dec bc      
0000:242A 7A     ld a,d      
0000:242B AE     xor (hl)    
0000:242C 77     ld (hl),a  
0000:242D 7A     ld a,d      
0000:242E 07     rlca        
0000:242F FE01   cp 01      
0000:2431 C22324 jp nz,2423  
0000:2434 1600   ld d,00    
0000:2436 19     add hl,de  
0000:2437 C32324 jp 2423    
0000:243A C9     ret        

          set_lcd_pointer(x, y, n)
;; common code for line draw routines,
;; sets reg hl = lcd buff address, a = bitmask, and bc = number of pixels
0000:243B FD6E00 ld l,(iy+00);; par0' is lcd bit x coord (range: 0 - 319 dec)
0000:243E FD6601 ld h,(iy+01)
0000:2441 29     add hl,hl   ; HL=HL*4
0000:2442 29     add hl,hl  
0000:2443 11E32A ld de,bitcolumns  ; Table  ;; maps bitcolumns to lcd buffer addresses
0000:2446 19     add hl,de  
0000:2447 56     ld d,(hl)   ;; de = lcd buffer offset
0000:2448 23     inc hl      
0000:2449 5E     ld e,(hl)  
0000:244A 23     inc hl      
0000:244B 7E     ld a,(hl)   ;; a = bitmask
0000:244C FD6E02 ld l,(iy+02);; par2' is lcd y coord
0000:244F 2600   ld h,00    
0000:2451 19     add hl,de  
0000:2452 1110C0 ld de,lcdbuff  
0000:2455 19     add hl,de   ;; hl = par2' + buffer_offset + lcd_buff_start
0000:2456 FD4E04 ld c,(iy+04)
0000:2459 FD4605 ld b,(iy+05);; bc = par4'
0000:245C C9     ret        

; Clear bit map buffer and LCD display
          [0A85] Clear_LCD
0000:245D CD6424 call clear_lcdbuff  
0000:2460 CD7324 call copy_lcdbuff_to_LCD  
0000:2463 C9     ret        

; Clear LCD bit map buffer
          clear_lcdbuff
0000:2464 2110C0 ld hl,lcdbuff  
0000:2467 1111C0 ld de,C011  
0000:246A 01FF13 ld bc,13FF  
0000:246D 3E00   ld a,00    
0000:246F 77     ld (hl),a  
0000:2470 EDB0   ldir        
0000:2472 C9     ret        

; Copy LCD bit map buffer to display
          copy_lcdbuff_to_LCD
0000:2473 DB06   in a,(06)   ;; save slot4000device
0000:2475 5F     ld e,a      
0000:2476 D5     push de    
0000:2477 3E02   ld a,02     ;; slot4000device = #02 (first half of lcd)
0000:2479 D306   out (06),a  
0000:247B 2110C0 ld hl,lcdbuff  ;; hl = #c010 , first half lcd buffer
0000:247E CD9024 call 2490   ;; do half the screen
0000:2481 3E04   ld a,04     ;; slot4000device = #04 (second half of lcd)
0000:2483 D306   out (06),a  
0000:2485 2110CA ld hl,CA10  ;; hl = #ca10 , second half lcd buffer
0000:2488 CD9024 call 2490   ;; do the other half
0000:248B D1     pop de      ;; pop p6
0000:248C 7B     ld a,e      
0000:248D D306   out (06),a  
0000:248F C9     ret        

;; display half of lcd
;; hl is c010 when p6 = 2 ;; next call hl is ca10  and p6 = 4
0000:2490 0614   ld b,14     ;; b = #14  (do twenty columns of 8 pixels each = 160 pixels wide)
0000:2492 113840 ld de,4038  ;; de = #4038
;;
0000:2495 3AA1DB ld a,(p2shadow) ;; p2.3 = 0 ;; lcd column select active
0000:2498 E6F7   and F7      
0000:249A 32A1DB ld (p2shadow),a
0000:249D D302   out (02),a  
;;
0000:249F 78     ld a,b      
0000:24A0 3D     dec a      
0000:24A1 12     ld (de),a   ;; (#4038) = b - 1  ;; send lcd column number to lcd
;;
0000:24A2 3AA1DB ld a,(p2shadow) ;; p2.3 = 1  ;; lcd column select not-active
0000:24A5 F608   or 08      
0000:24A7 32A1DB ld (p2shadow),a
0000:24AA D302   out (02),a  
;;
0000:24AC 78     ld a,b      ;; a = b
0000:24AD 0600   ld b,00     ;; bc = #0080 (do 128 rows)
0000:24AF 0E80   ld c,80    
0000:24B1 EDB0   ldir        ;; display one column (ALL cols at 4038-40b7 !!!) (different col selected each time)
0000:24B3 47     ld b,a      
0000:24B4 10DC   djnz 2492   ;; loop until 20 cols done
0000:24B6 C9     ret        


          Update_LCD_at(x, y, n)
;; update a small part of lcd, maybe just 1 char???
0000:24B7 DD210200 ld ix,0002  
0000:24BB DD39   add ix,sp  
0000:24BD DD6E00 ld l,(ix+00);; hl = par0 (bit column) (x)
0000:24C0 DD6601 ld h,(ix+01)
0000:24C3 E5     push hl    
0000:24C4 B7     or a        
0000:24C5 11A000 ld de,pg13  ;; de = 160
0000:24C8 ED52   sbc hl,de  
0000:24CA 3805   jr c,24D1   ;; jp if col < 160  (right of left half LCD device)
;;
0000:24CC 3E04   ld a,04     ;; p6 value for "device = second half of lcd"
0000:24CE C3D524 jp 24D5     ;; (leave col adjusted down by 160)
;;
0000:24D1 E1     pop hl      ;; restore col if < 160
0000:24D2 E5     push hl    
0000:24D3 3E02   ld a,02     ;; p6 value for "device = first half of lcd"
;;
0000:24D5 324ED4 ld (lcdhalf),a ;; save lcd device# in (d44e)
;;
0000:24D8 1B     dec de      ;; de = 159 dec
0000:24D9 EB     ex de,hl    ;; hl = 159 dec , de = col
0000:24DA B7     or a        
0000:24DB ED52   sbc hl,de   ;; hl = 159 - col  (lcd coords reversed??? 0 becomes 159, and 159 becomes 0)
0000:24DD CB3C   srl h       ; HL >> 3
0000:24DF CB1D   rr l        
0000:24E1 CB3C   srl h      
0000:24E3 CB1D   rr l        
0000:24E5 CB3C   srl h      
0000:24E7 CB1D   rr l        ;; hl = bitcol / 8   (lcd_bytecol)
0000:24E9 7D     ld a,l      
0000:24EA 324FD4 ld (lcd_bytecol),a ;; save lcd_bytecol number in (d44f)
0000:24ED E1     pop hl      ;; hl = bitcol
0000:24EE B7     or a        
0000:24EF 29     add hl,hl   ; HL=HL*4  ;;index to table of 4byte values
0000:24F0 29     add hl,hl  
0000:24F1 01E32A ld bc,bitcolumns  ; Table     ;; table,  maps bitcolumn#'s to lcd buffer offsets
0000:24F4 09     add hl,bc   ;; hl points at tab row for our bitcol  (tab has 1 row for ea. col of pixels)
;;                                  ;; Table is 320 rows of (word, byte, byte)   (lcd_buff_offset, bitmask, bitshift)
0000:24F5 46     ld b,(hl)   ;; bc = first two bytes from table indexed loc
0000:24F6 23     inc hl      
0000:24F7 4E     ld c,(hl)  
0000:24F8 2110C0 ld hl,lcdbuff  ;; start of lcd buffer
0000:24FB 09     add hl,bc   ;; add offset to start addr  (we now point at buff addr of top row in our pix col)
;;
0000:24FC DD4E02 ld c,(ix+02);; bc = par2  (bitrow) (y)
0000:24FF 0600   ld b,00    
0000:2501 09     add hl,bc   ;; hl = lcdbuff addr for (bitcol, bitrow)  (now point at our row & col)
;;
0000:2502 2246D4 ld (bytecursor),hl;; save lcdbuff addr in (d446)
;;
0000:2505 213840 ld hl,4038  ;; address of top row of LCD
0000:2508 09     add hl,bc   ;; hl = topofLCD + bitrow  
0000:2509 224AD4 ld (LCD_Y),hl;; save that,too, in (d44a)
;;
0000:250C DB06   in a,(06)   ;; bank in lcd (which half is in d44e)
0000:250E 5F     ld e,a      
0000:250F D5     push de    
0000:2510 3A4ED4 ld a,(lcdhalf)
0000:2513 D306   out (06),a  
;;
0000:2515 2A46D4 ld hl,(bytecursor);; lcdbuff address
0000:2518 ED5B4AD4 ld de,(LCD_Y);; lcd address
;;
0000:251C 3AA1DB ld a,(p2shadow) ;; p2.3 = 0  (lcd col enable)
0000:251F E6F7   and F7      
0000:2521 32A1DB ld (p2shadow),a
0000:2524 D302   out (02),a  
;;
0000:2526 3A4FD4 ld a,(lcd_bytecol)
0000:2529 12     ld (de),a   ;; send it to lcd
;;
0000:252A 3AA1DB ld a,(p2shadow) ;; p2.3 = 1  (lcd col disable)
0000:252D F608   or 08      
0000:252F 32A1DB ld (p2shadow),a
0000:2532 D302   out (02),a  
;;
0000:2534 DD7E04 ld a,(ix+04);; par4, (n)
0000:2537 4F     ld c,a      
0000:2538 0600   ld b,00    
0000:253A EDB0   ldir        ;; copy n bytes from lcd buffer to LCD
;;
0000:253C D1     pop de      ;; bank lcd out
0000:253D 7B     ld a,e      
0000:253E D306   out (06),a  
0000:2540 C9     ret        


;; Table, used MANY places, 1 byte vals.  bit position to bit mask conversion table!???
          bitmasks
0000:2541 00     defb 00    
0000:2542 01     defb 01    
0000:2543 03     defb 03    
0000:2544 07     defb 07    
0000:2545 0F     defb 0F    
0000:2546 1F     defb 1F    
0000:2547 3F     defb 3F    
0000:2548 7F     defb 7F    
0000:2549 FF     defb FF    



          movebox_up(x0, y0, x1, y1, rows)          
0000:254A DD210200 ld ix,0002  
0000:254E DD39   add ix,sp  
;;
0000:2550 B7     or a        
0000:2551 DD6E00 ld l,(ix+00);; par0  (x0)
0000:2554 DD6601 ld h,(ix+01)
0000:2557 E5     push hl     ;; push x0
0000:2558 29     add hl,hl  
0000:2559 29     add hl,hl  
0000:255A 11E32A ld de,bitcolumns  ; Table ;; maps bitcolumns to lcd buffer addresses
0000:255D 19     add hl,de  
0000:255E 56     ld d,(hl)  
0000:255F 23     inc hl      
0000:2560 5E     ld e,(hl)  
0000:2561 23     inc hl      
0000:2562 23     inc hl      
0000:2563 7E     ld a,(hl)  
0000:2564 325DD4 ld (cursorbit),a
0000:2567 2110C0 ld hl,lcdbuff  
0000:256A 19     add hl,de   ;; hl points at bitcolumn X in lcdbuff
;;
0000:256B DD4E08 ld c,(ix+08);; bc = par8   (n)
0000:256E 0600   ld b,00    
0000:2570 DD5E02 ld e,(ix+02);; de = par2  (y0)
0000:2573 1600   ld d,00    
0000:2575 19     add hl,de  
0000:2576 2246D4 ld (bytecursor),hl;; (x0,y0) in lcdbuf  (dest????)
;;
0000:2579 09     add hl,bc   ;; bytecursor + n_rows
0000:257A 2248D4 ld (source),hl source is below dest  (moving up)
;;
0000:257D DD6E06 ld l,(ix+06);; hl = par6   (y1)
0000:2580 2600   ld h,00    
0000:2582 ED52   sbc hl,de   ;; hl = y1 - y0   (height)
0000:2584 D1     pop de      ;; de = x0
0000:2585 ED42   sbc hl,bc   ;; delta_y = height - n ????????
0000:2587 DA3B26 jp c,263B  
0000:258A CA3B26 jp z,263B   ;; ret if 0  or  ?????
;;
0000:258D 7D     ld a,l      
0000:258E 3256D4 ld (delta_y),a
;;
0000:2591 DD6E04 ld l,(ix+04)
0000:2594 DD6605 ld h,(ix+05);; hl = x1
0000:2597 ED52   sbc hl,de   ;; x1 - x0
0000:2599 2257D4 ld (delta_x),hl
;;
0000:259C 3A5DD4 ld a,(cursorbit)
0000:259F FE00   cp 00      
0000:25A1 CAED25 jp z,25ED   ;; jp if first col is whole byte wide
;;
0000:25A4 B7     or a        
0000:25A5 3A5DD4 ld a,(cursorbit)
0000:25A8 5F     ld e,a      
0000:25A9 1600   ld d,00     ;; de = cursorbit
0000:25AB 2A57D4 ld hl,(delta_x)
0000:25AE 19     add hl,de   ;; delta_x + cursorbit
;;
0000:25AF 110800 ld de,0008  
0000:25B2 ED52   sbc hl,de   ;; delta_x + cursorbit - 8
0000:25B4 2257D4 ld (delta_x),hl
;;
0000:25B7 214125 ld hl,bitmasks  ;; point at table
0000:25BA 5F     ld e,a      
0000:25BB 1600   ld d,00    
0000:25BD 19     add hl,de  
0000:25BE 7E     ld a,(hl)   ;; c = bitmask(cursorbit)   [0..7] --> [00..7f]
0000:25BF 4F     ld c,a      
;;
0000:25C0 3A56D4 ld a,(delta_y)
0000:25C3 47     ld b,a      ;; loop count = delta y
0000:25C4 FD2A46D4 ld iy,(bytecursor);; dest???
0000:25C8 2A48D4 ld hl,(source);; source????
;;
;; firstloop
0000:25CB 79     ld a,c      
0000:25CC 2F     cpl         ;; [ff..10] ie "allbit".."justhibit"
0000:25CD A6     and (hl)    ;; grab source bits    (i thin "10" is rt most)
0000:25CE 57     ld d,a      
;;
0000:25CF 79     ld a,c      ;; [00..7f] ie "nobits".."allbuthi"
0000:25D0 FDA600 and (iy+00) ;; grab existing bits
0000:25D3 B2     or d        ;; combine existing with source
0000:25D4 FD7700 ld (iy+00),a;; put result back in lcd buffer
;;
0000:25D7 23     inc hl      ;; source++
0000:25D8 FD23   inc iy      ;; dest++
0000:25DA 10EF   djnz 25CB   ;; firstloop
;;
;; bigloop   do all whole columns
0000:25DC 118000 ld de,0080  
0000:25DF 2A46D4 ld hl,(bytecursor);; move 1 byte to right
0000:25E2 19     add hl,de  
0000:25E3 2246D4 ld (bytecursor),hl
;;
0000:25E6 2A48D4 ld hl,(source);; move source too
0000:25E9 19     add hl,de  
0000:25EA 2248D4 ld (source),hl
;;
;; here when first col is a whole byte wide
0000:25ED 2A57D4 ld hl,(delta_x)
0000:25F0 110800 ld de,0008  
0000:25F3 ED52   sbc hl,de   ;; delta_x - 8
0000:25F5 DA0F26 jp c,260F   ;; jp if delta_x < 8
;;
0000:25F8 2257D4 ld (delta_x),hl;; delta_x = delta_x - 8
;;
0000:25FB 3A56D4 ld a,(delta_y)
0000:25FE 47     ld b,a      ;; shortloopcount = delta_y
0000:25FF ED5B46D4 ld de,(bytecursor);; dest
0000:2603 2A48D4 ld hl,(source);; source
;;
;; shortloop   do 1 column
0000:2606 7E     ld a,(hl)  
0000:2607 12     ld (de),a  
0000:2608 13     inc de      
0000:2609 23     inc hl      
0000:260A 10FA   djnz 2606   shortloop
;;
0000:260C C3DC25 jp 25DC     ;; bigloop
;;
;;
0000:260F B7     or a        
0000:2610 ED5B57D4 ld de,(delta_x)
0000:2614 7B     ld a,e      
0000:2615 B2     or d        
0000:2616 CA3B26 jp z,263B   ;; ret if delta_x = 0
;;
0000:2619 214125 ld hl,bitmasks  
0000:261C 19     add hl,de  
0000:261D 7E     ld a,(hl)  
0000:261E 4F     ld c,a      
;;
0000:261F 3A56D4 ld a,(delta_y)
0000:2622 47     ld b,a      
;;
0000:2623 FD2A46D4 ld iy,(bytecursor)
0000:2627 2A48D4 ld hl,(source)
;;
;; lastloop
0000:262A 79     ld a,c      
0000:262B A6     and (hl)    
0000:262C 57     ld d,a      
0000:262D 79     ld a,c      
0000:262E 2F     cpl        
0000:262F FDA600 and (iy+00)
0000:2632 B2     or d        
0000:2633 FD7700 ld (iy+00),a
0000:2636 23     inc hl      
0000:2637 FD23   inc iy      
0000:2639 10EF   djnz 262A   ;; lastloop
;;
0000:263B C9     ret        



          movebox_down(x0, y0, x1, y1, rows)
0000:263C DD210200 ld ix,0002  
0000:2640 DD39   add ix,sp  
;;
0000:2642 B7     or a        
0000:2643 DD6E00 ld l,(ix+00);; x0
0000:2646 DD6601 ld h,(ix+01)
0000:2649 E5     push hl    
0000:264A 29     add hl,hl  
0000:264B 29     add hl,hl  
0000:264C 11E32A ld de,bitcolumns  ; Table  ;; maps bitcolumns to lcd buffer addresses
0000:264F 19     add hl,de  
0000:2650 56     ld d,(hl)  
0000:2651 23     inc hl      
0000:2652 5E     ld e,(hl)  
0000:2653 23     inc hl      
0000:2654 23     inc hl      
0000:2655 7E     ld a,(hl)  
0000:2656 325DD4 ld (cursorbit),a
0000:2659 2110C0 ld hl,lcdbuff  
0000:265C 19     add hl,de   ;; hl = lcdbuff(x0)
;;
0000:265D DD4E08 ld c,(ix+08);; n???
0000:2660 0600   ld b,00    
0000:2662 DD5E06 ld e,(ix+06);; y1                             ****y0
0000:2665 1600   ld d,00    
0000:2667 19     add hl,de   ;; lcdbuff(x0,y1) ?????
0000:2668 2B     dec hl      ;;                                ****
0000:2669 2246D4 ld (bytecursor),hl;; dest = lcdbuf(x0,y1) - 1
;;
0000:266C ED42   sbc hl,bc   ;;                                ****add
0000:266E 2248D4 ld (source),hl;; source = dest - n
;;
0000:2671 DD6E02 ld l,(ix+02);; y0                             ****y1
0000:2674 2600   ld h,00    
0000:2676 EB     ex de,hl    ;;                                ****
0000:2677 ED52   sbc hl,de   ;; y1 - y0
0000:2679 D1     pop de      ;; x0
0000:267A ED42   sbc hl,bc   ;; deltay - n  ??????
0000:267C DA3027 jp c,2730  
0000:267F CA3027 jp z,2730   ;; ret if 0 or ????
;;
0000:2682 7D     ld a,l      
0000:2683 3256D4 ld (delta_y),a
;;
0000:2686 DD6E04 ld l,(ix+04)
0000:2689 DD6605 ld h,(ix+05)
0000:268C ED52   sbc hl,de  
0000:268E 2257D4 ld (delta_x),hl
;;
0000:2691 3A5DD4 ld a,(cursorbit)
0000:2694 FE00   cp 00      
0000:2696 CAE226 jp z,26E2   ;; jp if first col is whole byte wide
;;
0000:2699 B7     or a        
0000:269A 3A5DD4 ld a,(cursorbit)
0000:269D 5F     ld e,a      
0000:269E 1600   ld d,00    
0000:26A0 2A57D4 ld hl,(delta_x)
0000:26A3 19     add hl,de   ;; delta_x + cursorbit
;;
0000:26A4 110800 ld de,0008  
0000:26A7 ED52   sbc hl,de   ;; delta_x +cursorbit - 8
0000:26A9 2257D4 ld (delta_x),hl
;;
0000:26AC 214125 ld hl,bitmasks  
0000:26AF 5F     ld e,a      
0000:26B0 1600   ld d,00    
0000:26B2 19     add hl,de  
0000:26B3 7E     ld a,(hl)  
0000:26B4 4F     ld c,a      
;;
0000:26B5 3A56D4 ld a,(delta_y)
0000:26B8 47     ld b,a      ;; firstloopcount = delta_y
;;
0000:26B9 FD2A46D4 ld iy,(bytecursor);; dest
0000:26BD 2A48D4 ld hl,(source);; source
;;
;; firstloop
0000:26C0 79     ld a,c      
0000:26C1 2F     cpl        
0000:26C2 A6     and (hl)    
0000:26C3 57     ld d,a      
;;
0000:26C4 79     ld a,c      
0000:26C5 FDA600 and (iy+00)
0000:26C8 B2     or d        
0000:26C9 FD7700 ld (iy+00),a
;;
0000:26CC 2B     dec hl      ;;                              ****inc
0000:26CD FD2B   dec iy      ;;                              ****inc
0000:26CF 10EF   djnz 26C0  
;;
;; bigloop
0000:26D1 118000 ld de,0080  
0000:26D4 2A46D4 ld hl,(bytecursor)
0000:26D7 19     add hl,de  
0000:26D8 2246D4 ld (bytecursor),hl
;;
0000:26DB 2A48D4 ld hl,(source)
0000:26DE 19     add hl,de  
0000:26DF 2248D4 ld (source),hl
;;
;; here when first col is whole byte wide
0000:26E2 2A57D4 ld hl,(delta_x)
0000:26E5 110800 ld de,0008  
0000:26E8 ED52   sbc hl,de  
0000:26EA DA0427 jp c,2704  
;;
0000:26ED 2257D4 ld (delta_x),hl
;;
0000:26F0 3A56D4 ld a,(delta_y)
0000:26F3 47     ld b,a      
0000:26F4 ED5B46D4 ld de,(bytecursor)
0000:26F8 2A48D4 ld hl,(source)
;;
;; shortloop
0000:26FB 7E     ld a,(hl)  
0000:26FC 12     ld (de),a  
0000:26FD 1B     dec de      ;;                              ****inc
0000:26FE 2B     dec hl      ;;                              ****inc
0000:26FF 10FA   djnz 26FB   ;; shortloop
;;
0000:2701 C3D126 jp 26D1     ;; bigloop
;;
;;
0000:2704 B7     or a        
0000:2705 ED5B57D4 ld de,(delta_x)
0000:2709 7B     ld a,e      
0000:270A B2     or d        
0000:270B CA3027 jp z,2730   ;; ret if delta_x = 0
;;
0000:270E 214125 ld hl,bitmasks  
0000:2711 19     add hl,de  
0000:2712 7E     ld a,(hl)  
0000:2713 4F     ld c,a      
;;
0000:2714 3A56D4 ld a,(delta_y)
0000:2717 47     ld b,a      
;;
0000:2718 FD2A46D4 ld iy,(bytecursor)
0000:271C 2A48D4 ld hl,(source)
;;
;; lastloop
0000:271F 79     ld a,c      
0000:2720 A6     and (hl)    
0000:2721 57     ld d,a      
0000:2722 79     ld a,c      
0000:2723 2F     cpl        
0000:2724 FDA600 and (iy+00)
0000:2727 B2     or d        
0000:2728 FD7700 ld (iy+00),a
0000:272B 2B     dec hl      ;;                               ****inc
0000:272C FD2B   dec iy      ;;                               ****inc
0000:272E 10EF   djnz 271F   ;; lastloop
;;
0000:2730 C9     ret        



          checksum8(codeflashpagenum)
0000:2731 210200 ld hl,0002  
0000:2734 39     add hl,sp  
;;
0000:2735 DB05   in a,(05)   ;; save slot4000
0000:2737 57     ld d,a      
0000:2738 DB06   in a,(06)  
0000:273A 5F     ld e,a      
0000:273B D5     push de    
;;
0000:273C 3E00   ld a,00     ;; slot4000 = codeflash page par0
0000:273E D306   out (06),a  
0000:2740 7E     ld a,(hl)  
0000:2741 D305   out (05),a  
;;
0000:2743 210040 ld hl,4000  ;; source
0000:2746 DD210000 ld ix,0000  ;; sum = 0
0000:274A 0600   ld b,00    
;;
;; loop
0000:274C 4E     ld c,(hl)   ;; grab a byte
0000:274D DD09   add ix,bc   ;; sum = sum + byte
0000:274F 23     inc hl      ;; next byte
0000:2750 7C     ld a,h      
0000:2751 FE80   cp 80      
0000:2753 C24C27 jp nz,274C  ;; loop if source < 8000
;;
0000:2756 DDE5   push ix    
0000:2758 E1     pop hl      ;; hl = sum
;;
0000:2759 D1     pop de      ;; restore slot4000
0000:275A 7A     ld a,d      
0000:275B D305   out (05),a  
0000:275D 7B     ld a,e      
0000:275E D306   out (06),a  
;;
0000:2760 C9     ret         ;; ret hl = sum


          render_char(B=char, C=font)
;; renders the ascii char B in single char buffer, using font C.
; Print character
; Char sent in B
0000:2761 DB05   in a,(05)   ;; save slot4000
0000:2763 5F     ld e,a      
0000:2764 DB06   in a,(06)  
0000:2766 E60F   and 0F      
0000:2768 57     ld d,a      
0000:2769 D5     push de    
;;
0000:276A 3E00   ld a,00     ;; slot4000device = codeflash
0000:276C D306   out (06),a  
0000:276E 3E04   ld a,04     ;; slot4000page = #04  [01000]  (the one just past this listing)
0000:2770 D305   out (05),a  ;; codepage 4 is has font data
;;
0000:2772 78     ld a,b      
0000:2773 FE20   cp 20       ; Check for char boundaries
0000:2775 380C   jr c,2783   ;;jp if < #20  (ctrlchar, map it to #7f - #20, or #5f)
0000:2777 FE81   cp 81      
0000:2779 3804   jr c,277F   ;;jp if < #81  (printable, remove #20 offset)
0000:277B FEA1   cp A1      
0000:277D 3804   jr c,2783   ;;jp if < #A1  (#81 to #A0, map to #5f)
;;
0000:277F D620   sub 20      ;; subtract ctrl chr offset  (but what about second gap at #81???)
0000:2781 1802   jr 2785    
;;
0000:2783 3E5F   ld a,5F     ;; remap ctrl chars to #5F  (#7f - #20)
;;
;; when we get here, the ascii has been changed to a font position
0000:2785 5F     ld e,a      
0000:2786 1600   ld d,00     ;; chr is in DE
0000:2788 79     ld a,c      ;; C is font????
0000:2789 FE00   cp 00      
0000:278B 2015   jr nz,27A2  
;;
; Look up char data for font 1      ;; i am gonna rename fonts zero based
;; font 0 when C was 0
0000:278D 210240 ld hl,4002  ;; width data (proportional font)
0000:2790 19     add hl,de  
0000:2791 46     ld b,(hl)   ;; width
0000:2792 0E08   ld c,08     ;; height????
0000:2794 21E240 ld hl,40E2  ;; font pos to chargen mapping
0000:2797 19     add hl,de  
0000:2798 19     add hl,de   ;; add twice, two bytes per table entry
0000:2799 5E     ld e,(hl)  
0000:279A 23     inc hl      
0000:279B 56     ld d,(hl)  
0000:279C 21A242 ld hl,42A2  ;; chargen bitmap data for char
0000:279F 19     add hl,de  
0000:27A0 1845   jr 27E7     ;; hl is pointing at bit data for char
;;
; Look up char data for font 2
0000:27A2 FE01   cp 01      
0000:27A4 2015   jr nz,27BB  
;; font 1 when C was 1
0000:27A6 21BA48 ld hl,48BA  ; Point to diagnostic main menu string?
0000:27A9 19     add hl,de  
0000:27AA 46     ld b,(hl)   ; B = character?
0000:27AB 0E0B   ld c,0B     ; C = font type?
0000:27AD 219A49 ld hl,499A  ; Add 2xDE to base
0000:27B0 19     add hl,de  
0000:27B1 19     add hl,de  
0000:27B2 5E     ld e,(hl)   ; DE = value from table
0000:27B3 23     inc hl      
0000:27B4 56     ld d,(hl)  
0000:27B5 215A4B ld hl,4B5A  ; Add to table
0000:27B8 19     add hl,de  
0000:27B9 182C   jr 27E7    
;;
; Look up char data for font 3
0000:27BB FE02   cp 02      
0000:27BD 2015   jr nz,27D4  
;; font 2 when C was 2
0000:27BF 21E753 ld hl,53E7  
0000:27C2 19     add hl,de  
0000:27C3 46     ld b,(hl)  
0000:27C4 0E0A   ld c,0A    
0000:27C6 210F54 ld hl,540F  
0000:27C9 19     add hl,de  
0000:27CA 19     add hl,de  
0000:27CB 5E     ld e,(hl)  
0000:27CC 23     inc hl      
0000:27CD 56     ld d,(hl)  
0000:27CE 215F54 ld hl,545F  
0000:27D1 19     add hl,de  
0000:27D2 1813   jr 27E7    
;;
; Look up char data for font 4
;; font 3 when C was 3       (Calculator font)
0000:27D4 211D55 ld hl,551D  
0000:27D7 19     add hl,de  
0000:27D8 46     ld b,(hl)  
0000:27D9 0E10   ld c,10    
0000:27DB 213B55 ld hl,553B  
0000:27DE 19     add hl,de  
0000:27DF 19     add hl,de  
0000:27E0 5E     ld e,(hl)  
0000:27E1 23     inc hl      
0000:27E2 56     ld d,(hl)  
0000:27E3 217755 ld hl,5577  
0000:27E6 19     add hl,de  
;;
; Copy char data to LCD     ;; here after pointing hl at bit data.
;; Actually, this just copies one char from font to single char buffer, not the lcd buffer just yet.
0000:27E7 1110D4 ld de,fontbuff.charwidth  ;; here's that single char buffer address again!
0000:27EA 78     ld a,b      ;; char width to sing char buff
0000:27EB 12     ld (de),a  
0000:27EC 13     inc de      
0000:27ED 79     ld a,c      ;; char height to sing char buff
0000:27EE 12     ld (de),a  
0000:27EF 13     inc de      
0000:27F0 78     ld a,b      
0000:27F1 FE09   cp 09       ;; width - 9,  cy means 1 byte wide, no cy means 2 bytes wide
0000:27F3 3E01   ld a,01    
0000:27F5 3805   jr c,27FC   ;; jp if char is only 1 byte wide
;;
0000:27F7 79     ld a,c      ;; C = height x 2  (need twice as many bytes if 2 bytes wide)
0000:27F8 87     add a,a    
0000:27F9 4F     ld c,a      
0000:27FA 3E02   ld a,02    
;;
0000:27FC 0600   ld b,00     ;; now, BC is count of bytes in char bitmap
0000:27FE 12     ld (de),a   ;; num of bytes wide to sing char buff
0000:27FF 13     inc de      ;; now, de is pointing where the bit data goes in single char buff
0000:2800 EDB0   ldir        ; Copy
;;
0000:2802 D1     pop de      
0000:2803 7A     ld a,d      
0000:2804 D306   out (06),a  ; Restore banks
0000:2806 7B     ld a,e      
0000:2807 D305   out (05),a  
0000:2809 C9     ret        



          dispatchme(B,C)
;;  seems to be "find_icon".   called from 2 places
;; When b>=128, C is byte to look up in "magicsector", a directory of some sort.
;; might be font look up?????  Or icon lookup???  both???  samething?????
;; format of icon in buffer #D410 is: width_word, height_byte.
;; (#D444) points at icon bit data, and (#D442) is icon width in bytes.
;; (#D455) is icon device, (#D452) is icon page, (#D44F) is slot info
;;
0000:280A 78     ld a,b      
0000:280B FE01   cp 01      
0000:280D 2810   jr z,281F   ;; B = 1 ? jp #281F
0000:280F FE02   cp 02      
0000:2811 2811   jr z,2824   ;; B = 2 ? jp #2824
0000:2813 FE00   cp 00      
0000:2815 2812   jr z,2829   ;; B = 0 ? jp #2829
0000:2817 FE80   cp 80      
0000:2819 D23428 jp nc,2834  ;; B >= #80 ? jp #2834
0000:281C C3DB28 jp 28DB     ;; else jp #28DB   (when #03 <= B <#80)
;;
;; b was #01   (splash screen???)
0000:281F 110009 ld de,0900  ;; sector #09, offset #00
0000:2822 1844   jr 2868     ;; jp to read from dataflash
;;
;; b was #02   (another icon????)
0000:2824 110021 ld de,2100  ;; sector #21, offset #00
0000:2827 183F   jr 2868     ;; jp to read from dataflash
;;
;; b was #00
0000:2829 3E04   ld a,04     ;; binary 0100
0000:282B 324FD4 ld (lcd_bytecol),a ;; sumthin = #04  ***********  current ram page
;;                                  ;;    sumthin is a flag for what slot is being used, so can restore correct slot at end
;;                                  ;;      0001 - codeflash at 4000 (not OK dataflash sector)
;;                                  ;;      0010 -       ram at 8000 (OK dataflash sector)
;;                                  ;;      0100 -       ram at 8000
;;                                  ;;      1000 - dataflash at 4000
0000:282E 210480 ld hl,8004  
0000:2831 C31C29 jp 291C    
;;
;; b >= #80  (hi bit set)
0000:2834 78     ld a,b      ;; B = B - #7F   (b = b - 127dec)
0000:2835 067F   ld b,7F    
0000:2837 90     sub b      
0000:2838 47     ld b,a      
;;
0000:2839 3E08   ld a,08    
0000:283B 324FD4 ld (lcd_bytecol),a ;; sumthin = #08  (in dataflash)  ***********
;;
0000:283E 69     ld l,c      ;; app number???
0000:283F 2600   ld h,00     ;; byte to scan for  (calling value in C reg)
0000:2841 E5     push hl    
0000:2842 CDD60A call L = Scan_Magicsector(who)   ;; rets app page
0000:2845 D1     pop de      
;;
0000:2846 DB06   in a,(06)   ;; d = slot4000device  (save it)
0000:2848 E60F   and 0F      
0000:284A 57     ld d,a      
;;
0000:284B 3E03   ld a,03     ;; set slot4000device = dataflash
0000:284D D306   out (06),a  
0000:284F 3255D4 ld (y1),a   ;; (D455) = device
;;
0000:2852 DB05   in a,(05)   ;; e = slot4000page  (save it too)
0000:2854 5F     ld e,a      
;;
0000:2855 7D     ld a,l      ;; set slot4000page = app page  (from magic lookup)
0000:2856 D305   out (05),a  
0000:2858 3252D4 ld (y0),a   ;; (D452) = page
;;
0000:285B D5     push de     ;; save previous slot4000 inhabitant
;;
0000:285C 2A0340 ld hl,(4003);; grab icon address from dataflash app page
0000:285F EB     ex de,hl    
0000:2860 D5     push de    
0000:2861 DDE1   pop ix      ;; IX = icon_address
0000:2863 13     inc de      
0000:2864 13     inc de      ;; DE = icon_address + 2
0000:2865 C30E29 jp 290E    
;;
;; here when  b=1, de=0900   OR  b=2 de=2100.  read 2 bytes from dataflash.  (JUST 2 BYTES!!!)
;; LOOKS for "OK" in either of the 2 areas of dataflash
0000:2868 2110D4 ld hl,fontbuff.charwidth  
0000:286B E5     push hl     ;; push @where = #D410  (this add was sing char buff, maybe a gen purpose buff???)
0000:286C 210200 ld hl,0002  
0000:286F E5     push hl     ;; push n = #0002  (just reading 2 bytes!)
0000:2870 210200 ld hl,0002  
0000:2873 E5     push hl     ;; push #0002         hi byte of page    dep on B, the 2 are:  8:9:0 / 8:21:0
0000:2874 D5     push de     ;; push  #0900/2100   pp:sector:offset    (pp meaning 2 bits of page!)
0000:2875 CD0509 call Read_dataflash(page:sector:offset, n, @where)  
;;                                  ;; the first par is a long, just the absolute 24 bit address.  Maybe that suggests
;;                                  ;; a better name???
;;                            ;; par0: 00         (offset 00)
;;                            ;; par1: 09 or 21   (sect 09 or 21)
;;                            ;; par2: 02         (pg 8)
;;                            ;; par3: 00         (dont care, not used, just 24 bit address)
0000:2878 D1     pop de      
0000:2879 E1     pop hl      
0000:287A E1     pop hl      
0000:287B E1     pop hl      ;; use val , @where = #D410
;;
0000:287C 7E     ld a,(hl)   ;; 1st of 2 bytes read from dataflash
0000:287D FE4F   cp 4F      
0000:287F C2DB28 jp nz,28DB  ;; jp if it is not = #4F  'O'
0000:2882 23     inc hl      
0000:2883 7E     ld a,(hl)   ;; 2nd of 2 bytes read from dataflash
0000:2884 FE4B   cp 4B      
0000:2886 C2DB28 jp nz,28DB  ;; jp if it is not = #4B  'K'
;;
;; the flag sez "OK" for selected area
0000:2889 CDF305 call What_Rampage?   ;; What_Rampage() sets slot8000device = ram , no change to page, rets currentpage
0000:288C 7D     ld a,l      
0000:288D 3250D4 ld (x0),a   ;; save current ram page in #D450
0000:2890 2E04   ld l,04    
0000:2892 2600   ld h,00    
0000:2894 E5     push hl    
0000:2895 CDF005 call Rampage!(new)   ;; Rampage(#04)   (puts page 4 of ram into slot8000)
0000:2898 E1     pop hl      
;;
;; still b=1, de=0900   OR  b=2 de=2100   ("OK")
0000:2899 210080 ld hl,8000  
0000:289C E5     push hl     ;; push @where = #8000
0000:289D 78     ld a,b      ;; B is still 1 or 2
0000:289E FE01   cp 01      
0000:28A0 2009   jr nz,28AB  
;;
;; B is 1, de=0900   ("OK")
0000:28A2 210715 ld hl,1507  
0000:28A5 E5     push hl     ;; ****push n = #1507  (5383 dec)
0000:28A6 110209 ld de,Read_dataflash_Lastsector(offset, n, @where)  ;; low 2 bytes of page:sector:offset
0000:28A9 1807   jr 28B2    
;;
;; B is 2, de=2100   ("OK")
0000:28AB 212703 ld hl,0327  
0000:28AE E5     push hl     ;; ****push n = #0327   (807 dec)
0000:28AF 110221 ld de,2102  ;; low 2 bytes of page:sector:offset
;;
;; Now:  b=1, de=#0902, hl=#1507  _OR_  b=2, de=#2102, hl=#0327   ("OK")
0000:28B2 D5     push de     ;; *
0000:28B3 C5     push bc     ;; **
0000:28B4 210080 ld hl,8000  ;; zero 5129 dec bytes @8000
0000:28B7 110180 ld de,8001  
0000:28BA 010814 ld bc,1408  
0000:28BD 3E00   ld a,00    
0000:28BF 77     ld (hl),a  
0000:28C0 EDB0   ldir        
0000:28C2 C1     pop bc      ;; **
0000:28C3 D1     pop de      ;; *
;;
0000:28C4 210200 ld hl,0002  ;; high byte of page:sector:offset
0000:28C7 E5     push hl     ;; ****push high byte of page:sector:offset (2)    [08:xx:xx]
0000:28C8 D5     push de     ;; ****push low 2 bytes of page:sector:offset      [08:09:02] or [08:21:02]
0000:28C9 CD0509 call Read_dataflash(page:sector:offset, n, @where)  
;;                                  ;;   (page:sector:offset above is just 24 bit absolute address in dataflash)
0000:28CC D1     pop de      
0000:28CD E1     pop hl      
0000:28CE E1     pop hl      
0000:28CF E1     pop hl      ;; val used  (@where) (#8000 still????)
0000:28D0 110400 ld de,0004  
0000:28D3 19     add hl,de   ;; @where + 4   (#8004)
0000:28D4 3E02   ld a,02     ;; 0010
0000:28D6 324FD4 ld (lcd_bytecol),a ;; sumthin = #02  *********** means one of the OK sectors of dataflash in ram pg 4
0000:28D9 1841   jr 291C    
;;
;; here when B>=#03 and B<#80,  OR when B=#01 or B=#02, and the dataflash file is not marked "OK".
0000:28DB 3E01   ld a,01     ;; 0001
0000:28DD 324FD4 ld (lcd_bytecol),a ;; sumthin = #01   ***********  dataflash not "OK" , use codeflash instead
0000:28E0 78     ld a,b      ;; b is 1 or 2 still
0000:28E1 FE01   cp 01      
0000:28E3 2008   jr nz,28ED  
;; b is 1    (this looks like a patch, only #01 is found in page #2C)
0000:28E5 262C   ld h,2C     ;; use page #2c    (i thin this might be splash screen)
0000:28E7 DD210068 ld ix,6800  ;; offset in page
0000:28EB 1806   jr 28F3    
;; b is > 1
0000:28ED 2604   ld h,04     ;; use page #04
0000:28EF DD216757 ld ix,5767  ;; offset in page to start of icons
;;
0000:28F3 DB05   in a,(05)   ;; save slot4000
0000:28F5 5F     ld e,a      
0000:28F6 DB06   in a,(06)  
0000:28F8 E60F   and 0F      
0000:28FA 57     ld d,a      
0000:28FB D5     push de    
;;
0000:28FC 3E00   ld a,00    
0000:28FE D306   out (06),a  ;; set slot4000device = codeflash
0000:2900 3255D4 ld (y1),a   ;; d455 = device
;;
0000:2903 7C     ld a,h      ;; set slot4000page = H
0000:2904 D305   out (05),a  
0000:2906 3252D4 ld (y0),a   ;; d452 = page
;;
0000:2909 DDE5   push ix    
0000:290B D1     pop de      ;; de = offset in page to start of icons
0000:290C 13     inc de      
0000:290D 13     inc de      ;; de = offset + 2  [#04:5769]  (#1769 in codepage #04)
;;
;; hops in here when >=128 (after magic lookup), ix = 4th & 5th bytes from selected page of dataflash, de = ix+2
;; however we got here, the selected page is banked in, and IX & DE are pointing at our data, right???
0000:290E 68     ld l,b      ;; b was 1 to 127, or >=128??? (-127 now, as in 1 or 2??? or greater too???)
0000:290F 2600   ld h,00     ;; I am thinin that B is 1 based icon#.
0000:2911 2D     dec l       ;; hl is 0 based icon# now.
0000:2912 29     add hl,hl  
0000:2913 29     add hl,hl   ;; hl = hl * 4  (icon# x 4)
0000:2914 19     add hl,de   ;; HL = offsettoicons + 2 + (icon# x 4)   (iow, addr of offset to selected icon)
;;
0000:2915 5E     ld e,(hl)   ;; DE = offset to selected icon  [#0188 for icon 2]
0000:2916 23     inc hl      
0000:2917 56     ld d,(hl)   ;; when b=1, not "OK", then de = #0004
0000:2918 DDE5   push ix     ;; offset in page to start of icons
0000:291A E1     pop hl      
0000:291B 19     add hl,de   ;; HL = offset to data + offset to selected icon   (hl points at a particular icon now)
;;                                  ;; hl is pointing at icon width, actually  [#58ef for icon 2]
;; here when b=0, hl=8004
;;   _OR_
;; notOK, b=1, hl=#6804  _OR_  notOK, b=2, hl=#5769 + icon_offset
;;   _OR_
;; b >= 3, hl=#5769 + icon_offset
;;   _OR_
;; when OK or after magic lookup too, vals are ????
;;
;; all paths thru this routine converge here, after setup of the various
;; sources.  hl points at a particular icon now.
;;
;; format of icon in buffer is: width_word, height_byte, all the bytes of bitmap data
;; (#D444) points at icon bit data, and (#D442) is icon width in bytes.
;; (#D455) is icon device, (#D452) is icon page, (#D44F) is slot info
0000:291C 1110D4 ld de,fontbuff.charwidth  ;; buff   (same addr as single char buff, but format is diff for icons.)
;;
0000:291F 4E     ld c,(hl)   ;; get lo byte of icon width
0000:2920 79     ld a,c      
0000:2921 12     ld (de),a   ;; put lo byte of width in buff (and C)
;;
0000:2922 13     inc de      
0000:2923 23     inc hl      
0000:2924 46     ld b,(hl)   ;; get hi byte of icon width
0000:2925 78     ld a,b      
0000:2926 12     ld (de),a   ;; put hi byte in buff (and B)    (bc has icon width now)  [#0140 for icon 2]
;;
0000:2927 13     inc de      
0000:2928 23     inc hl      
0000:2929 7E     ld a,(hl)   ;; get icon height
0000:292A 12     ld (de),a   ;; put icon height in buff  (and A)
;;
0000:292B 23     inc hl      ;; hl points at icon bit data now
0000:292C 1144D4 ld de,icon_bitmap_ptr  ;; (#D444) = pointer to icon bit data
0000:292F 7D     ld a,l      
0000:2930 12     ld (de),a  
0000:2931 13     inc de      
0000:2932 7C     ld a,h      
0000:2933 12     ld (de),a  
;;
0000:2934 03     inc bc      ;; (#D442) = (width + 7)/8     icon width in bytes instead of pixels
0000:2935 03     inc bc      
0000:2936 03     inc bc      
0000:2937 03     inc bc      
0000:2938 03     inc bc      
0000:2939 03     inc bc      
0000:293A 03     inc bc      
0000:293B CB38   srl b      
0000:293D CB19   rr c        
0000:293F CB38   srl b      
0000:2941 CB19   rr c        
0000:2943 CB38   srl b      
0000:2945 CB19   rr c        
0000:2947 2142D4 ld hl,icon_num_bytes_wide  
0000:294A 71     ld (hl),c  
0000:294B 23     inc hl      
0000:294C 70     ld (hl),b  
;;
;; restore slot 4000 if we used it.  #D450, #D452, #D455 have the page/dev we used, for later use by caller!!
0000:294D 3A4FD4 ld a,(lcd_bytecol) ;; sumthin
0000:2950 E609   and 09      
0000:2952 C25829 jp nz,2958  ;; if sumthin was 0 or 8, we need to restore slot4000
0000:2955 C35F29 jp 295F    
;;
0000:2958 D1     pop de      ;; restore slot4000
0000:2959 7A     ld a,d      
0000:295A D306   out (06),a  
0000:295C 7B     ld a,e      
0000:295D D305   out (05),a  
0000:295F C9     ret        
;; end of dispatchme



;; this is called from a few places, in range 1dxx-1exx, above here.
;; it puts the page found by dispatchme back in its slot, and
;; copies a block from it to buffer at #d410.
;;
;; Wait, it only has to put it back if it was in slot 4000!!!!  
;; this seems ultra retarded!!!!  All this crap swapping in and out,
;; and checking if we are using slot4000 or 8000!!!!  
;;
;; Why not just put all of them in slot 8000, and not worry about messin
;; with the code slot????  It seems to copy to a buffer in slot C000 anyhow,
;; so what is in slot8000 when we are screwing with slot 4000??????
;;
;; Copies one pixel row of icon to the font buffer each time called.
          read_dispatch
0000:2960 3A4FD4 ld a,(lcd_bytecol) ;; sumthin              
0000:2963 E609   and 09      ;; these two bits are flags, mean slot4000 used by dispatchme
0000:2965 C26B29 jp nz,296B  ;; swap into slot4000 if 8 or 1
0000:2968 C37E29 jp 297E     ;; else its in ram
;;
;; it's in code or data flash, need to bank it in.
0000:296B DB05   in a,(05)   ;; save slot4000
0000:296D 5F     ld e,a      
0000:296E DB06   in a,(06)  
0000:2970 E60F   and 0F      
0000:2972 57     ld d,a      
0000:2973 D5     push de    
;;
0000:2974 3A55D4 ld a,(y1)   ;; set slot4000 per saved values
0000:2977 D306   out (06),a  
0000:2979 3A52D4 ld a,(y0)  
0000:297C D305   out (05),a  
;;
;; here after banking, or if it was already in ram bank.
0000:297E 2142D4 ld hl,icon_num_bytes_wide  
0000:2981 4E     ld c,(hl)  
0000:2982 23     inc hl      
0000:2983 46     ld b,(hl)   ;; BC = (#D442)    (n)
;;
0000:2984 1110D4 ld de,fontbuff.charwidth  ;; buff???         (dest)
;;
0000:2987 2144D4 ld hl,icon_bitmap_ptr  
0000:298A 7E     ld a,(hl)  
0000:298B 23     inc hl      
0000:298C 66     ld h,(hl)  
0000:298D 6F     ld l,a      ;; HL = (#D444)    (src)
0000:298E EDB0   ldir        ;; copy 1 line of pixels to fontbuff
;;
0000:2990 1144D4 ld de,icon_bitmap_ptr  ;; (#D444) = next src
0000:2993 EB     ex de,hl    
0000:2994 73     ld (hl),e  
0000:2995 23     inc hl      
0000:2996 72     ld (hl),d   ;; de = hl value after the ldir
;;
;; restore slot4000 if we changed it above.
0000:2997 3A4FD4 ld a,(lcd_bytecol) ;; sumthin
0000:299A E609   and 09      
0000:299C C2A229 jp nz,29A2  ;; 8 OR 1?
0000:299F C3A929 jp 29A9     ;; just ret if it was in ram  (slot8000)
;;
0000:29A2 D1     pop de      ;; restore slot4000
0000:29A3 7A     ld a,d      
0000:29A4 D306   out (06),a  
0000:29A6 7B     ld a,e      
0000:29A7 D305   out (05),a  
;;
0000:29A9 C9     ret        


; Determine font set and convert char code prior to printing
;;
;; result is the width & height of the string, in pixels, stored in two
;; consecutive words at w_h_ptr.
;;
          [0A88] calc_string_height&width(thingyptr, stringptr, len, w_h_ptr)
0000:29AA DD210200 ld ix,0002  
0000:29AE DD39   add ix,sp  
;;
0000:29B0 DB05   in a,(05)  
0000:29B2 5F     ld e,a      
0000:29B3 DB06   in a,(06)  
0000:29B5 57     ld d,a      
0000:29B6 D5     push de    
;;
0000:29B7 3E00   ld a,00     ;; slot4000 = font page (0004:4000)
0000:29B9 D306   out (06),a  
0000:29BB 3E04   ld a,04    
0000:29BD D305   out (05),a  
;;
0000:29BF DD6E00 ld l,(ix+00);; hl = par0
0000:29C2 DD6601 ld h,(ix+01)
0000:29C5 110A00 ld de,000A  
0000:29C8 19     add hl,de   ;; font is at par0 + 000a
0000:29C9 7E     ld a,(hl)  
0000:29CA FE00   cp 00      
0000:29CC 2008   jr nz,29D6  
;;
0000:29CE 1E08   ld e,08     ;; height is 8 pixels
0000:29D0 FD210240 ld iy,4002  ;; font0
0000:29D4 181E   jr 29F4    
;;
;; not 0
0000:29D6 FE01   cp 01      
0000:29D8 2008   jr nz,29E2  
;;
0000:29DA 1E0B   ld e,0B     ;; height is 11 pixels
0000:29DC FD21BA48 ld iy,48BA  ; Diag main menu string?  ;; font1
0000:29E0 1812   jr 29F4    
;;
;; not 1
0000:29E2 FE02   cp 02      
0000:29E4 2008   jr nz,29EE  
;;
0000:29E6 1E0A   ld e,0A     ;; height is 10 pixels
0000:29E8 FD21E753 ld iy,53E7  ;; font2
0000:29EC 1806   jr 29F4    
;;
;; not 2
0000:29EE 1E10   ld e,10     ;; height is 16 pixels
0000:29F0 FD211D55 ld iy,551D  ;; font3
;;
;; here after set font
0000:29F4 DD6E06 ld l,(ix+06);; hl = par6
0000:29F7 DD6607 ld h,(ix+07)
0000:29FA 23     inc hl      
0000:29FB 23     inc hl      ;; hl = par6 + 2
0000:29FC 1600   ld d,00    
0000:29FE 73     ld (hl),e  
0000:29FF 23     inc hl      
0000:2A00 72     ld (hl),d   ;; (par6 + 2) = font height
;;
0000:2A01 DD4E04 ld c,(ix+04);; bc = par4    (n)
0000:2A04 DD4605 ld b,(ix+05)
0000:2A07 DD6E02 ld l,(ix+02);; hl = par2
0000:2A0A DD6603 ld h,(ix+03)
0000:2A0D DDE5   push ix     ;; *
0000:2A0F E5     push hl     ;; **
0000:2A10 DDE1   pop ix      ;; **   ix = par2  (stringptr)
;;
0000:2A12 210000 ld hl,0000  ;; set total width to 0
0000:2A15 1600   ld d,00    
;;
0000:2A17 78     ld a,b      
0000:2A18 B1     or c        
0000:2A19 2825   jr z,2A40   ;; jp if bc = 0
;;
0000:2A1B DD7E00 ld a,(ix+00);; a = (par2)
0000:2A1E DD23   inc ix      
0000:2A20 FE20   cp 20      
0000:2A22 380C   jr c,2A30   ;; unprintable if less than "space"
0000:2A24 FE81   cp 81      
0000:2A26 3804   jr c,2A2C   ;; printable if less than #81
0000:2A28 FEA1   cp A1      
0000:2A2A 3804   jr c,2A30   ;; unprintable if less than #A1
;;
;; printable
0000:2A2C D620   sub 20      
0000:2A2E 1802   jr 2A32    
;;
;; unprintable
0000:2A30 3E5F   ld a,5F    
0000:2A32 5F     ld e,a      ;; e = char
;;
0000:2A33 FDE5   push iy     ;; *~        iy points at font
0000:2A35 FD19   add iy,de   ;;           iy points at char width
0000:2A37 FD5E00 ld e,(iy+00);;      e = char width
0000:2A3A FDE1   pop iy      ;; *~
0000:2A3C 19     add hl,de   ;; hl = total width
0000:2A3D 0B     dec bc      
0000:2A3E 18D7   jr 2A17     ;; loop
;;
;; here when bc = 0
0000:2A40 DDE1   pop ix      ;; *
0000:2A42 DD5E06 ld e,(ix+06)
0000:2A45 DD5607 ld d,(ix+07)
0000:2A48 EB     ex de,hl    ;; hl = par6,  de = total width
0000:2A49 73     ld (hl),e  
0000:2A4A 23     inc hl      
0000:2A4B 72     ld (hl),d   ;; (par6) = total width
;;
0000:2A4C D1     pop de      
0000:2A4D 7A     ld a,d      
0000:2A4E D306   out (06),a  
0000:2A50 7B     ld a,e      
0000:2A51 D305   out (05),a  
0000:2A53 C9     ret        



          [0A97] get_charwidth(font, achar)
0000:2A54 210400 ld hl,0004  
0000:2A57 39     add hl,sp   ;; HL points at sp0004  (par2) (achar)
;;
0000:2A58 DB05   in a,(05)   ;; save slot4000
0000:2A5A 5F     ld e,a      
0000:2A5B DB06   in a,(06)  
0000:2A5D E60F   and 0F      
0000:2A5F 57     ld d,a      
0000:2A60 D5     push de    
;;
0000:2A61 3E00   ld a,00     ;; put fonts in slot4000
0000:2A63 D306   out (06),a  ;; slot4000device = coderom
0000:2A65 3E04   ld a,04    
0000:2A67 D305   out (05),a  ;; slot4000page = page#04
;;
0000:2A69 7E     ld a,(hl)   ;; A = par2  (achar)
0000:2A6A FE20   cp 20      
0000:2A6C 380C   jr c,2A7A   ;; if achar < #20  then jp nonprintable  (#00 thru #1f are nonprintable)
0000:2A6E FE81   cp 81      
0000:2A70 3804   jr c,2A76   ;; if achar < #81  then jp printable     (#20 thru #80 are printable)
0000:2A72 FEA1   cp A1      
0000:2A74 3804   jr c,2A7A   ;; if achar < #A1  then jp nonprintable  (#81 thru #a0 are nonprintable)
;;                                  ;;                                       (#a1 thru #ff are printable)
;; printable
0000:2A76 D620   sub 20      ;; else subtract #20
0000:2A78 1802   jr 2A7C    
;;
;; nonprintable
0000:2A7A 3E5F   ld a,5F     ;; this is #7f - #20, iow nonprintables are changeg to char #7f
;;
0000:2A7C 5F     ld e,a      
0000:2A7D 1600   ld d,00     ;; DE is adjusted char (font position)
0000:2A7F 2B     dec hl      
0000:2A80 2B     dec hl      
0000:2A81 7E     ld a,(hl)   ;; A = par0
0000:2A82 B7     or a        
0000:2A83 2005   jr nz,2A8A  
;;
0000:2A85 210240 ld hl,4002  ;; when par0 is 0, use font 0 widths
0000:2A88 1803   jr 2A8D    
;; font not 0
0000:2A8A 21BA48 ld hl,48BA  ; Diag string?  ;; codeflash pg 4, font data.  (start of font 1, width data)
;;
0000:2A8D 19     add hl,de  
0000:2A8E 6E     ld l,(hl)  
0000:2A8F 2600   ld h,00     ;; hl = char width
;;
0000:2A91 D1     pop de      ;; restore slot4000
0000:2A92 7A     ld a,d      
0000:2A93 D306   out (06),a  
0000:2A95 7B     ld a,e      
0000:2A96 D305   out (05),a  
;;
0000:2A98 7C     ld a,h      
0000:2A99 B5     or l        
0000:2A9A C9     ret         ret char width



;;name_me(hoo, wut, wair^, wen^).  not called iffp
0000:2A9B FD210200 ld iy,0002  
0000:2A9F FD39   add iy,sp  
0000:2AA1 FD4E00 ld c,(iy+00);; C = hoo
0000:2AA4 FD4602 ld b,(iy+02);; B = wut
0000:2AA7 CD0A28 call dispatchme(B,C)   ;; dispatchme   (poss. a font look up????) (probably icon lookup)
;; above call seems to go thru a lot of machinations, to just set 3 bytes at #d410, and 4 bytes at #D442
;; I am thinking now it might have something to do with screen coords
;;
0000:2AAA FD6E04 ld l,(iy+04)
0000:2AAD FD6605 ld h,(iy+05)
0000:2AB0 3A12D4 ld a,(fontbuff.charbyteswide_or_iconheight)
0000:2AB3 77     ld (hl),a   ;; (wair^) = buff[2]   Y???
;;
0000:2AB4 FD6E06 ld l,(iy+06)
0000:2AB7 FD6607 ld h,(iy+07)
0000:2ABA 3A10D4 ld a,(fontbuff.charwidth)
0000:2ABD 77     ld (hl),a  
0000:2ABE 23     inc hl      
0000:2ABF 3A11D4 ld a,(fontbuff.charheight)
0000:2AC2 77     ld (hl),a   ;; (wen^) =       ;; buff[0]  X???
;;
0000:2AC3 3A4FD4 ld a,(lcd_bytecol) ;; sumthin  (what slot we used in dispatchme)
;;                                  ;;      0001 - code in 4000 (not OK dataflash sector)
;;                                  ;;      0010 -  ram in 8000 (OK dataflash sector)
;;                                  ;;      0100 -  ram in 8000
;;                                  ;;      1000 - data in 4000
0000:2AC6 FE01   cp 01      
0000:2AC8 CAE22A jp z,2AE2   ;; if sumthin = 1 , then we are done, just ret
;;
0000:2ACB 47     ld b,a      
0000:2ACC 3A50D4 ld a,(x0)   ;; get saved orig page# for slot we used
0000:2ACF 6F     ld l,a      
0000:2AD0 2600   ld h,00    
0000:2AD2 E5     push hl    
;;
0000:2AD3 78     ld a,b      
0000:2AD4 FE08   cp 08       ;; sumthin = #08 ?
0000:2AD6 2806   jr z,2ADE  
;;
0000:2AD8 CDF005 call Rampage!(new)   ;; Rampage(page#) sets slot8000device = ram, page = newpage, rets oldpage
0000:2ADB E1     pop hl      
0000:2ADC 1804   jr 2AE2    
;;
0000:2ADE CDFC05 call 05FC   ;; set4000datapage(page#).  sets device4000 = dataflash, page = newpage, rets oldpage
0000:2AE1 E1     pop hl      
0000:2AE2 C9     ret        

;; Table.  320 x 4 (word, byte, byte).  (lcd_buff_offset, bitmask, bitshift)
;; It maps bitcolumns to lcd buffer addresses.  The buffer offset is address
;; of the top pixel.  (By bitcolumn, I mean the X pixel coord.)
;;
;; Each byte in the buffer holds 8 horizontaly adjacent pixels, and
;; consecutive bytes in buffer are vertically adjacent.
;;
;; In other words, the first byte of the buffer holds 8 pixels, 1 for each of
;; the first 8 columns of pixels, all on the top pixel row.  The second byte
;; of the buffer holds 8 pixels from the same 8 columns, but for the second
;; row.
;;
;; Table has the buffer offset for just the top pixel in each column.  For the
;; rest of the column (y coord), you just add the y coord to the looked up
;; X offset of that top pixel.
;;
;; Each group of 4 bytes represents a single column of pixels on LCD.
;; I am gonna convert to longs, coz it's easier to hit alt-l 320 times than
;; it is to hit alt-w, alt-b, alt-b, 320 times.
;; *** Note: the lcd_buff_offset is NOT a normal "word", the byte order is
;;     reversed (the low order byte is at the higher address).
;;
;; Table.  320 x 4 (word, byte, byte).  (lcd_buff_offset, bitmask, bitshift)

          bitcolumns
0000:2AE3 00000100 defl 00010000;; First pixel column
0000:2AE7 00000201 defl 01020000;; second pixel column
0000:2AEB 00000402 defl 02040000;; etc.
0000:2AEF 00000803 defl 03080000;; etc.
0000:2AF3 00001004 defl 04100000
0000:2AF7 00002005 defl 05200000
0000:2AFB 00004006 defl 06400000
0000:2AFF 00008007 defl 07800000
0000:2B03 00800100 defl 00018000
0000:2B07 00800201 defl 01028000
0000:2B0B 00800402 defl 02048000
0000:2B0F 00800803 defl 03088000
0000:2B13 00801004 defl 04108000
0000:2B17 00802005 defl 05208000
0000:2B1B 00804006 defl 06408000
0000:2B1F 00808007 defl 07808000
0000:2B23 01000100 defl 00010001
0000:2B27 01000201 defl 01020001
0000:2B2B 01000402 defl 02040001
0000:2B2F 01000803 defl 03080001
0000:2B33 01001004 defl 04100001
0000:2B37 01002005 defl 05200001
0000:2B3B 01004006 defl 06400001
0000:2B3F 01008007 defl 07800001
0000:2B43 01800100 defl 00018001
0000:2B47 01800201 defl 01028001
0000:2B4B 01800402 defl 02048001
0000:2B4F 01800803 defl 03088001
0000:2B53 01801004 defl 04108001
0000:2B57 01802005 defl 05208001
0000:2B5B 01804006 defl 06408001
0000:2B5F 01808007 defl 07808001
0000:2B63 02000100 defl 00010002
0000:2B67 02000201 defl 01020002
0000:2B6B 02000402 defl 02040002
0000:2B6F 02000803 defl 03080002
0000:2B73 02001004 defl 04100002
0000:2B77 02002005 defl 05200002
0000:2B7B 02004006 defl 06400002
0000:2B7F 02008007 defl 07800002
0000:2B83 02800100 defl 00018002
0000:2B87 02800201 defl 01028002
0000:2B8B 02800402 defl 02048002
0000:2B8F 02800803 defl 03088002
0000:2B93 02801004 defl 04108002
0000:2B97 02802005 defl 05208002
0000:2B9B 02804006 defl 06408002
0000:2B9F 02808007 defl 07808002
0000:2BA3 03000100 defl 00010003
0000:2BA7 03000201 defl 01020003
0000:2BAB 03000402 defl 02040003
0000:2BAF 03000803 defl 03080003
0000:2BB3 03001004 defl 04100003
0000:2BB7 03002005 defl 05200003
0000:2BBB 03004006 defl 06400003
0000:2BBF 03008007 defl 07800003
0000:2BC3 03800100 defl 00018003
0000:2BC7 03800201 defl 01028003
0000:2BCB 03800402 defl 02048003
0000:2BCF 03800803 defl 03088003
0000:2BD3 03801004 defl 04108003
0000:2BD7 03802005 defl 05208003
0000:2BDB 03804006 defl 06408003
0000:2BDF 03808007 defl 07808003
0000:2BE3 04000100 defl 00010004
0000:2BE7 04000201 defl 01020004
0000:2BEB 04000402 defl 02040004
0000:2BEF 04000803 defl 03080004
0000:2BF3 04001004 defl 04100004
0000:2BF7 04002005 defl 05200004
0000:2BFB 04004006 defl 06400004
0000:2BFF 04008007 defl 07800004
0000:2C03 04800100 defl 00018004
0000:2C07 04800201 defl 01028004
0000:2C0B 04800402 defl 02048004
0000:2C0F 04800803 defl 03088004
0000:2C13 04801004 defl 04108004
0000:2C17 04802005 defl 05208004
0000:2C1B 04804006 defl 06408004
0000:2C1F 04808007 defl 07808004
0000:2C23 05000100 defl 00010005
0000:2C27 05000201 defl 01020005
0000:2C2B 05000402 defl 02040005
0000:2C2F 05000803 defl 03080005
0000:2C33 05001004 defl 04100005
0000:2C37 05002005 defl 05200005
0000:2C3B 05004006 defl 06400005
0000:2C3F 05008007 defl 07800005
0000:2C43 05800100 defl 00018005
0000:2C47 05800201 defl 01028005
0000:2C4B 05800402 defl 02048005
0000:2C4F 05800803 defl 03088005
0000:2C53 05801004 defl 04108005
0000:2C57 05802005 defl 05208005
0000:2C5B 05804006 defl 06408005
0000:2C5F 05808007 defl 07808005
0000:2C63 06000100 defl 00010006
0000:2C67 06000201 defl 01020006
0000:2C6B 06000402 defl 02040006
0000:2C6F 06000803 defl 03080006
0000:2C73 06001004 defl 04100006
0000:2C77 06002005 defl 05200006
0000:2C7B 06004006 defl 06400006
0000:2C7F 06008007 defl 07800006
0000:2C83 06800100 defl 00018006
0000:2C87 06800201 defl 01028006
0000:2C8B 06800402 defl 02048006
0000:2C8F 06800803 defl 03088006
0000:2C93 06801004 defl 04108006
0000:2C97 06802005 defl 05208006
0000:2C9B 06804006 defl 06408006
0000:2C9F 06808007 defl 07808006
0000:2CA3 07000100 defl 00010007
0000:2CA7 07000201 defl 01020007
0000:2CAB 07000402 defl 02040007
0000:2CAF 07000803 defl 03080007
0000:2CB3 07001004 defl 04100007
0000:2CB7 07002005 defl 05200007
0000:2CBB 07004006 defl 06400007
0000:2CBF 07008007 defl 07800007
0000:2CC3 07800100 defl 00018007
0000:2CC7 07800201 defl 01028007
0000:2CCB 07800402 defl 02048007
0000:2CCF 07800803 defl 03088007
0000:2CD3 07801004 defl 04108007
0000:2CD7 07802005 defl 05208007
0000:2CDB 07804006 defl 06408007
0000:2CDF 07808007 defl 07808007
0000:2CE3 08000100 defl 00010008
0000:2CE7 08000201 defl 01020008
0000:2CEB 08000402 defl 02040008
0000:2CEF 08000803 defl 03080008
0000:2CF3 08001004 defl 04100008
0000:2CF7 08002005 defl 05200008
0000:2CFB 08004006 defl 06400008
0000:2CFF 08008007 defl 07800008
0000:2D03 08800100 defl 00018008
0000:2D07 08800201 defl 01028008
0000:2D0B 08800402 defl 02048008
0000:2D0F 08800803 defl 03088008
0000:2D13 08801004 defl 04108008
0000:2D17 08802005 defl 05208008
0000:2D1B 08804006 defl 06408008
0000:2D1F 08808007 defl 07808008
0000:2D23 09000100 defl 00010009
0000:2D27 09000201 defl 01020009
0000:2D2B 09000402 defl 02040009
0000:2D2F 09000803 defl 03080009
0000:2D33 09001004 defl 04100009
0000:2D37 09002005 defl 05200009
0000:2D3B 09004006 defl 06400009
0000:2D3F 09008007 defl 07800009
0000:2D43 09800100 defl 00018009
0000:2D47 09800201 defl 01028009
0000:2D4B 09800402 defl 02048009
0000:2D4F 09800803 defl 03088009
0000:2D53 09801004 defl 04108009
0000:2D57 09802005 defl 05208009
0000:2D5B 09804006 defl 06408009
0000:2D5F 09808007 defl 07808009
0000:2D63 0A000100 defl 0001000A
0000:2D67 0A000201 defl 0102000A
0000:2D6B 0A000402 defl 0204000A
0000:2D6F 0A000803 defl 0308000A
0000:2D73 0A001004 defl 0410000A
0000:2D77 0A002005 defl 0520000A
0000:2D7B 0A004006 defl 0640000A
0000:2D7F 0A008007 defl 0780000A
0000:2D83 0A800100 defl 0001800A
0000:2D87 0A800201 defl 0102800A
0000:2D8B 0A800402 defl 0204800A
0000:2D8F 0A800803 defl 0308800A
0000:2D93 0A801004 defl 0410800A
0000:2D97 0A802005 defl 0520800A
0000:2D9B 0A804006 defl 0640800A
0000:2D9F 0A808007 defl 0780800A
0000:2DA3 0B000100 defl 0001000B
0000:2DA7 0B000201 defl 0102000B
0000:2DAB 0B000402 defl 0204000B
0000:2DAF 0B000803 defl 0308000B
0000:2DB3 0B001004 defl 0410000B
0000:2DB7 0B002005 defl 0520000B
0000:2DBB 0B004006 defl 0640000B
0000:2DBF 0B008007 defl 0780000B
0000:2DC3 0B800100 defl 0001800B
0000:2DC7 0B800201 defl 0102800B
0000:2DCB 0B800402 defl 0204800B
0000:2DCF 0B800803 defl 0308800B
0000:2DD3 0B801004 defl 0410800B
0000:2DD7 0B802005 defl 0520800B
0000:2DDB 0B804006 defl 0640800B
0000:2DDF 0B808007 defl 0780800B
0000:2DE3 0C000100 defl 0001000C
0000:2DE7 0C000201 defl 0102000C
0000:2DEB 0C000402 defl 0204000C
0000:2DEF 0C000803 defl 0308000C
0000:2DF3 0C001004 defl 0410000C
0000:2DF7 0C002005 defl 0520000C
0000:2DFB 0C004006 defl 0640000C
0000:2DFF 0C008007 defl 0780000C
0000:2E03 0C800100 defl 0001800C
0000:2E07 0C800201 defl 0102800C
0000:2E0B 0C800402 defl 0204800C
0000:2E0F 0C800803 defl 0308800C
0000:2E13 0C801004 defl 0410800C
0000:2E17 0C802005 defl 0520800C
0000:2E1B 0C804006 defl 0640800C
0000:2E1F 0C808007 defl 0780800C
0000:2E23 0D000100 defl 0001000D
0000:2E27 0D000201 defl 0102000D
0000:2E2B 0D000402 defl 0204000D
0000:2E2F 0D000803 defl 0308000D
0000:2E33 0D001004 defl 0410000D
0000:2E37 0D002005 defl 0520000D
0000:2E3B 0D004006 defl 0640000D
0000:2E3F 0D008007 defl 0780000D
0000:2E43 0D800100 defl 0001800D
0000:2E47 0D800201 defl 0102800D
0000:2E4B 0D800402 defl 0204800D
0000:2E4F 0D800803 defl 0308800D
0000:2E53 0D801004 defl 0410800D
0000:2E57 0D802005 defl 0520800D
0000:2E5B 0D804006 defl 0640800D
0000:2E5F 0D808007 defl 0780800D
0000:2E63 0E000100 defl 0001000E
0000:2E67 0E000201 defl 0102000E
0000:2E6B 0E000402 defl 0204000E
0000:2E6F 0E000803 defl 0308000E
0000:2E73 0E001004 defl 0410000E
0000:2E77 0E002005 defl 0520000E
0000:2E7B 0E004006 defl 0640000E
0000:2E7F 0E008007 defl 0780000E
0000:2E83 0E800100 defl 0001800E
0000:2E87 0E800201 defl 0102800E
0000:2E8B 0E800402 defl 0204800E
0000:2E8F 0E800803 defl 0308800E
0000:2E93 0E801004 defl 0410800E
0000:2E97 0E802005 defl 0520800E
0000:2E9B 0E804006 defl 0640800E
0000:2E9F 0E808007 defl 0780800E
0000:2EA3 0F000100 defl 0001000F
0000:2EA7 0F000201 defl 0102000F
0000:2EAB 0F000402 defl 0204000F
0000:2EAF 0F000803 defl 0308000F
0000:2EB3 0F001004 defl 0410000F
0000:2EB7 0F002005 defl 0520000F
0000:2EBB 0F004006 defl 0640000F
0000:2EBF 0F008007 defl 0780000F
0000:2EC3 0F800100 defl 0001800F
0000:2EC7 0F800201 defl 0102800F
0000:2ECB 0F800402 defl 0204800F
0000:2ECF 0F800803 defl 0308800F
0000:2ED3 0F801004 defl 0410800F
0000:2ED7 0F802005 defl 0520800F
0000:2EDB 0F804006 defl 0640800F
0000:2EDF 0F808007 defl 0780800F
0000:2EE3 10000100 defl 00010010
0000:2EE7 10000201 defl 01020010
0000:2EEB 10000402 defl 02040010
0000:2EEF 10000803 defl 03080010
0000:2EF3 10001004 defl 04100010
0000:2EF7 10002005 defl 05200010
0000:2EFB 10004006 defl 06400010
0000:2EFF 10008007 defl 07800010
0000:2F03 10800100 defl 00018010
0000:2F07 10800201 defl 01028010
0000:2F0B 10800402 defl 02048010
0000:2F0F 10800803 defl 03088010
0000:2F13 10801004 defl 04108010
0000:2F17 10802005 defl 05208010
0000:2F1B 10804006 defl 06408010
0000:2F1F 10808007 defl 07808010
0000:2F23 11000100 defl 00010011
0000:2F27 11000201 defl 01020011
0000:2F2B 11000402 defl 02040011
0000:2F2F 11000803 defl 03080011
0000:2F33 11001004 defl 04100011
0000:2F37 11002005 defl 05200011
0000:2F3B 11004006 defl 06400011
0000:2F3F 11008007 defl 07800011
0000:2F43 11800100 defl 00018011
0000:2F47 11800201 defl 01028011
0000:2F4B 11800402 defl 02048011
0000:2F4F 11800803 defl 03088011
0000:2F53 11801004 defl 04108011
0000:2F57 11802005 defl 05208011
0000:2F5B 11804006 defl 06408011
0000:2F5F 11808007 defl 07808011
0000:2F63 12000100 defl 00010012
0000:2F67 12000201 defl 01020012
0000:2F6B 12000402 defl 02040012
0000:2F6F 12000803 defl 03080012
0000:2F73 12001004 defl 04100012
0000:2F77 12002005 defl 05200012
0000:2F7B 12004006 defl 06400012
0000:2F7F 12008007 defl 07800012
0000:2F83 12800100 defl 00018012
0000:2F87 12800201 defl 01028012
0000:2F8B 12800402 defl 02048012
0000:2F8F 12800803 defl 03088012
0000:2F93 12801004 defl 04108012
0000:2F97 12802005 defl 05208012
0000:2F9B 12804006 defl 06408012
0000:2F9F 12808007 defl 07808012
0000:2FA3 13000100 defl 00010013
0000:2FA7 13000201 defl 01020013
0000:2FAB 13000402 defl 02040013
0000:2FAF 13000803 defl 03080013
0000:2FB3 13001004 defl 04100013
0000:2FB7 13002005 defl 05200013
0000:2FBB 13004006 defl 06400013
0000:2FBF 13008007 defl 07800013
0000:2FC3 13800100 defl 00018013
0000:2FC7 13800201 defl 01028013
0000:2FCB 13800402 defl 02048013
0000:2FCF 13800803 defl 03088013
0000:2FD3 13801004 defl 04108013
0000:2FD7 13802005 defl 05208013
0000:2FDB 13804006 defl 06408013
0000:2FDF 13808007 defl 07808013



; Keyscan  ;; key matrix is 8 cols x 10 rows
0000:2FE3 DB01   in a,(01)   ; Check for keypress  ;; any of the 8 columns active?
0000:2FE5 FEFF   cp FF       ; Key? -> 2FF6
0000:2FE7 200D   jr nz,2FF6  
;;
;; only when key not pressed
0000:2FE9 3AF0E5 ld a,(keyscanstate) ;; get keyscan state
0000:2FEC FE03   cp 03      
0000:2FEE 280A   jr z,2FFA   ;; stop incrementing at 3
0000:2FF0 3C     inc a       ;; inc if less than 3
0000:2FF1 32F0E5 ld (keyscanstate),a
0000:2FF4 1804   jr 2FFA    
;;
;; only when key pressed
0000:2FF6 AF     xor a      
0000:2FF7 32F0E5 ld (keyscanstate),a ;; set keyscan state = 0
;;
;; here after either of the above two
0000:2FFA 3AA1DB ld a,(p2shadow) ; P2 |= 0x03
0000:2FFD F603   or 03      
0000:2FFF D302   out (02),a  ;; turn off matrix rows 8 & 9
;;
0000:3001 3EFE   ld a,FE     ; Pull down LSB of Port 1 ;; turn off rows 1 thru 7, just row 0 on
0000:3003 D301   out (01),a  
;;
0000:3005 3AEDE5 ld a,(keycolstate) ; Read (E5EE)
0000:3008 57     ld d,a      
0000:3009 3AEEE5 ld a,(keycolstate2) ; Read (E5EF)
0000:300C 5F     ld e,a      
;;
0000:300D DB09   in a,(09)   ; Read Port 9  ;;wazziss???? bit 4 is important one.  it's power button!!!
0000:300F AA     xor d       ; XOR with (E5EE) ;; keycolstate
0000:3010 CB67   bit 4,a     ; (Test if same as last time?);;tests p9.4 , but what is it???
0000:3012 2808   jr z,301C   ;; jp if bit 4's are same
;;
;; power button col diff
0000:3014 3E10   ld a,10     ;; else, flip bit 4 of keycolstate
0000:3016 AA     xor d       ;; now it's the same!
0000:3017 32EDE5 ld (keycolstate),a
0000:301A 1835   jr 3051     ;; skip over "same"
;;
;; power button col same as keycolstate
0000:301C 7B     ld a,e      ;; the other one...
0000:301D AA     xor d       ;; keycolstate
0000:301E CB67   bit 4,a    
0000:3020 282F   jr z,3051   ;; jp if bit4 is same in both
;;
;; bit4 was diff between the two
0000:3022 CB62   bit 4,d     ;; keycolstate
0000:3024 2819   jr z,303F   ;; jp if keycolstate.4 = 1 , other = 0
;;
0000:3026 3A31D6 ld a,(flagz) ;; check flag 4
0000:3029 CB67   bit 4,a    
0000:302B 2804   jr z,3031  
;;
0000:302D CD6B0A call powerdownmode   ;; this shuts the power off
0000:3030 C9     ret        
;;
0000:3031 D5     push de    
0000:3032 1600   ld d,00    
0000:3034 1E0F   ld e,0F    
0000:3036 CD3032 call 3230   ;; put "power button up" in keybuffer
0000:3039 D1     pop de      
0000:303A B7     or a        
0000:303B 2814   jr z,3051  
0000:303D 180C   jr 304B    
;;
;; E.4 = 1 , D.4 = 0
0000:303F D5     push de    
0000:3040 1601   ld d,01    
0000:3042 1E0F   ld e,0F    
0000:3044 CD3032 call 3230   ;; put "power button down" in keybuffer
0000:3047 D1     pop de      
0000:3048 B7     or a        
0000:3049 2806   jr z,3051  
;;
0000:304B 7B     ld a,e      
0000:304C EE10   xor 10      
0000:304E 32EEE5 ld (keycolstate2),a
;;
0000:3051 3A31D6 ld a,(flagz) ;; test flag 4
0000:3054 CB67   bit 4,a    
0000:3056 201A   jr nz,3072  
0000:3058 CB5F   bit 3,a    
0000:305A 2016   jr nz,3072  
;;
;; flag4 and flag3 are not set
0000:305C 3AF0E5 ld a,(keyscanstate)
0000:305F FE03   cp 03      
0000:3061 2002   jr nz,3065  
0000:3063 1817   jr 307C     ;; jp if #03
;;
;; not #03
0000:3065 B7     or a        
0000:3066 2005   jr nz,306D  
;;
;; keyscanstate is #00
0000:3068 CDD230 call scan_keymatrix  
0000:306B 180F   jr 307C    
;;
;; not #03 or #00  (ie, it's 01 or 02????)
0000:306D CD2E31 call 312E  
0000:3070 180A   jr 307C    
;;
;; flag4 or flag3 was set
0000:3072 3AF0E5 ld a,(keyscanstate)
0000:3075 FE03   cp 03      
0000:3077 2803   jr z,307C  
;;
0000:3079 CD8730 call 3087  
;;
;; here when keyscanstate is #03, zero all keyrows
0000:307C AF     xor a      
0000:307D D301   out (01),a  ;; zero keybd rows 0 - 7
0000:307F 3AA1DB ld a,(p2shadow) ; Restore Port 2
0000:3082 E6FC   and FC      ;;zero keybd rows 8 & 9
0000:3084 D302   out (02),a  
0000:3086 C9     ret        

;; called by above
0000:3087 3AEDE5 ld a,(keycolstate)
0000:308A 57     ld d,a      
0000:308B 3AEEE5 ld a,(keycolstate2)
0000:308E 5F     ld e,a      
;;
0000:308F DB01   in a,(01)   ;; read key cols, active low
0000:3091 2F     cpl         ;; now active high
0000:3092 B7     or a        
0000:3093 2805   jr z,309A   ;; jp if none active
;;
0000:3095 FE02   cp 02      
0000:3097 2801   jr z,309A  
0000:3099 C9     ret        
;;
;; none active OR just col1 active
;; a is read cols, active hi
0000:309A AA     xor d       ;; now a is diff between saved and current states.
0000:309B CB4F   bit 1,a     ;; col1 again
0000:309D 2807   jr z,30A6   ;; jp if col1 different
;;
;; col1 was same
0000:309F 3E02   ld a,02     ;; flip col1 in saved keycolstate
0000:30A1 AA     xor d      
0000:30A2 32EDE5 ld (keycolstate),a ;; now it's different!
0000:30A5 C9     ret        
;;
;; col1 was different
0000:30A6 7B     ld a,e      
0000:30A7 AA     xor d       ;; a is diff between two saved states???
0000:30A8 CB4F   bit 1,a    
0000:30AA 2001   jr nz,30AD  ;; jp if col1 different???
;;
;; both saved col1 were same???
0000:30AC C9     ret        
;;
;; both saved col1 were different????
0000:30AD CB4A   bit 1,d    
0000:30AF 200D   jr nz,30BE  
;;
0000:30B1 D5     push de    
0000:30B2 1600   ld d,00    
0000:30B4 1E01   ld e,01    
0000:30B6 CD3032 call 3230   ;; put "back key up" in keybuffer
0000:30B9 D1     pop de      
0000:30BA B7     or a        
0000:30BB 200E   jr nz,30CB  
0000:30BD C9     ret  
;;
0000:30BE D5     push de    
0000:30BF 1601   ld d,01    
0000:30C1 1E01   ld e,01    
0000:30C3 CD3032 call 3230   ;; put "back key down" in keybuffer
0000:30C6 D1     pop de      
0000:30C7 B7     or a        
0000:30C8 2001   jr nz,30CB  
0000:30CA C9     ret        
;;
0000:30CB 7B     ld a,e      
0000:30CC EE02   xor 02      
0000:30CE 32EEE5 ld (keycolstate2),a
0000:30D1 C9     ret        


          scan_keymatrix
; Keyboard scan?
;; this makes my brane hurt.  I 'spose the reason for turning on the next row BEFORE you are done recording the
;; current one could be to let the key matrix lines stabilize, i.e. turn next on as soon as possible.
;; here when no flags set, and (#E5F1) = #03
0000:30D2 DD2105E6 ld ix,keytable1  ;; pointer ram table1, last col val for each row
0000:30D6 FD21FBE5 ld iy,keytable2  ;; pointer ram table2, key changes we want to see
0000:30DA 21F1E5 ld hl,keytable3  ;; pointer ram table3
0000:30DD 1EFD   ld e,FD     ;; keybd row mask, just 1 row active (low) at a time
0000:30DF 0607   ld b,07     ;; 7 rows???
;;
0000:30E1 DB01   in a,(01)   ;; read keybd cols for current row (0-6)
0000:30E3 F5     push af     ; Save it
0000:30E4 7B     ld a,e      ;; activate next  1 kb row (1-7)
0000:30E5 D301   out (01),a  
0000:30E7 F1     pop af      ; Restore original IN(1)
0000:30E8 CB03   rlc e       ; Rotate E ;; next row
0000:30EA CD5131 call 3151   ;; record keyboard state for a row (0-6)
0000:30ED 10F2   djnz 30E1   ; Loop 7x ;; why not all 8?? coz on 8th, the "next" row is different port!!
;;
0000:30EF DB01   in a,(01)   ;; read keybd cols for row (7)
0000:30F1 F5     push af     ; Save it
;;
0000:30F2 3EFF   ld a,FF     ; OUT(1,FFh)
0000:30F4 D301   out (01),a  ;; keyrows 0-7 off
0000:30F6 3AA1DB ld a,(p2shadow) ; P2.1=1, P2.0=0
0000:30F9 F603   or 03       ;; keyrows 8 & 9
0000:30FB E6FE   and FE      ;; no, just 8!
0000:30FD D302   out (02),a  ;; turn row 8 on
;;
0000:30FF F1     pop af      ; Restore original IN(1) ;; col val from row 7
0000:3100 CD5131 call 3151   ;; record keyboard state for row 7
;;
0000:3103 DB01   in a,(01)   ; IN(1) ;; read keybd cols for row 8
0000:3105 F5     push af     ; Save it
0000:3106 3AA1DB ld a,(p2shadow)
0000:3109 F603   or 03       ;; keyrows 8 & 9
0000:310B E6FD   and FD      ;; oh! did I say 8?  No, turn 8 off.
0000:310D D302   out (02),a  ; P2.1=0, P2.0=1 ;; turn keyrow 9 on
;;
0000:310F F1     pop af      ; Restore original IN(1);; keybd cols for row 8
0000:3110 CD5131 call 3151   ;; record keyboard state for row 8
;;
0000:3113 DB01   in a,(01)   ; IN(1);; read keybd cols for row 9
0000:3115 CD5131 call 3151   ;; record keyboard state for row 9.  Just like that?
;;                                  ;;   what about turning on row 0 for next time???
;;
0000:3118 CD6C31 call 316C   ;; best guess at this time is this checks for multiple key garbage.
0000:311B B7     or a        
0000:311C 2001   jr nz,311F  ; Zero? -> Exit
0000:311E C9     ret        
;;
;; was not 0, call 31ae, copy table 2 to table 3, and exit
0000:311F CDAE31 call 31AE  
0000:3122 21FBE5 ld hl,keytable2  ;; table 2
0000:3125 11F1E5 ld de,keytable3  ;; table 3
0000:3128 010A00 ld bc,000A  
0000:312B EDB0   ldir        ; Copy 10 bytes from E5FC to E5F2
0000:312D C9     ret        


0000:312E DD2105E6 ld ix,keytable1  ;; table 1, last col val for each row
0000:3132 FD21FBE5 ld iy,keytable2  ;; table 2
0000:3136 21F1E5 ld hl,keytable3  ;; table 3
0000:3139 060A   ld b,0A    
;;
0000:313B 3EFF   ld a,FF    
0000:313D CD5131 call 3151  
0000:3140 10F9   djnz 313B   ; Loop 10x
;;
0000:3142 CDAE31 call 31AE  
0000:3145 21FBE5 ld hl,keytable2  ; Copy 10 bytes from E5FC to E5F2   ;; table 2
0000:3148 11F1E5 ld de,keytable3  ;; table 3
0000:314B 010A00 ld bc,000A  
0000:314E EDB0   ldir        
0000:3150 C9     ret        

;; when this is called, A = the read keybd cols.
;; called from above, once for each key row.
0000:3151 DD5600 ld d,(ix+00); D = param       ;; D = table1 value  (last value for this row pos???)
0000:3154 DD7700 ld (ix+00),a; Set to IN value ;; put new value in table1
0000:3157 AA     xor d       ; D=0             ;; A = diff bet last and new  (just key changes)
0000:3158 4F     ld c,a      ; C=IN value      ;; C = diff
0000:3159 A6     and (hl)    ; Mask it         ;; A = diff AND table3 value  (just key changes we want to see)
0000:315A FD7700 ld (iy+00),a; Save at (IY)    ;; put masked diff in table2  (0 or imp diff)
0000:315D 79     ld a,c      ; Invert IN value ;; invert diff                (now 1 means not imp diff)
0000:315E 2F     cpl        
0000:315F A2     and d       ; Mask it with 0  ;; old col val, AND NOT imp diff...
0000:3160 FDB600 or (iy+00)  ; OR with (IY)    ;; ... OR it with masked diff into table2
0000:3163 FD7700 ld (iy+00),a; Write to (IY)
0000:3166 23     inc hl      ; HL++            ;; advance all 3 table pointers to next row
0000:3167 DD23   inc ix      ; IX++
0000:3169 FD23   inc iy      ; IY++
0000:316B C9     ret        

;; called from above, after all 10 key rows are recorded
0000:316C 21FBE5 ld hl,keytable2  ;; table 2 (masked changes)
0000:316F 56     ld d,(hl)  
0000:3170 23     inc hl      
0000:3171 0609   ld b,09    
;; loop
0000:3173 5E     ld e,(hl)  
0000:3174 CD9531 call 3195   ;; more_than_one_col?(D)
0000:3177 B7     or a        
0000:3178 2812   jr z,318C   ;; jump if one or less change
;;
0000:317A 7A     ld a,d      
0000:317B B3     or e        ;; or with next row
0000:317C FEFF   cp FF      
0000:317E 280C   jr z,318C  
;;
0000:3180 D5     push de    
0000:3181 57     ld d,a      
0000:3182 CD9531 call 3195   ;; more_than_one_col?(D)
0000:3185 D1     pop de      
0000:3186 B7     or a        
0000:3187 2803   jr z,318C  
0000:3189 3E00   ld a,00    
0000:318B C9     ret        
;;
0000:318C 7A     ld a,d      ; D = D & E
0000:318D A3     and e      
0000:318E 57     ld d,a      
0000:318F 23     inc hl      ; Next byte
0000:3190 10E1   djnz 3173   ; Loop B times
;;
0000:3192 3E01   ld a,01    
0000:3194 C9     ret        

;; more_than_one_col?(D)
0000:3195 C5     push bc    
0000:3196 7A     ld a,d      
0000:3197 2F     cpl         ;; now active hi
0000:3198 B7     or a        
0000:3199 280F   jr z,31AA   ;; if 0, ret a=0  (if we get past here, at least one col was active)
;;
0000:319B 0E01   ld c,01     ;; start w/ col 0
0000:319D 0608   ld b,08     ;; check all 8 cols
;;
0000:319F B9     cp c        ;; is this only one on?
0000:31A0 2808   jr z,31AA   ;; if yes, ret a=0  bc=which one
0000:31A2 CB01   rlc c      
0000:31A4 10F9   djnz 319F  
;;
0000:31A6 C1     pop bc      ;; only way to get here is if more than one col active
0000:31A7 3E01   ld a,01     ;; ret a=1
0000:31A9 C9     ret        
;;
0000:31AA C1     pop bc      
0000:31AB 3E00   ld a,00    
0000:31AD C9     ret        

;; oh i dont care, its just part of key matrix decode!!!
0000:31AE FD2104E6 ld iy,E604  
0000:31B2 DD21FAE5 ld ix,E5FA  
0000:31B6 060A   ld b,0A    
0000:31B8 2E09   ld l,09    
0000:31BA FD4E00 ld c,(iy+00)
0000:31BD DD7E00 ld a,(ix+00)
0000:31C0 A9     xor c      
0000:31C1 67     ld h,a      
0000:31C2 C5     push bc    
0000:31C3 0608   ld b,08    
0000:31C5 CB04   rlc h      
0000:31C7 305A   jr nc,3223  
0000:31C9 CB01   rlc c      
0000:31CB 3804   jr c,31D1  
0000:31CD 1601   ld d,01    
0000:31CF 1802   jr 31D3    
0000:31D1 1600   ld d,00    
0000:31D3 CB09   rrc c      
0000:31D5 7D     ld a,l      
0000:31D6 87     add a,a    
0000:31D7 87     add a,a    
0000:31D8 87     add a,a    
0000:31D9 87     add a,a    
0000:31DA B0     or b        
0000:31DB 3D     dec a      
0000:31DC 5F     ld e,a      
0000:31DD FE60   cp 60      
0000:31DF 200B   jr nz,31EC  
0000:31E1 7A     ld a,d      
0000:31E2 B7     or a        
0000:31E3 2807   jr z,31EC  
0000:31E5 3AEFE5 ld a,(anotherkeyvar)
0000:31E8 EE20   xor 20      
0000:31EA 182B   jr 3217    
0000:31EC FE80   cp 80      
0000:31EE 2804   jr z,31F4  
0000:31F0 FE96   cp 96      
0000:31F2 200F   jr nz,3203  
0000:31F4 7A     ld a,d      
0000:31F5 B7     or a        
0000:31F6 3AEFE5 ld a,(anotherkeyvar)
0000:31F9 2804   jr z,31FF  
0000:31FB CBF7   set 6,a    
0000:31FD 1818   jr 3217    
0000:31FF CBB7   res 6,a    
0000:3201 1814   jr 3217    
0000:3203 FE90   cp 90      
0000:3205 3AEFE5 ld a,(anotherkeyvar)
0000:3208 200D   jr nz,3217  
0000:320A 7A     ld a,d      
0000:320B B7     or a        
0000:320C 3AEFE5 ld a,(anotherkeyvar)
0000:320F 2804   jr z,3215  
0000:3211 CBFF   set 7,a    
0000:3213 1802   jr 3217    
0000:3215 CBBF   res 7,a    
0000:3217 32EFE5 ld (anotherkeyvar),a
0000:321A B2     or d        
0000:321B 57     ld d,a      
0000:321C C5     push bc    
0000:321D E5     push hl    
0000:321E CD3032 call 3230   ;; put DE in keybuffer
0000:3221 E1     pop hl      
0000:3222 C1     pop bc      
0000:3223 CB01   rlc c      
0000:3225 109E   djnz 31C5  
0000:3227 C1     pop bc      
0000:3228 2D     dec l      
0000:3229 DD2B   dec ix      
0000:322B FD2B   dec iy      
0000:322D 108B   djnz 31BA  
0000:322F C9     ret        

; Put key into buffer
; DE = key
; Return A=1=OK, Full=0
0000:3230 3AEBE5 ld a,(keybuffin) ; Read E5EC (index to next byte in keybuffer)
0000:3233 4F     ld c,a      ; Save it
0000:3234 3C     inc a       ; Bump it
0000:3235 E61F   and 1F      ; Rollover at 1F (5 bits max)  ;; 32 byte buffer, or 16 keys
0000:3237 47     ld b,a      ; B=A
0000:3238 3AECE5 ld a,(keybuffout) ; Read E5ED
0000:323B B8     cp b        ; Compare with bumped value
0000:323C 2814   jr z,3252   ; Same? -> 3252  ;; err if buffer full
0000:323E C5     push bc     ; Else save BC
0000:323F CB21   sla c       ; Double C  ;; keybuffer_in index
0000:3241 0600   ld b,00    
0000:3243 21ABE5 ld hl,keybuffer  ; Point to E5AC+BC
0000:3246 09     add hl,bc  
0000:3247 73     ld (hl),e   ; Save DE there
0000:3248 23     inc hl      
0000:3249 72     ld (hl),d  
0000:324A C1     pop bc      ; Restore BC
0000:324B 78     ld a,b      
0000:324C 32EBE5 ld (keybuffin),a ; Save B (rolled over value) at (E5EC) ;; keybuffer_in index
0000:324F 3E01   ld a,01    
0000:3251 C9     ret        
0000:3252 3E00   ld a,00    
0000:3254 C9     ret        



          [0A9A] getkeycodefrombuffer(wheretoputit^)
0000:3255 210200 ld hl,0002  
0000:3258 39     add hl,sp  
0000:3259 5E     ld e,(hl)   ;; de is the dest
0000:325A 23     inc hl      
0000:325B 56     ld d,(hl)  
0000:325C 3AEBE5 ld a,(keybuffin) ;; C = keybuffer_in index
0000:325F 4F     ld c,a      
0000:3260 3AECE5 ld a,(keybuffout) ;; A = keybuffer_out index
0000:3263 B9     cp c        
0000:3264 2822   jr z,3288   ;; err if buffer empty
0000:3266 FE20   cp 20      
0000:3268 301E   jr nc,3288  ;; err if keybuffer_out index out of range
0000:326A 4F     ld c,a      
0000:326B CB21   sla c       ;; C = keybuffer_out x 2
0000:326D 0600   ld b,00    
0000:326F 21ABE5 ld hl,keybuffer  ;; start of buffer
0000:3272 09     add hl,bc  
0000:3273 7E     ld a,(hl)   ;; grab keycode out of the buffer (2bytes), put it at (de)
0000:3274 12     ld (de),a  
0000:3275 23     inc hl      
0000:3276 13     inc de      
0000:3277 7E     ld a,(hl)  
0000:3278 12     ld (de),a  
0000:3279 CB39   srl c       ;; C = keybuffer_out  /2
0000:327B 79     ld a,c      
0000:327C 3C     inc a       ;; inc keybuffer_out, roll to 0 at 32
0000:327D E61F   and 1F      
0000:327F 32ECE5 ld (keybuffout),a
0000:3282 210100 ld hl,0001  
0000:3285 7C     ld a,h      
0000:3286 B5     or l        
0000:3287 C9     ret        
0000:3288 210000 ld hl,0000  
0000:328B 7C     ld a,h      
0000:328C B5     or l        
0000:328D C9     ret        


;; clear the 3 key state tables
0000:328E 3EFF   ld a,FF    
0000:3290 32F1E5 ld (keytable3),a
0000:3293 32FBE5 ld (keytable2),a
0000:3296 3205E6 ld (keytable1),a ;; table 1, last col val for each row
0000:3299 010900 ld bc,0009  
0000:329C 21F1E5 ld hl,keytable3  
0000:329F 11F2E5 ld de,E5F2  
0000:32A2 EDB0   ldir        
0000:32A4 010900 ld bc,0009  
0000:32A7 21FBE5 ld hl,keytable2  
0000:32AA 11FCE5 ld de,E5FC  
0000:32AD EDB0   ldir        
0000:32AF 010900 ld bc,0009  
0000:32B2 2105E6 ld hl,keytable1  
0000:32B5 1106E6 ld de,E606  
0000:32B8 EDB0   ldir        
0000:32BA C9     ret        



          [0A9D] init_keybuffer
0000:32BB F3     di          
0000:32BC AF     xor a      
0000:32BD 32EBE5 ld (keybuffin),a ;; zero keybuffer_in & keybuffer_out indexes.
0000:32C0 32ECE5 ld (keybuffout),a
0000:32C3 3EFF   ld a,FF    
0000:32C5 3246DA ld (kbd_last_up_keycode),a ;; (#DA46) = #FF
0000:32C8 FB     ei          
0000:32C9 C9     ret        




          [0AA0]  init_keyboard(flagz)
0000:32CA F3     di          
0000:32CB CD8E32 call 328E   ;; clear the 3 keystate tables
0000:32CE CDBB32 call init_keybuffer   ;; init_keybuffer.
;;
0000:32D1 3AEEE5 ld a,(keycolstate2)
0000:32D4 CB8F   res 1,a    
0000:32D6 32EEE5 ld (keycolstate2),a ;; reset E5EF.1
;;
0000:32D9 3AEDE5 ld a,(keycolstate)
0000:32DC CB8F   res 1,a    
0000:32DE 32EDE5 ld (keycolstate),a ;; reset E5EE.1
;;
0000:32E1 210200 ld hl,0002  ;; par0
0000:32E4 39     add hl,sp  
0000:32E5 7E     ld a,(hl)  
0000:32E6 B7     or a        
0000:32E7 200A   jr nz,32F3  ;; jp if par0 <> 0
;;
;; par0 was 0
0000:32E9 3A31D6 ld a,(flagz) ;; reset flag bits 3 & 4
0000:32EC E6E7   and E7      
0000:32EE 3231D6 ld (flagz),a
0000:32F1 FB     ei          
0000:32F2 C9     ret        
;;
;; par0 was not 0
0000:32F3 FE01   cp 01      
0000:32F5 200A   jr nz,3301  ;; jp if par0 <> 1
;;
;; par0 was 1
0000:32F7 3A31D6 ld a,(flagz) ;; set flag bit 4
0000:32FA CBE7   set 4,a    
0000:32FC 3231D6 ld (flagz),a
0000:32FF FB     ei          
0000:3300 C9     ret        
;;
;; par0 was not 1
0000:3301 FE02   cp 02      
0000:3303 2008   jr nz,330D  ; 2? D631.3=1 ;; ret if par0 <> 2
;;
;; par0 was 2
0000:3305 3A31D6 ld a,(flagz) ;; set flag bit 3
0000:3308 CBDF   set 3,a    
0000:330A 3231D6 ld (flagz),a
0000:330D FB     ei          ; Else exit
0000:330E C9     ret        




;; returns 1 when pressed, or when (#E5F1) <> #03
          [0AA3] get_powerbutton
0000:330F 3AF0E5 ld a,(keyscanstate) ; Read E5F1
0000:3312 FE03   cp 03      
0000:3314 200C   jr nz,3322  ; 3? -> (Return P9.4 != 0)
;;
;; was #03
0000:3316 DB09   in a,(09)   ;; power button bit is normally a 1
0000:3318 CB67   bit 4,a     ;; test p9.4 again , still unknown whatis???  (it's the power button!)
0000:331A 2806   jr z,3322  
;;
;; power button not pressed
0000:331C 210000 ld hl,0000  
0000:331F 7C     ld a,h      
0000:3320 B5     or l        
0000:3321 C9     ret        
;;
;; was not #03, or power button pressed
0000:3322 210100 ld hl,0001  
0000:3325 7C     ld a,h      
0000:3326 B5     or l        
0000:3327 C9     ret        

; End of keyboard routine?




;; the next several routines access some vars in _device_ 5 (my guess is the modem)
;; notice that the page is not specified, just a device of 5, so dev5 must have only 1 page.
;; Also, don't forget the caller ID chip!!!!! (callid chip is only on SOME boards.)  ((CHECK DATASHEET))
;; OK, callerid is serial interface.  And modem datasheet sez there are 8 addressable registers.  I proclaim dev5 = modem.

;; HL = Modem_receive_data().    (dev5,#4000)
          HL=Modem_receive_data
0000:3328 DB06   in a,(06)   ;; NOTE: P6 is slot4000device, not page (or bank)
0000:332A 67     ld h,a      
0000:332B 3E05   ld a,05     ;; dev5 is modem
0000:332D D306   out (06),a  
0000:332F 3A0040 ld a,(4000) ;; byte 0 of slot4000 device
0000:3332 6F     ld l,a      
0000:3333 7C     ld a,h      
0000:3334 D306   out (06),a  
0000:3336 2600   ld h,00    
0000:3338 C9     ret        

;; HL = Get_Modem_int_enable_reg().    (dev5,#4001)
          HL=Get_Modem_int_enable_reg
0000:3339 DB06   in a,(06)  
0000:333B 67     ld h,a      
0000:333C 3E05   ld a,05    
0000:333E D306   out (06),a  
0000:3340 3A0140 ld a,(4001)
0000:3343 6F     ld l,a      
0000:3344 7C     ld a,h      
0000:3345 D306   out (06),a  
0000:3347 2600   ld h,00    
0000:3349 C9     ret        

;; HL = Get_Modem_int_identify_reg().     (dev5,#4002)
          HL = Get_Modem_int_identify_reg
0000:334A DB06   in a,(06)   ;; save slot4000device
0000:334C 67     ld h,a      
0000:334D 3E05   ld a,05     ;; slot4000device = 5  (modem)
0000:334F D306   out (06),a  
0000:3351 3A0240 ld a,(4002) ;; l = (#4002)
0000:3354 6F     ld l,a      
0000:3355 7C     ld a,h      
0000:3356 D306   out (06),a  ;; restore slot4000device
0000:3358 2600   ld h,00    
0000:335A C9     ret         ;; hl = (dev5, 4002)

;; Get_Modem_control_reg().      (dev5,#4004)
          Get_Modem_control_reg
0000:335B DB06   in a,(06)  
0000:335D 67     ld h,a      
0000:335E 3E05   ld a,05    
0000:3360 D306   out (06),a  
0000:3362 3A0440 ld a,(4004)
0000:3365 6F     ld l,a      
0000:3366 7C     ld a,h      
0000:3367 D306   out (06),a  
0000:3369 2600   ld h,00    
0000:336B C9     ret        

;; Get_Modem_line_status_reg().      (dev5,#4005)
          Get_Modem_line_status_reg
0000:336C DB06   in a,(06)  
0000:336E 67     ld h,a      
0000:336F 3E05   ld a,05    
0000:3371 D306   out (06),a  
0000:3373 3A0540 ld a,(4005)
0000:3376 6F     ld l,a      
0000:3377 7C     ld a,h      
0000:3378 D306   out (06),a  
0000:337A 2600   ld h,00    
0000:337C C9     ret        

;; Get_Modem_status_reg().      (dev5,#4006)
          get_modem_status
0000:337D DB06   in a,(06)  
0000:337F 67     ld h,a      
0000:3380 3E05   ld a,05    
0000:3382 D306   out (06),a  
0000:3384 3A0640 ld a,(4006)
0000:3387 6F     ld l,a      
0000:3388 7C     ld a,h      
0000:3389 D306   out (06),a  
0000:338B 2600   ld h,00    
0000:338D C9     ret        

;; Set_Modem_int_enable_reg(new_value).    (dev5,#4001)
          Set_Modem_int_enable_reg(new_value)
0000:338E 210200 ld hl,0002  
0000:3391 39     add hl,sp  
0000:3392 6E     ld l,(hl)  
0000:3393 DB06   in a,(06)  
0000:3395 67     ld h,a      
0000:3396 3E05   ld a,05    
0000:3398 D306   out (06),a  
0000:339A 7D     ld a,l      
0000:339B 320140 ld (4001),a
0000:339E 7C     ld a,h      
0000:339F D306   out (06),a  
0000:33A1 C9     ret        

;; Set_Modem_control_reg(new_value).    (dev5,#4004)
;; outputs, active hi
;;   bit0 = dtr on
;;   bit1 = rts on
;;   bit2 = out1 (used in loopback, see datasheet)
;;   bit3 = out2 (HINT enable, see datasheet)
;;   bit4 = enable loopback
;;   bit5-7 = unused
;;
          Set_Modem_control_reg(new_value)
0000:33A2 210200 ld hl,0002  
0000:33A5 39     add hl,sp  
0000:33A6 6E     ld l,(hl)  
0000:33A7 DB06   in a,(06)  
0000:33A9 67     ld h,a      
0000:33AA 3E05   ld a,05    
0000:33AC D306   out (06),a  
0000:33AE 7D     ld a,l      
0000:33AF 320440 ld (4004),a
0000:33B2 7C     ld a,h      
0000:33B3 D306   out (06),a  
0000:33B5 C9     ret        

;; Modem_transmit_data(onebyte).    (dev5,#4000)
          Modem_transmit_data(onebyte)
0000:33B6 210200 ld hl,0002  
0000:33B9 39     add hl,sp  
0000:33BA 6E     ld l,(hl)  
0000:33BB DB06   in a,(06)  
0000:33BD 67     ld h,a      
0000:33BE 3E05   ld a,05    
0000:33C0 D306   out (06),a  
0000:33C2 7D     ld a,l      
0000:33C3 320040 ld (4000),a
0000:33C6 7C     ld a,h      
0000:33C7 D306   out (06),a  
0000:33C9 C9     ret        

; Init?   ;; init modem queue's  (recv & xmit).
          init_modem
0000:33CA 210000 ld hl,0000  
0000:33CD CDEA35 call initialize_modem_rx_queue()  
0000:33D0 CDE035 call initialize_modem_tx_queue()  
0000:33D3 3EFF   ld a,FF    
0000:33D5 321FE6 ld (modem_who),a
0000:33D8 7C     ld a,h      
0000:33D9 3229E6 ld (modem_q9),a
0000:33DC 322AE6 ld (modem_qA),a
0000:33DF 3228E6 ld (modem_q8),a
0000:33E2 3220E6 ld (modem_q2),a
0000:33E5 3221E6 ld (modem_q3),a
0000:33E8 2222E6 ld (modem_q4),hl
0000:33EB 2224E6 ld (modem_q5),hl
;;
0000:33EE 210100 ld hl,0001  ;; 1 means "enable received data available int"
0000:33F1 E5     push hl    
0000:33F2 CD8E33 call Set_Modem_int_enable_reg(new_value)  
0000:33F5 E1     pop hl      
0000:33F6 C9     ret        


          [0863]  Turn_modem_on
0000:33F7 CDBE3D call callid_off   ; Set up ports, clear some vars
0000:33FA 3E01   ld a,01    
0000:33FC 3237E6 ld (CID1),a ; E638=1
;;
0000:33FF DB06   in a,(06)  
0000:3401 F5     push af     ; Save P6  ;; slot4000device
;;
0000:3402 3AA1DB ld a,(p2shadow)
0000:3405 E6DF   and DF      
0000:3407 32A1DB ld (p2shadow),a
0000:340A D302   out (02),a  ; P2.5 = 0 ;; turn on Vcc for modem et al  (U6xx numbered ic's)
;;
0000:340C 212C01 ld hl,012C  
0000:340F E5     push hl    
0000:3410 CD5C0A call Delay(msec)   ; Delay(0x012C)
0000:3413 E1     pop hl      
;;
0000:3414 3E00   ld a,00    
0000:3416 D326   out (26),a  ; P26 = 0
;;
0000:3418 216400 ld hl,0064  
0000:341B E5     push hl    
0000:341C CD5C0A call Delay(msec)   ; Delay(0x64)
0000:341F E1     pop hl      
;;
0000:3420 3E01   ld a,01    
0000:3422 D326   out (26),a  ; P26 = 1
;;
0000:3424 21B80B ld hl,0BB8  
0000:3427 E5     push hl    
0000:3428 CD5C0A call Delay(msec)   ; Delay(0x0BB8)
0000:342B E1     pop hl      
;;
0000:342C 3E05   ld a,05     ;; select slot4000device = 5  (modem)
0000:342E D306   out (06),a  ; P6=5
;;
0000:3430 3EC7   ld a,C7    
0000:3432 320240 ld (4002),a ; (4002)=C7  ;; fifo control: rx trig = 14, no dma, clr rx & tx fifo's, enable fifo's
;;
0000:3435 3A2BE6 ld a,(modem_qB)
0000:3438 B7     or a        
0000:3439 280F   jr z,344A   ; (E62C)=0? -> Skip
;;
0000:343B 3E83   ld a,83    
0000:343D 320340 ld (4003),a ; (4003)=0x83  ;; line control: enable divisor latch access
0000:3440 3E06   ld a,06    
0000:3442 320040 ld (4000),a ; (4000)=6     ;; LSB of baud rate divisor: div by 6
0000:3445 3E00   ld a,00    
0000:3447 320140 ld (4001),a ; (4001)=0     ;; MSB of baud rate divisor
;;
0000:344A 3E03   ld a,03    
0000:344C 320340 ld (4003),a ; (4003)=3     ;; line control: disable div lat, 8bit, 1 stop, no parity
0000:344F 3A0440 ld a,(4004)
0000:3452 F60F   or 0F      
0000:3454 320440 ld (4004),a ; (4004) &= 0x0f ;; modem control: dtr & rts on, host int enabled
;;
0000:3457 0601   ld b,01     ;; enable interrupt 3.6
0000:3459 0E06   ld c,06    
0000:345B CD2F0A call set_interrupt(int#=C, enable=B)   ; Translate bit position given in C (0-7) to bit mask and apply it to A ;;set p3.6
;;
0000:345E F1     pop af      
0000:345F D306   out (06),a  ; Out 6, ??  ;; restore device in slot4000
0000:3461 CDCA33 call init_modem   ; Init?
0000:3464 C9     ret        



          [0866] Turn_modem_off
0000:3465 0600   ld b,00     ;; unschedule interrupt 3.6 (or maybe disable is a better word?)
0000:3467 0E06   ld c,06    
0000:3469 CD2F0A call set_interrupt(int#=C, enable=B)   ; Translate bit position given in C (0-7) to bit mask and apply it to A
0000:346C 3E00   ld a,00    
0000:346E D326   out (26),a  ; P26=0
0000:3470 213200 ld hl,0032  
0000:3473 E5     push hl    
0000:3474 CD5C0A call Delay(msec)   ; Delay(0x32)
0000:3477 E1     pop hl      
0000:3478 3AA1DB ld a,(p2shadow)
0000:347B F620   or 20      
0000:347D 32A1DB ld (p2shadow),a
0000:3480 D302   out (02),a  ; P2.5=1  ;; turn off Vcc for modem et al  (U6xx numbered ic's)
0000:3482 CDE83D call callid_on  
0000:3485 C9     ret        


;; putqueue(E,A).   (this is REALLY dumb.  wouldn't it be simpler to just make 2 subs, and skip the A param???????)
;; It looks like someone just kluged in a seperate recv queue!
;; But why not just call the one you want directly, 'stead of passing par???
0000:3486 B7     or a        ;; DUH!??? which queue are we gonna put E into?
0000:3487 2826   jr z,34AF   ;; if a=0, use 2k buffer at #dba8 (rx queue)
;;                                  ;; else use 512k buffer at #e3ac (tx queue)
0000:3489 2AA7E3 ld hl,(txqin)
0000:348C 4D     ld c,l      
0000:348D 44     ld b,h      ;; bc = (#e3a8) index tx q-in
;;
0000:348E 2AA9E3 ld hl,(txqout);; hl = (#e3aa) index tx q-out
0000:3491 C5     push bc    
0000:3492 03     inc bc      ;; bc = bc + 1 mod 200h  (buffer wraps at 512 bytes)
0000:3493 78     ld a,b      
0000:3494 E601   and 01      ;; 0000 0001 xxxx xxxx
0000:3496 47     ld b,a      
0000:3497 AF     xor a      
0000:3498 ED42   sbc hl,bc   ;; hl = (#e4aa) - (#e3a8)+1 mod 200h
0000:349A C1     pop bc      
0000:349B 2838   jr z,34D5   ;; if (#e4aa) = (#e3a8)+1 mod 200h , then return 0  (prob means buff full)
;;
0000:349D 21ABE3 ld hl,txqueue  ;; index buffer at #e3ac with (#e3a8)...
0000:34A0 09     add hl,bc  
0000:34A1 73     ld (hl),e   ;; ...and put E there.
0000:34A2 03     inc bc      ;; increment index
0000:34A3 78     ld a,b      ;; wrap index at 512
0000:34A4 E601   and 01      
0000:34A6 67     ld h,a      
0000:34A7 69     ld l,c      
0000:34A8 22A7E3 ld (txqin),hl;; put index away
0000:34AB 210100 ld hl,0001  ;; ret 1
0000:34AE C9     ret        
;;
;; this uses same vars as code update, but are they same uses here????? looks like may b different
0000:34AF 2AA3DB ld hl,(rxqin)
0000:34B2 4D     ld c,l      
0000:34B3 44     ld b,h      ;; bc = rx q_in buffer index
0000:34B4 2AA5DB ld hl,(rxqout);; hl = rx q_out buffer index
0000:34B7 C5     push bc    
0000:34B8 03     inc bc      ;; test if q_in increment will overrun q_out.
0000:34B9 78     ld a,b      
0000:34BA E607   and 07      ;; wrap at 2048
0000:34BC 47     ld b,a      
0000:34BD AF     xor a      
0000:34BE ED42   sbc hl,bc   ;; hl = q_out - (q_in+1 MOD 800h)
0000:34C0 C1     pop bc      ;; bc is q_in
0000:34C1 2812   jr z,34D5   ;; if q_out = (q_in+1 MOD 800h), then return 0  (buffer full)
;;
0000:34C3 21A7DB ld hl,rxqueue  ;; this is address of buffer in the update code, too
0000:34C6 09     add hl,bc   ;; index buffer with q_in
0000:34C7 73     ld (hl),e   ;; whatever is in E, put it in buffer
0000:34C8 03     inc bc      ;; increment q_in...
0000:34C9 78     ld a,b      
0000:34CA E607   and 07      ;; ...wrap at 2048...
0000:34CC 67     ld h,a      
0000:34CD 69     ld l,c      
0000:34CE 22A3DB ld (rxqin),hl;; ...and put q_in away.
0000:34D1 210100 ld hl,0001  ;; return 1
0000:34D4 C9     ret        
;;
0000:34D5 210000 ld hl,0000  
0000:34D8 C9     ret        


;; E = getqueue(A).   this is called from two places not too far down.
0000:34D9 B7     or a        ;; which queue do we take E out of?
0000:34DA 2829   jr z,3505   ;; if a=0, use buffer at #dba8
;;                                  ;; else use buffer at #e3ac
0000:34DC 2AA9E3 ld hl,(txqout); DE=(E3AA) ;; index q_out
0000:34DF EB     ex de,hl    
0000:34E0 2AA7E3 ld hl,(txqin); HL=(E3A8) ;; index q_in
0000:34E3 AF     xor a      
0000:34E4 ED52   sbc hl,de  
0000:34E6 2846   jr z,352E   ; HL=DE? -> 352E ;; ret 0 if Queue empty
;;
0000:34E8 EB     ex de,hl    ;; hl is q_out
0000:34E9 110002 ld de,0200  ; DE=0x0200
0000:34EC AF     xor a       ; A=0  ;; clear carry
0000:34ED E5     push hl     ; BC = (E3A8) ;; push q_out
0000:34EE ED52   sbc hl,de   ;; q_out - 0200h
0000:34F0 C1     pop bc      ;; bc = q_out
0000:34F1 303B   jr nc,352E  ;; if q_out >= 200h , then ret 0  (out of range???? how??????)
;;
0000:34F3 21ABE3 ld hl,txqueue  ;; index buffer at #e3ac with q_out...
0000:34F6 09     add hl,bc  
0000:34F7 5E     ld e,(hl)   ;; ...and grab E from there.
0000:34F8 03     inc bc      ;; increment q_out
0000:34F9 78     ld a,b      
0000:34FA E601   and 01      ;; wrap at 512
0000:34FC 67     ld h,a      
0000:34FD 69     ld l,c      
0000:34FE 22A9E3 ld (txqout),hl;; put q_out away
0000:3501 210100 ld hl,0001  
0000:3504 C9     ret         ;; ret 1
;; a was 0
0000:3505 2AA5DB ld hl,(rxqout)
0000:3508 EB     ex de,hl    ;; de = q_out
0000:3509 2AA3DB ld hl,(rxqin);; hl = q_in
0000:350C AF     xor a      
0000:350D ED52   sbc hl,de   ;; q_in - q_out
0000:350F 281D   jr z,352E   ;; if buffer empty, ret 0
0000:3511 EB     ex de,hl    ;; hl is q_out
0000:3512 110008 ld de,0800  
0000:3515 AF     xor a      
0000:3516 E5     push hl    
0000:3517 ED52   sbc hl,de   ;; q_out - 800h
0000:3519 C1     pop bc      ;; bc is q_out
0000:351A 3012   jr nc,352E  ;; if q_out >= 800h, then ret 0  (out of range?????)
;;
0000:351C 21A7DB ld hl,rxqueue  ;; index buffer at #dba8 with q_out...
0000:351F 09     add hl,bc  
0000:3520 5E     ld e,(hl)   ;; ...and grab E from there.
0000:3521 03     inc bc      ;; increment q_out
0000:3522 78     ld a,b      
0000:3523 E607   and 07      ;; wrap at 2048
0000:3525 67     ld h,a      
0000:3526 69     ld l,c      
0000:3527 22A5DB ld (rxqout),hl;; put q_out away
0000:352A 210100 ld hl,0001  
0000:352D C9     ret         ;; ret 1
;;
0000:352E 210000 ld hl,0000  
0000:3531 C9     ret        


          Modem_handler
;; called by isr 3.6   (also jumped/looped to from a few places below)
0000:3532 CD4A33 call HL = Get_Modem_int_identify_reg   ;; HL = Get_Modem_int_identify_reg().
0000:3535 7D     ld a,l      
0000:3536 E607   and 07      ; And #7
0000:3538 CB47   bit 0,a     ; Bit 0 isn't set? -> Exit  ;;????? no, exit if it IS set ;; 0 means int pending
0000:353A 2801   jr z,353D   ;; jump if bit 0 = 0
0000:353C C9     ret         ;; ret if bit 0 = 1  (no pending int)
;;
0000:353D FE04   cp 04       ;; 4 means it is "recv data avail" int
0000:353F 204E   jr nz,358F  ;; jump if (dev5,4002) <> #04
;;
;; here when it is "recv data avail" int, recv a byte.
0000:3541 CD2833 call HL=Modem_receive_data   ;; HL = Modem_receive_data().
0000:3544 5D     ld e,l      ;; here's where the byte gets into E!
;;
;; handle received flow control.  (check for xon or xoff chars #11 or #13)
0000:3545 7D     ld a,l      
0000:3546 FE13   cp 13      
0000:3548 2805   jr z,354F  
0000:354A FE11   cp 11      
0000:354C 2016   jr nz,3564  
;;
;; here when #11
0000:354E 3C     inc a       ;; if was was #11, now #12
;;
;; here when #13 (and #11+1)
0000:354F 67     ld h,a      
0000:3550 3A29E6 ld a,(modem_q9) ;; maybe a flag to enable/disable flow control???  why not before check???
0000:3553 B7     or a        
0000:3554 280E   jr z,3564   ;; if flag zero, don't handle
;;
0000:3556 3E0D   ld a,0D     ;; funky/crappy way to handle xon/xoff's!!!
0000:3558 94     sub h       ;; A = #0d - #13  (or #0d - #12)
0000:3559 322AE6 ld (modem_qA),a ;; #fa  (or #fb)
0000:355C 87     add a,a     ;; #f4  (or #f6)
0000:355D 3C     inc a       ;; #f5  (or #f7)   [11110101  or  11110111]
0000:355E 6F     ld l,a      ;; xon/xoff is now converted to modem command??? (hard way, IMHO)
0000:355F E5     push hl    
0000:3560 CD8E33 call Set_Modem_int_enable_reg(new_value)   ;; Set_Modem_int_enable_reg(new_value).
0000:3563 E1     pop hl      
;;
;; here when not #13/11 or after handling #13/11
0000:3564 AF     xor a       ;; a=0, means use 2k buffer at #dba8 (must be rx queue)
0000:3565 CD8634 call 3486   ;; putqueue(E,A).
0000:3568 B7     or a        ;; clear cy
0000:3569 2AA5DB ld hl,(rxqout)
0000:356C EB     ex de,hl    ;; de = q_out
0000:356D 2AA3DB ld hl,(rxqin);; hl = q_in
0000:3570 ED52   sbc hl,de   ;; hl = q_in - q_out  (num char in buff)
0000:3572 3004   jr nc,3578  ;; jp if q_in higher than q_out (not wrapped)
;;
0000:3574 010008 ld bc,0800  ;; adjust num if wrapped
0000:3577 09     add hl,bc  
;;
0000:3578 EB     ex de,hl    ;; de = num in buff
0000:3579 B7     or a        
0000:357A 214106 ld hl,0641  ;; 1601 dec
0000:357D ED52   sbc hl,de   ;; hl = 1601 - num
0000:357F 300C   jr nc,358D  ;; loop isr 3.6 if num < 1602 dec   (more than 78% full)
;;
;; set flow control, when buffer is getting full
0000:3581 210D00 ld hl,000D  ;; drops request to send
0000:3584 E5     push hl    
0000:3585 CDA233 call Set_Modem_control_reg(new_value)  
0000:3588 D1     pop de      
0000:3589 AF     xor a      
0000:358A 3230E6 ld (modem_rts_shadow),a ;; make note that rts dropped
0000:358D 18A3   jr Modem_handler     ;; loop isr 3.6
;;
;; here when it is NOT "recv data avail" int
0000:358F FE02   cp 02       ;; was it "xmit buffer empty" int?
0000:3591 209F   jr nz,Modem_handler  ;; loop isr 3.6 if not either of the two.
0000:3593 CD7D33 call get_modem_status   ;; Get_Modem_status_reg().
0000:3596 7D     ld a,l      
0000:3597 E610   and 10      ;; cts bit
0000:3599 2007   jr nz,35A2  ;; jump if clear clear to send
0000:359B AF     xor a      
0000:359C 3231E6 ld (modem_qF),a ;; reset flag if not cts
0000:359F C3B335 jp 35B3     ;; what is this jump needed for???? why not enable int here and loop???
;;
;; here when clear to send.  get a byte out of tx queue, and send it.
0000:35A2 3E01   ld a,01     ;; a=1 means use buff at #e3ac  (tx queue)
0000:35A4 CDD934 call 34D9   ;; E = getqueue(A).
0000:35A7 7C     ld a,h      
0000:35A8 B5     or l        
0000:35A9 2808   jr z,35B3   ;; zero means q was empty, skip write.
0000:35AB D5     push de    
0000:35AC CDB633 call Modem_transmit_data(onebyte)   ;; Modem_transmit_data(onebyte).
0000:35AF D1     pop de      
0000:35B0 C33235 jp Modem_handler     ;; loop isr 3.6
;;
;; here when not clear to send.  this could be just tacked on to where we jumped from
0000:35B3 2E01   ld l,01     ;; enable only "recv data avail" int
0000:35B5 E5     push hl    
0000:35B6 CD8E33 call Set_Modem_int_enable_reg(new_value)   ;; Set_Modem_int_enable_reg(new_value).
0000:35B9 AF     xor a      
0000:35BA 3228E6 ld (modem_q8),a ;; make note
0000:35BD D1     pop de      
0000:35BE C33235 jp Modem_handler     ;; loop isr 3.6
;; end of isr 3.6

          putbyte_modem_tx_queue(onebyte)
0000:35C1 210200 ld hl,0002  
0000:35C4 39     add hl,sp  
0000:35C5 5E     ld e,(hl)  
0000:35C6 3E01   ld a,01     ;; a=1 means use 512 buffer at #e3ac  (tx queue)
0000:35C8 CD8634 call 3486   ;; putqueue(E,A).
0000:35CB 7C     ld a,h      
0000:35CC B5     or l        
0000:35CD C9     ret        


          getbyte_modem_rx_queue(wheretoputit^)
0000:35CE 210200 ld hl,0002  
0000:35D1 39     add hl,sp  
0000:35D2 4E     ld c,(hl)   ; BC=param
0000:35D3 23     inc hl      
0000:35D4 46     ld b,(hl)  
0000:35D5 C5     push bc     ; Push BC
0000:35D6 AF     xor a       ;; a=0 means use 2k buffer at #dba8  (rx queue)
0000:35D7 CDD934 call 34D9   ;; E = getqueue(A).
0000:35DA C1     pop bc      ; Restore BC
0000:35DB 7B     ld a,e      
0000:35DC 02     ld (bc),a   ; (BC)=A
0000:35DD 7C     ld a,h      ; Return H|L ;; ret whatever errcode getque returned
0000:35DE B5     or l        
0000:35DF C9     ret        

          initialize_modem_tx_queue()
0000:35E0 210000 ld hl,0000  
0000:35E3 22A7E3 ld (txqin),hl; E3A8 = 0000  ;; txqin
0000:35E6 22A9E3 ld (txqout),hl; E3AA = 0000  ;; txqout
0000:35E9 C9     ret        

          initialize_modem_rx_queue()
0000:35EA 210000 ld hl,0000  
0000:35ED 22A3DB ld (rxqin),hl; DBA4 = 0000  ;; rxqin
0000:35F0 22A5DB ld (rxqout),hl; DBA6 = 0000  ;; rxqout
0000:35F3 C9     ret        

          modem_rx_queue_empty?()
0000:35F4 2AA3DB ld hl,(rxqin);; rxqin
0000:35F7 EB     ex de,hl    
0000:35F8 2AA5DB ld hl,(rxqout);; rxqout
0000:35FB AF     xor a      
0000:35FC ED52   sbc hl,de   ; DBA6=DBA4? Return 1  ;; rxqin = rxqout means q empty
0000:35FE 2806   jr z,3606   ;
0000:3600 210000 ld hl,0000  ; Return 0
0000:3603 7C     ld a,h      
0000:3604 B5     or l        
0000:3605 C9     ret        
0000:3606 210100 ld hl,0001  
0000:3609 7C     ld a,h      
0000:360A B5     or l        
0000:360B C9     ret        



          Write_dataflash_sector(pgsector, offset, n, @where)
;; ("n" is clipped to sector, "clipped n" returned in HL)
;; called lots of places, but no handle.
0000:360C DD210200 ld ix,0002  
0000:3610 DD39   add ix,sp  
0000:3612 DD5E00 ld e,(ix+00);; DE = par0
0000:3615 DD5601 ld d,(ix+01)
;;
0000:3618 2100F8 ld hl,F800  ;; hl = f800 , all the high "unused" bits of dataflash address.
0000:361B 7A     ld a,d      ;; just a note: hi bits of par0 are not valid (ie. out of range of dataflash)
;;                                  ;;   so why would they be used in calc below??  could be flag for somethin'???
0000:361C AC     xor h       ;; A = not A  (follow the hi bit)  ("bit" is "not" of hi bit of par0 )
0000:361D 07     rlca        ;; rot A left 1 bit       (hi "bit" now in lo bit , cy not important)
0000:361E 19     add hl,de   ;; hl = F800 + param      (if this carries, addr too high for dataflash)
0000:361F CE00   adc a,00    ;; if hl + de carried, inc A  (if was too high, flip "bit" )
0000:3621 0F     rrca        ;; rot A right 1 bit, lo bit to cy (is this crap about sign??? I still don't unnerstan)
0000:3622 3806   jr c,362A   ;; c must mean "in range" but above crap escapes me rite now!
;;                                  ;; Oh.  I think it is just range check
;; not in range
0000:3624 210001 ld hl,HL=0?  ;; ret hl=0100, a=01 , hl's ret val is normally: 00-ff. so this is err cond???
0000:3627 7C     ld a,h      ;; a = 1 would indicate NOT an error???  or IS error?????
0000:3628 B5     or l        ;; Seems to me that since we are returning without writing ANY bytes, hl should be 0.
0000:3629 C9     ret         ;; But that leaves the possibility that caller might keep retrying fruitlessly????
;;
;; in range
0000:362A 210000 ld hl,0000  
0000:362D DD4E04 ld c,(ix+04);; bc = par4  ("n")
0000:3630 DD4605 ld b,(ix+05)
0000:3633 78     ld a,b      
0000:3634 B1     or c        
0000:3635 2003   jr nz,363A  ;; jump if n <> 0
;;
0000:3637 7C     ld a,h      ;; else ret 0  ("n" was 0 , so were done already!)
0000:3638 B5     or l        
0000:3639 C9     ret        
;;
;; here when n<>0
0000:363A DB06   in a,(06)   ; D=P6
0000:363C 57     ld d,a      
0000:363D DB05   in a,(05)   ; E=P5
0000:363F 5F     ld e,a      
0000:3640 D5     push de     ; Save bank regs
;;
;; split address into page and sector, and clip n to sector end)
0000:3641 CDDE36 call Split_and_Clip(ix = @par0', bc = n)  
;;
;; put dataflash page #00 in slot4000
0000:3644 3E03   ld a,03     ; P6=3  ;; dataflash!!!
0000:3646 D306   out (06),a  
0000:3648 3E00   ld a,00     ; P5=0      ;; page #00 , for command
0000:364A D305   out (05),a  
;;
;; unprotect the dataflash
0000:364C 3A2358 ld a,(5823) ;; command sequence
0000:364F 3A2058 ld a,(5820)
0000:3652 3A2258 ld a,(5822)
0000:3655 3A1844 ld a,(4418)
0000:3658 3A1B44 ld a,(441B)
0000:365B 3A1944 ld a,(4419)
0000:365E 3A1A44 ld a,(441A) ;; #1A Unprotect dataflash
;;
;; Now put the page we want to write in slot4000
0000:3661 7B     ld a,e      
0000:3662 D305   out (05),a  ;; our page, from split & clip
;;
;; Copy the sector we are writing to ram buffer.
;; We need old data, coz we have to erase 256 bytes, and we
;; will need to re-write any bytes that we are not changing.
0000:3664 1E00   ld e,00     ;; d is still sector, from split & clip
0000:3666 210040 ld hl,4000  
0000:3669 19     add hl,de   ;; ptr to our sector
0000:366A E5     push hl    
0000:366B C5     push bc     ;; clipped n
;;
0000:366C 1167E6 ld de,dataflashbuff  ;; ram buffer
0000:366F 010001 ld bc,HL=0?  ;; 256 byte per sector
0000:3672 EDB0   ldir        ;; copy sector to buffer
;;
;; Now we change the bytes we need to, in the ram buffer.
0000:3674 2167E6 ld hl,dataflashbuff  
0000:3677 DD4E02 ld c,(ix+02);; par2  (offset)
0000:367A 0600   ld b,00    
0000:367C 09     add hl,bc  
0000:367D EB     ex de,hl    ;; location in buff for "write"
0000:367E DD6E06 ld l,(ix+06)
0000:3681 DD6607 ld h,(ix+07);; source of "write"
0000:3684 C1     pop bc      ;; bc = clipped n
0000:3685 C5     push bc    
0000:3686 EDB0   ldir        ;; modify the buffer
;;
;;
0000:3688 C1     pop bc      ;; bc = clipped n
0000:3689 FDE1   pop iy      ;; iy = pointer to our sector in slot4000
0000:368B C5     push bc     ;; save clipped n, we will use it as ret value
;;
;; erase the sector
0000:368C FD360020 ld (iy+00),20;; erase sector command
0000:3690 FD3600D0 ld (iy+00),D0;; erase sector command
;;
;; sectorerase_waitloop
0000:3694 FD7E00 ld a,(iy+00)
0000:3697 47     ld b,a      
0000:3698 FD7E00 ld a,(iy+00)
0000:369B B8     cp b        
0000:369C 20F6   jr nz,3694  ;; wait for command to complete
;;
;;
;; Now write the 256 bytes in ram buffer to the blanked sector.
0000:369E 2167E6 ld hl,dataflashbuff  ;; point at buffer
0000:36A1 0600   ld b,00     ;; loop 256 x    (0 means 256)
;;
;; bytewrite_loop
0000:36A3 7E     ld a,(hl)   ;; grab byte from buffer
0000:36A4 FD360010 ld (iy+00),10;; send write_byte_command
0000:36A8 FD7700 ld (iy+00),a;; now send the byte
;;
;; write_waitloop
0000:36AB FD7E00 ld a,(iy+00)
0000:36AE 5F     ld e,a      
0000:36AF FD7E00 ld a,(iy+00)
0000:36B2 BB     cp e        
0000:36B3 20F6   jr nz,36AB  ;; wait till command complete
;;
0000:36B5 23     inc hl      
0000:36B6 FD23   inc iy      
0000:36B8 10E9   djnz 36A3   ;; loop till all 256 bytes written
;;
;;
;; Now we reprotect the dataflash
0000:36BA 3E00   ld a,00     ;; page for next command
0000:36BC D305   out (05),a  
0000:36BE 3A2358 ld a,(5823) ;; command sequence
0000:36C1 3A2058 ld a,(5820)
0000:36C4 3A2258 ld a,(5822)
0000:36C7 3A1844 ld a,(4418)
0000:36CA 3A1B44 ld a,(441B)
0000:36CD 3A1944 ld a,(4419)
0000:36D0 3A0A44 ld a,(440A) ;; 0A ,  Re-protect dataflash
;;
;;
;; get clipped n off stack, and return it.
;; This always erases & writes 256 bytes, but this return value is
;; the number we *changed*
0000:36D3 E1     pop hl      ;; number of bytes written
;;
0000:36D4 D1     pop de      ;; restore slot4000
0000:36D5 7A     ld a,d      
0000:36D6 D306   out (06),a  
0000:36D8 7B     ld a,e      
0000:36D9 D305   out (05),a  
;;
0000:36DB 7C     ld a,h      
0000:36DC B5     or l        
0000:36DD C9     ret        
;; end of Write_dataflash




          Split_and_Clip(ix = @par0', bc = n)
;; returns d = sector, e = page, and bc = clipped n
;;
;; okay, this is same as in update code.  It is for addressing dataflash.  par0' is upper 2 bytes of address,
;; par2' is third byte.  Called by "write_dataflash" (above) , and also "read_dataflash" (just below us here).
;; I am calling it "split and clip", because it splits hi two bytes of 24 bit address into page:sector, and it
;; also limits "n" to be no greater than the number of bytes before the end of the selected sector.
;; I imagine it is used to let read/writes that would cross sector boundaries, be done in two or more parts.
;; Although this is "CALLed", the params are the params of the caller, designated with prime (').
;;  bc = par4' ("n") on call, and "clipped n" on ret
0000:36DE DD5E02 ld e,(ix+02);; de = par2'   (ix points at par0' , so, ix+2 is par2')
0000:36E1 1600   ld d,00     ;; (e is low byte of three in dataflsh arddress.  this is offset in sector)
0000:36E3 210001 ld hl,HL=0?  
0000:36E6 AF     xor a      
0000:36E7 ED52   sbc hl,de   ;; hl = #0100 - par2'  (number of bytes before end of sector)
0000:36E9 E5     push hl    
0000:36EA ED42   sbc hl,bc   ;; hl - bc , cy if bc bigger  (compare "n" to num byte before e.o.s.)
0000:36EC E1     pop hl      
0000:36ED 3002   jr nc,36F1  ;; skip next 2 if hl >= bc    (limit "n" to num of bytes before e.o.s.)
0000:36EF 4D     ld c,l      
0000:36F0 44     ld b,h      
;; at this point, bc is either "n", or number of bytes till end of sector, whichever is lower.
;;
;; now, split high two bytes of 24 bit address into page#, and sector#
0000:36F1 DD5E00 ld e,(ix+00);; de = par0 [07fe]  (00000111 11111110)
0000:36F4 DD5601 ld d,(ix+01)
0000:36F7 210600 ld hl,0006  
0000:36FA CD3705 call hl=de_srl_hl   ;; HL = par0 shifted right 6 bits  (00000000 00011111) [001f]
0000:36FD 5D     ld e,l      ;;  [e = 1f]    (e is page number)
;;
0000:36FE DD7E00 ld a,(ix+00);; [fe]
0000:3701 E63F   and 3F      ;; [3e]
0000:3703 57     ld d,a      ;; [d = 3e]     (d is sector number)
;;
0000:3704 C9     ret         ;; [de = 3e1f]




          Read_dataflash_sector(pgsector, offset, n, @where)
;; ("n" is clipped to sector, "clipped n" returned in HL)
;; pgsector is upper two of three byte address, offset is lo byte.
;; NOTE: pgsector is not 1 byte of each, it is 6 bits of each, rammed into lo 12 bits of word.
;;   ******* There is a better read function, "Read_dataflash_unclipped", handle [0905] ********
;; This one is called several places, but has no handle.
0000:3705 DD210200 ld ix,0002  
0000:3709 DD39   add ix,sp  
0000:370B DD5E00 ld e,(ix+00);; de = par0
0000:370E DD5601 ld d,(ix+01)
0000:3711 2100F8 ld hl,F800  ;; hl = f800
0000:3714 7A     ld a,d      
0000:3715 AC     xor h       ;; a = hi(par0) xor #F8
0000:3716 07     rlca        ;; rot a left 1
0000:3717 19     add hl,de  
0000:3718 CE00   adc a,00    
0000:371A 0F     rrca        
0000:371B 3806   jr c,3723   ;; jp if in range
;;
0000:371D 210001 ld hl,HL=0?  ;; ret #0100  (what does 0100 mean???   out of range???)
0000:3720 7C     ld a,h      ;; A = 0 means err
0000:3721 B5     or l        
0000:3722 C9     ret        
;; in range
0000:3723 210000 ld hl,0000  
0000:3726 DD4E04 ld c,(ix+04);; bc = par4 [0002] ("n")
0000:3729 DD4605 ld b,(ix+05)
0000:372C 78     ld a,b      
0000:372D B1     or c        
0000:372E 282E   jr z,375E   ;; if n = 0 , ret hl = 0 , (we're done)
0000:3730 DB06   in a,(06)  
0000:3732 57     ld d,a      
0000:3733 DB05   in a,(05)  
0000:3735 5F     ld e,a      
0000:3736 D5     push de     ;; push banks

0000:3737 CDDE36 call Split_and_Clip(ix = @par0', bc = n)   ;; split_and_clip  (split address into page and sector, and clip n to sector end)

0000:373A 3E03   ld a,03     ;; dataflash
0000:373C D306   out (06),a  
0000:373E 7B     ld a,e      ;; our page
0000:373F D305   out (05),a  

0000:3741 1E00   ld e,00    
0000:3743 210040 ld hl,4000  
0000:3746 19     add hl,de   ;; our sector, + window offset   (pointer to our sector)

0000:3747 DD5E02 ld e,(ix+02);; add third byte of address (point at our data in sector)
0000:374A 1600   ld d,00    
0000:374C 19     add hl,de  

0000:374D DD5E06 ld e,(ix+06);; par6 is dest
0000:3750 DD5607 ld d,(ix+07)
0000:3753 C5     push bc     ;; save clipped "n"
0000:3754 EDB0   ldir        ;; move data ("read" dataflash)

0000:3756 E1     pop hl      ;; HL = "clipped n" for return
0000:3757 D1     pop de      
0000:3758 7A     ld a,d      
0000:3759 D306   out (06),a  
0000:375B 7B     ld a,e      
0000:375C D305   out (05),a  
0000:375E 7C     ld a,h      
0000:375F B5     or l        
0000:3760 C9     ret        
;; end of read_dataflash



;; This is the business-end of Read_dataflash [#0905], and also
;; read_codeflash & read_ram.
;; It reads the dataflash in larger chunks, even across page boundaries.
;; This routine has 3 entry points a litle farther down, each to select a diferent device,
;; but the one for dataflash seems to be only one called [0905].  If you think of dataflash as a disklike device, the
;; other two entrypoints [both handle-less], would be code_rom_disk, and ramdisk!!!???????
;;
;; par's:
;; #D410      par7 par6     @where   (a buffer)
;; #0002      par5 par4     n
;; #0002      xxxx par2     hi addr (byte)
;; #0900/2100 par1 par0     mid addr (byte) lo addr (byte)offset
;;
0000:3761 C5     push bc     ; Save BC
0000:3762 DD210400 ld ix,0004  ;; 4, compensates for push, above (and ret addr).
0000:3766 DD39   add ix,sp  
0000:3768 DD4E04 ld c,(ix+04);; par4  ("n")
0000:376B DD7E05 ld a,(ix+05)
0000:376E B1     or c        
0000:376F 286B   jr z,37DC   ;; if n = 0 , were done, cleanup, & ret A = 0
;;
;;    oooK!!!  this address is passed different than others I've seen in elsewhere in this thing!!!!
;; instead of par1par0:par2, with par1~par0 being the high two bytes of address (page:sector), and par2 being :offset,
;; this time its par2~par1~par0, with par2_par1 being  high  "    "    "    "       "    "      and par0 being :offset.
;;
0000:3771 DD5E01 ld e,(ix+01);; par1
0000:3774 DD5602 ld d,(ix+02);; par2   DE is page:sector
;;
0000:3777 210600 ld hl,0006  
0000:377A CD3705 call hl=de_srl_hl   ; hl = Shift DE right 6 times, hl is page now.
;;
0000:377D DD7E01 ld a,(ix+01);; A = pp:sector  (lo 2 bits of page, 6 bits sector)
0000:3780 E63F   and 3F      ;; squash two bits of page
0000:3782 47     ld b,a      ;; B is just sector now
0000:3783 DD4E00 ld c,(ix+00);; BC is sector:offset (still needs window offset before it points to data)
;;
0000:3786 DB06   in a,(06)   ;; save bank
0000:3788 57     ld d,a      
0000:3789 DB05   in a,(05)  
0000:378B 5F     ld e,a      
0000:378C D5     push de    
;;
0000:378D 3A54E6 ld a,(dev2read) ;; select device picked on entry
0000:3790 D306   out (06),a  
0000:3792 E5     push hl     ;; **********push our page
0000:3793 7D     ld a,l      
0000:3794 D305   out (05),a  ;; select our page
;;
0000:3796 59     ld e,c      ;; de is sector:offset
0000:3797 50     ld d,b      
0000:3798 D5     push de     ;; ************push sector:offset
0000:3799 210000 ld hl,0000  
0000:379C E5     push hl     ;; ************push #0000 (will be excess n, if any)
0000:379D DD4E04 ld c,(ix+04);; bc is "n"
0000:37A0 DD4605 ld b,(ix+05)
0000:37A3 C5     push bc     ;; ************push "n"
0000:37A4 210040 ld hl,4000  
0000:37A7 AF     xor a      
0000:37A8 ED52   sbc hl,de  
0000:37AA EB     ex de,hl    ;; de is   4000 - S:O      (bytes till end)
0000:37AB 60     ld h,b      
0000:37AC 69     ld l,c      
0000:37AD AF     xor a      
0000:37AE ED52   sbc hl,de   ;; hl = "n" - (bytes til end)
0000:37B0 3804   jr c,37B6   ;; carry means don't need to clip   (n fits in cuurent page)
;; clip
0000:37B2 C1     pop bc      ;; lose unclipped n   (here we clip to bank window, not sector size!!!!!!!)
0000:37B3 C1     pop bc      ;; lose #0000
0000:37B4 E5     push hl     ;; push excess n
0000:37B5 D5     push de     ;; push clipped n
;; skip to after clip
0000:37B6 C1     pop bc      ;; now bc = n (possibly clipped)
0000:37B7 E1     pop hl      ;;     hl = excess n
0000:37B8 D1     pop de      ;;     de = sector:offset
0000:37B9 E5     push hl     ;; save excess n
0000:37BA 210040 ld hl,4000  ;; add window offset
0000:37BD 19     add hl,de   ;; now hl is pointer to selected device:page:sector:offset  (source is dataflash)
0000:37BE DD5E06 ld e,(ix+06)
0000:37C1 DD5607 ld d,(ix+07);; de = par6  (@where is dest)
0000:37C4 EDB0   ldir        ;; now copy the data!!!  (the point of all that, after all!!!)
;;
0000:37C6 C1     pop bc      ;; BC is excess n
0000:37C7 E1     pop hl      ;; hl is our page again
0000:37C8 78     ld a,b      
0000:37C9 B1     or c        
0000:37CA 2809   jr z,37D5   ;; if no excess, were done,
0000:37CC 23     inc hl      ;; else select next page...
0000:37CD 7D     ld a,l      
0000:37CE D305   out (05),a  
0000:37D0 210040 ld hl,4000  ;; ...point at start of that page...
0000:37D3 EDB0   ldir        ;; ... and finish copying the data!!!
;; done
0000:37D5 D1     pop de      ;; restore banks
0000:37D6 7A     ld a,d      
0000:37D7 D306   out (06),a  
0000:37D9 7B     ld a,e      
0000:37DA D305   out (05),a  
0000:37DC C1     pop bc      ;; restore BC
0000:37DD C9     ret        


          [08FF] Write_dataflash_Lastsector(offset, n, @where)
;;
;; This only writes within the very last 256 bytes of dataflash.
;; So far, the only things I found in this sector are a mode flag, and the serial number.
;;
;; Mode flag is 4 bytes at (1f:3f:00), and observed values are:
;;    #19720514 = "test mode"       (remembers thru power cycle)
;;    #54831245 = "test over"       (this is normal mode, at least after you test.  mine has this)
;;    #93544359 = "code reflashing" (while reflashing)
;;    #58738753 = "code_reflashed"  (after success reflash)
;; Serial number is 16 bytes at (1f:3f:c8)
;;
0000:37DE DD210200 ld ix,0002  
0000:37E2 DD39   add ix,sp  
0000:37E4 DD6E04 ld l,(ix+04);; par4     (@where)
0000:37E7 DD6605 ld h,(ix+05)
0000:37EA E5     push hl    
0000:37EB DD6E02 ld l,(ix+02);; par2     (n)
0000:37EE 2600   ld h,00    
0000:37F0 E5     push hl    
0000:37F1 DD6E00 ld l,(ix+00);; par0     (offset)
0000:37F4 E5     push hl    
0000:37F5 21FF07 ld hl,07FF  ;; fixed    (pgsector)  (page 1f, sector 3f, the last page, last sector of dataflash)
0000:37F8 E5     push hl    
0000:37F9 CD0C36 call Write_dataflash_sector(pgsector, offset, n, @where)   ;; Write_dataflash_sector(pgsector, offset, n, @where).
0000:37FC E1     pop hl      
0000:37FD E1     pop hl      
0000:37FE E1     pop hl      
0000:37FF E1     pop hl      
0000:3800 C9     ret        



          [0902] Read_dataflash_Lastsector(offset, n, @where)
;; This only reads within the very last 256 bytes of dataflash.  (see above)
;; rets HL = clipped n
0000:3801 DD210200 ld ix,0002  
0000:3805 DD39   add ix,sp  
0000:3807 DD6E04 ld l,(ix+04);; par4     (@where)
0000:380A DD6605 ld h,(ix+05)
0000:380D E5     push hl    
0000:380E DD6E02 ld l,(ix+02);; par2     (n)
0000:3811 2600   ld h,00    
0000:3813 E5     push hl    
0000:3814 DD6E00 ld l,(ix+00);; par0     (offset)
0000:3817 E5     push hl    
0000:3818 21FF07 ld hl,07FF  ;; fixed    (pgsector)  (page 1f, sector 3f, the last page, last sector of dataflash)
0000:381B E5     push hl    
0000:381C CD0537 call Read_dataflash_sector(pgsector, offset, n, @where)   ;; Read_dataflash_sector(pgsector, offset, n, @where)
0000:381F E1     pop hl      
0000:3820 E1     pop hl      
0000:3821 E1     pop hl      
0000:3822 E1     pop hl      ;; hl is clipped n
0000:3823 C9     ret        


;; Read_dataflash_unclipped(page:sector:offset, n, @where)
;;    page:sector:offset is 24 bit address as a long (actually just 20 bits of 3 bytes),
;;    Or, as two words, (lo2bitsofpage:sector:offset, hi4bitsofpage, n ,@where)
;;  called from [2875] and [28c9], and a few in pg 2e, thru handle,
;; and several places in pg #32 call directly
          [0905] Read_dataflash(page:sector:offset, n, @where)
0000:3824 3E03   ld a,03    
0000:3826 3254E6 ld (dev2read),a ; E655 = 3  ;; dataflash (used for device select after jump)
0000:3829 C36137 jp 3761    


;; unused??? Nope, there are 2 farcalls here in page #2e.  
;;
;; It looks like a mistake at first, making farcall to page #00 when it
;; is *always* available directly in slot0000.  But the effect is to put
;; the "far page" into slot4000, and then, since "far offset" is less than
;; #4000, the call comes *here*.  The far page is then read as data????
;;
;; This really is silly, though.  This routine will handle swapping *any*
;; page in by itself, regardless if it is already there!!!  So, the overhead
;; of the farcall saving/swaping the pages is *wasted*.  Hmmmmmmmm.....
;; Not to mention that the param will select which page to use, regardless
;; of what the farcall slammed in there.  So, I guess this does qualify as a
;; mistake!  But it works, it's just inefficient.  Though it *does*
;; illustrate a technique that *could* be used.
;;
          Read_codeflash(page:sector:offset, n, @where)
0000:382C 3E00   ld a,00     ; E655 = 0  ;; would be codeflash, if ever used.
0000:382E 3254E6 ld (dev2read),a
0000:3831 C36137 jp 3761    


;; unused?????
          Read_ram()
0000:3834 3E01   ld a,01    
0000:3836 3254E6 ld (dev2read),a ; E655 = 1  ;; would be ram, if ever used.
0000:3839 C36137 jp 3761    



0000:383C DD210200 ld ix,0002  
0000:3840 DD39   add ix,sp  
0000:3842 DD6E04 ld l,(ix+04)
0000:3845 DD6605 ld h,(ix+05)
0000:3848 1167E7 ld de,file_bookmark_buffer  ; Copy FA bytes from pointer to E768
0000:384B 01FA00 ld bc,pg33  
0000:384E EDB0   ldir        
0000:3850 21E979 ld hl,79E9  
0000:3853 C3F400 jp 32:79E9     ; CB9E9

0000:3856 DD210200 ld ix,0002  
0000:385A DD39   add ix,sp  
0000:385C DD6E00 ld l,(ix+00)
0000:385F DD6601 ld h,(ix+01)
0000:3862 1167E6 ld de,dataflashbuff  ; Copy EC bytes from pointer to E668
0000:3865 01EC00 ld bc,00EC  
0000:3868 EDB0   ldir        
0000:386A 219B79 ld hl,799B  
0000:386D C3F400 jp 32:799B     ; CB9E9




;;  This is the first code to execute after reboot.  (copied here 'cause I'm
;;  tired of going back to see just what happens before Calling #3870)
;;
;;  DI
;;  LD      SP,#FFF0    
;;  IM      1
;;  CALL    #3870        ;; clears most of ram, among (lotsa) other things.
;;  LD      HL,#4000     ; More init/check for flash reprog (18000)
;;  JP      #0054        ; JP $18000

; Called shortly after reset        
          Init:
0000:3870 11FDFF ld de,FFFD  ;; local: sp0008-sp000A   ;; -3,  3 bytes of locals
0000:3873 CD6B05 call localize   ;;  par: sp000F   ;; LOCALIZE (creates space for local vars)
;;
0000:3876 2A44DA ld hl,(DA44);; preserve #DA44 & #DA45 thru reboots.
;; What is???  My best guess is Flag, with pattern indicating ram ok,
;; or garbage indicating "bootstate" var is invalid.
0000:3879 EB     ex de,hl    
0000:387A 210900 ld hl,0009  ;; sp0009 = ramvalid?      
0000:387D 39     add hl,sp  
0000:387E 73     ld (hl),e  
0000:387F 23     inc hl      
0000:3880 72     ld (hl),d  
;;
0000:3881 3A32D6 ld a,(bootstate) ;; ??? on powerup, and set to #5A before reboot at c519 (exit test???)
0000:3884 2B     dec hl      
0000:3885 2B     dec hl      
0000:3886 77     ld (hl),a   ;; sp0008 = "BootState" save
;;
0000:3887 21003C ld hl,3C00  
0000:388A E5     push hl     ;; push #3C00  (n)  ;; shorten to 1c00 to leave debug intact. (C000-DC00)
0000:388B 65     ld h,l      ;; maybe need to zero a few more after debug???
0000:388C E5     push hl     ;; push #0000  (fill byte)  ;; the putative callid buffer is #DBA8 to #E2C3.  So,
0000:388D 26C0   ld h,C0     ;; really should zero from #E2C4 to #FBFF.
0000:388F E5     push hl     ;; push #C000  (strt addr)
0000:3890 CDA805 call memfill(dst,val,n)   ;; memfill (#c000, #00, #3c00) ;;zero c000-fbff,ie zero all the high ram excpt stack??
0000:3893 D1     pop de      ;; all of current #c000 page of ram except last 1024 bytes, prob just skiping stack???
0000:3894 D1     pop de      ;; there are 7 pages of ram swapped out, and not cleared!!!
0000:3895 D1     pop de      
;;
0000:3896 CD2B1B call The_Loadout   ; Init ports and mem locs
0000:3899 CD7F0A call LCD_on   ; Set P2.7 ;; TURN ON LCD (power, or just enables???)
0000:389C CD850A call Clear_LCD   ; Clear LCD
;;
;; This next call to init_dataflash defeats the purpose of leaving
;; the first 4 pages un-erased during code updating, doesn't it???
;; Or maybe the int service routine calls the update test???
;;
0000:389F 210100 ld hl,0001  ;;     (#0000)
0000:38A2 E5     push hl    
0000:38A3 CDE108 call init_dataflash(command)   ; call c9948  
0000:38A6 D1     pop de      
;;
0000:38A7 210900 ld hl,0009  ; Restore regs
0000:38AA 39     add hl,sp  
0000:38AB 5E     ld e,(hl)  
0000:38AC 23     inc hl      
0000:38AD 56     ld d,(hl)  
0000:38AE ED5344DA ld (DA44),de;; restore ramvalid flag
0000:38B2 2B     dec hl      
0000:38B3 2B     dec hl      
0000:38B4 7E     ld a,(hl)  
0000:38B5 3232D6 ld (bootstate),a ;; restore "BootState"
0000:38B8 C9     ret        



;; this is called from a bazillion places.
;;
;; This is a wrapper for the "damnlong" function.
;; The first par is a pointer to a record with what seems to be several x/y
;; coords in it
;; OK, its a pointer to one of the records that I have dubbed "thingy".
;; This is converting window coord to absolute screen coords.
;;
          [0704] draw_string_wc(thingyptr, x, y, string^, n)
0000:38B9 210A00 ld hl,000A  ;; par8  (n)
0000:38BC 39     add hl,sp  
0000:38BD 5E     ld e,(hl)  
0000:38BE 23     inc hl      
0000:38BF 56     ld d,(hl)  
0000:38C0 D5     push de     ;; [-2] push n
;;
0000:38C1 2B     dec hl      
0000:38C2 2B     dec hl      
0000:38C3 56     ld d,(hl)  
0000:38C4 2B     dec hl      
0000:38C5 5E     ld e,(hl)  
0000:38C6 D5     push de     ;; [-4] push string^
;;
0000:38C7 210600 ld hl,0006  ;; sp0002  (par0)
0000:38CA 39     add hl,sp  
0000:38CB 5E     ld e,(hl)  
0000:38CC 23     inc hl      
0000:38CD 56     ld d,(hl)  
0000:38CE EB     ex de,hl    
0000:38CF 23     inc hl      
0000:38D0 23     inc hl      
0000:38D1 5E     ld e,(hl)  
0000:38D2 23     inc hl      
0000:38D3 56     ld d,(hl)   ;; de = (par0 + 2)
;;
0000:38D4 210A00 ld hl,000A  ;; sp0006   (par4)
0000:38D7 39     add hl,sp  
0000:38D8 7E     ld a,(hl)  
0000:38D9 23     inc hl      
0000:38DA 66     ld h,(hl)  
0000:38DB 6F     ld l,a      
0000:38DC 19     add hl,de   ;; hl = par4 + thingy.ya
0000:38DD E5     push hl     ;; [-6]                          (y)
;;
0000:38DE 210800 ld hl,0008  ;; sp0002   (par0)
0000:38E1 39     add hl,sp  
0000:38E2 5E     ld e,(hl)  
0000:38E3 23     inc hl      
0000:38E4 56     ld d,(hl)  
0000:38E5 EB     ex de,hl    
0000:38E6 5E     ld e,(hl)  
0000:38E7 23     inc hl      
0000:38E8 56     ld d,(hl)   ;; de = (par0)
;;
0000:38E9 210A00 ld hl,000A  ;; sp0004   (par2)
0000:38EC 39     add hl,sp  
0000:38ED 7E     ld a,(hl)  
0000:38EE 23     inc hl      
0000:38EF 66     ld h,(hl)  
0000:38F0 6F     ld l,a      
0000:38F1 19     add hl,de  
0000:38F2 E5     push hl     ;; [-8] push par2 + thingy.xa       (x)
;;
0000:38F3 210A00 ld hl,000A  ;; sp0002    (par0)
0000:38F6 39     add hl,sp  
0000:38F7 5E     ld e,(hl)  
0000:38F8 23     inc hl      
0000:38F9 56     ld d,(hl)  
0000:38FA D5     push de     ;; [-A] push par0
;;
0000:38FB CD0439 call damnlong(thingyptr, x, y, string^, n)   ;; call one damn long routine
0000:38FE 210A00 ld hl,000A  
0000:3901 39     add hl,sp  
0000:3902 F9     ld sp,hl    
0000:3903 C9     ret        



;; Start of one damn long routine.  what it does I know not.  
;; only call is from about five lines above.  I now think it is clipping the
;; front end of a string to left edge of a window, or something like that.
;; It also is checking if start coord is above/below/right of the box, in
;; which case it clips the whole string.  Relies on the next call in chain to
;; clip the bottom and end of the sting to the box bottom and right edge.
;;
;; If string starts even one pixel above box, it will not be displayed (It
;; will not clip the top, and draw the bottom portion).
;;
;; x & y are absolute screen coords.  And it has had this name so long, that
;; I am gonna leave it.  :-)  
;; It's only called from the wrapper directly above, which now has a more
;; descriptive name.
;;
          damnlong(thingyptr, x, y, string^, n)
;; this first param is in format that is showing up a lot.  I am calling it
;; a "thingy".  Here are some of the early inklings of what a thingy is:
;; guesses         box?? x  y
;; par0^.0  par0^.2  .4  .6  .8  .A   .xC  .0E_y0  .10_x1  .12_y1
;;                               font  x0   y0     x1      y1
;; see somethingy at [0100:d633]
;; or init_thingy at [0737] for more.
;;
0000:3904 11F3FF ld de,FFF3  ;; local: sp0008-sp0014
0000:3907 CD6B05 call localize   ;;  par: sp0019, sp001b, sp001d, sp001f, sp0021
;;
;; First, we check if the string starts above, below, or to right of the box.
;; If it does, then the whole string is outside of the box, and we just ret.
0000:390A 211900 ld hl,0019  
0000:390D 39     add hl,sp  
0000:390E 5E     ld e,(hl)  
0000:390F 23     inc hl      
0000:3910 56     ld d,(hl)   de = par0
;;
0000:3911 210E00 ld hl,000E  
0000:3914 19     add hl,de  
0000:3915 5E     ld e,(hl)  
0000:3916 23     inc hl      
0000:3917 56     ld d,(hl)   ;; de = (par0 + 000e)    (thingy.box.y0)
;;
0000:3918 211D00 ld hl,001D  
0000:391B 39     add hl,sp  
0000:391C 7E     ld a,(hl)  
0000:391D 23     inc hl      
0000:391E 66     ld h,(hl)  
0000:391F 6F     ld l,a      ;; hl = par4         (y)
;;
0000:3920 CD3D01 call HL<DE?   ;; y < y0 ?
0000:3923 C0     ret nz      ;; above box, clip it all!
;;
0000:3924 211900 ld hl,0019  
0000:3927 39     add hl,sp  
0000:3928 5E     ld e,(hl)  
0000:3929 23     inc hl      
0000:392A 56     ld d,(hl)   ;; de = par0
;;
0000:392B 211200 ld hl,0012  
0000:392E 19     add hl,de  
0000:392F 5E     ld e,(hl)  
0000:3930 23     inc hl      
0000:3931 56     ld d,(hl)   ;; de = y1
;;
0000:3932 211D00 ld hl,001D  
0000:3935 39     add hl,sp  
0000:3936 7E     ld a,(hl)  
0000:3937 23     inc hl      
0000:3938 66     ld h,(hl)  
0000:3939 6F     ld l,a      ;; hl = y
;;
0000:393A CD3C01 call HL>DE?   ;; y > y1 ?
0000:393D C0     ret nz      ;; below box, clip it all
;;
0000:393E 211900 ld hl,0019  
0000:3941 39     add hl,sp  
0000:3942 5E     ld e,(hl)  
0000:3943 23     inc hl      
0000:3944 56     ld d,(hl)   ;; de = par0
;;
0000:3945 211000 ld hl,0010  
0000:3948 19     add hl,de  
0000:3949 5E     ld e,(hl)  
0000:394A 23     inc hl      
0000:394B 56     ld d,(hl)   de = (par0 + 0010)         (x1)
;;
0000:394C 211B00 ld hl,001B  
0000:394F 39     add hl,sp  
0000:3950 7E     ld a,(hl)  
0000:3951 23     inc hl      
0000:3952 66     ld h,(hl)  
0000:3953 6F     ld l,a      ;; hl = sp001b   (par2)     (x)
;;
0000:3954 CD3C01 call HL>DE?   ;; x > x1 ?  
0000:3957 C0     ret nz      ;; to right of box, clip it all
;;
;; ok, those were the easy ones.  But when string is to left of box,
;; we need to fig out if *any* part of the string is in the box.  
;;
;; Advance x by charwidths until in box, or string ends.
0000:3958 211200 ld hl,0012  ;; sp0012   (i = 0)
0000:395B 39     add hl,sp  
0000:395C 3600   ld (hl),00  ; V12 = 0000
0000:395E 23     inc hl      
0000:395F 3600   ld (hl),00  
0000:3961 186E   jr 39D1    
;;
;; loop   for i=0 to n
0000:3963 211900 ld hl,0019  
0000:3966 39     add hl,sp  
0000:3967 5E     ld e,(hl)  
0000:3968 23     inc hl      
0000:3969 56     ld d,(hl)   ; DE = v19  ;; (par0)
;;
0000:396A 210C00 ld hl,000C  
0000:396D 19     add hl,de  
0000:396E 5E     ld e,(hl)  
0000:396F 23     inc hl      
0000:3970 56     ld d,(hl)   ; DE=(v19+C)  ;; de = x0
;;
0000:3971 211B00 ld hl,001B  ;; par2               x
0000:3974 39     add hl,sp  
0000:3975 7E     ld a,(hl)  
0000:3976 23     inc hl      
0000:3977 66     ld h,(hl)  
0000:3978 6F     ld l,a      
0000:3979 CD2201 call HL>=DE?   ;; x >= x0 ?
0000:397C 2068   jr nz,39E6  ;; break
;;
0000:397E 211F00 ld hl,001F  
0000:3981 39     add hl,sp  
0000:3982 5E     ld e,(hl)  
0000:3983 23     inc hl      
0000:3984 56     ld d,(hl)  
0000:3985 EB     ex de,hl    ;; hl = sp001f   (string^)
;;
0000:3986 5E     ld e,(hl)  
0000:3987 211100 ld hl,0011  
0000:398A 39     add hl,sp  
0000:398B 73     ld (hl),e   ;; de = sp0011   (char)
;;
0000:398C 1600   ld d,00    
0000:398E D5     push de     ;; [-2] push char
;;
0000:398F 211B00 ld hl,001B  ;; sp0019
0000:3992 39     add hl,sp  
0000:3993 5E     ld e,(hl)  
0000:3994 23     inc hl      
0000:3995 56     ld d,(hl)   ;; de = par0
;;
0000:3996 210A00 ld hl,000A  
0000:3999 19     add hl,de   ;; hl = par0 + #000A
0000:399A 5E     ld e,(hl)  
0000:399B 1600   ld d,00     ;; de = (par0 + 000a)    (font)
0000:399D D5     push de     ;; [-4]
;;
0000:399E CD970A call get_charwidth(font, achar)  
0000:39A1 D1     pop de      
0000:39A2 D1     pop de      
0000:39A3 EB     ex de,hl    
0000:39A4 211400 ld hl,0014  
0000:39A7 39     add hl,sp  
0000:39A8 73     ld (hl),e   ;; de = char width
0000:39A9 1600   ld d,00     ;; sp0014 = char width
;;
0000:39AB 211B00 ld hl,001B  ;; par2      (x)
0000:39AE 39     add hl,sp  
0000:39AF 7E     ld a,(hl)  
0000:39B0 23     inc hl      
0000:39B1 66     ld h,(hl)  
0000:39B2 6F     ld l,a      
0000:39B3 19     add hl,de  
0000:39B4 EB     ex de,hl    ;; de = x + char width
;;
0000:39B5 211B00 ld hl,001B  ;; x = x + char width  
0000:39B8 39     add hl,sp  
0000:39B9 73     ld (hl),e  
0000:39BA 23     inc hl      
0000:39BB 72     ld (hl),d  
;;
0000:39BC 23     inc hl      
0000:39BD 23     inc hl      
0000:39BE 23     inc hl      ;; sp001f  (par6)
0000:39BF 5E     ld e,(hl)  
0000:39C0 23     inc hl      
0000:39C1 56     ld d,(hl)  
0000:39C2 13     inc de      
0000:39C3 72     ld (hl),d  
0000:39C4 2B     dec hl      
0000:39C5 73     ld (hl),e   ;; par6++     (string^)  point to next char
;;
;; loopinc
0000:39C6 211200 ld hl,0012  ;; i++
0000:39C9 39     add hl,sp  
0000:39CA 5E     ld e,(hl)  
0000:39CB 23     inc hl      
0000:39CC 56     ld d,(hl)  
0000:39CD 13     inc de      
0000:39CE 72     ld (hl),d  
0000:39CF 2B     dec hl      
0000:39D0 73     ld (hl),e  
;;
;; looptest
0000:39D1 211200 ld hl,0012  
0000:39D4 39     add hl,sp  
0000:39D5 5E     ld e,(hl)  
0000:39D6 23     inc hl      
0000:39D7 56     ld d,(hl)   ;; de = i
0000:39D8 212100 ld hl,0021  
0000:39DB 39     add hl,sp  
0000:39DC 7E     ld a,(hl)  
0000:39DD 23     inc hl      
0000:39DE 66     ld h,(hl)  
0000:39DF 6F     ld l,a      ;; hl = sp0021   (par8)  (n)
0000:39E0 CD3C01 call HL>DE?   ;; n > i ?
0000:39E3 C26339 jp nz,3963  ;; loop if i < n
;;
;;
;; Here when whole string done, or if x moves into (or started inside) box.
;; Now we clip any part of string that was outside box, leaving part that is in.
0000:39E6 211200 ld hl,0012  ;; de = i
0000:39E9 39     add hl,sp  
0000:39EA 5E     ld e,(hl)  
0000:39EB 23     inc hl      
0000:39EC 56     ld d,(hl)  
;;
0000:39ED 212100 ld hl,0021  ;; hl = n
0000:39F0 39     add hl,sp  
0000:39F1 7E     ld a,(hl)  
0000:39F2 23     inc hl      
0000:39F3 66     ld h,(hl)  
0000:39F4 6F     ld l,a      
;;
0000:39F5 A7     and a      
0000:39F6 ED52   sbc hl,de   ;; n - i
0000:39F8 C8     ret z       ;; did we clip it all ?
;;
;; here when there is still some part of string inside box.
;; And since I am an extremely stupid compiler, lets just see how many more
;; instructions we can waste.  I mean, there *must* be more than one way we can
;; calculate "n-i", right???
0000:39F9 212100 ld hl,0021  
0000:39FC 39     add hl,sp  
0000:39FD 5E     ld e,(hl)  
0000:39FE 23     inc hl      
0000:39FF 56     ld d,(hl)   ;; de = n
;;
0000:3A00 211200 ld hl,0012  
0000:3A03 39     add hl,sp  
0000:3A04 7E     ld a,(hl)  
0000:3A05 23     inc hl      
0000:3A06 66     ld h,(hl)  
0000:3A07 6F     ld l,a      ;; hl = i
;;
0000:3A08 A7     and a      
0000:3A09 EB     ex de,hl    
0000:3A0A ED52   sbc hl,de   ;; n - i
0000:3A0C EB     ex de,hl    ;; de = n-i
;;
;; OK, I guess I am ready to accept this as the new value for n...
0000:3A0D 212100 ld hl,0021  
0000:3A10 39     add hl,sp  
0000:3A11 73     ld (hl),e  
0000:3A12 23     inc hl      
0000:3A13 72     ld (hl),d   ;; n = n - i
;;
;; Now that we're really sure about the value of n-i, we still need to draw
;; the part of the string that is left inside of box.  The string has been
;; clipped, and the starting x has been adjusted to the pos of the first
;; char in string that is inside of box.
0000:3A14 211B00 ld hl,001B  ;; par2    (x)  (after adjust)
0000:3A17 39     add hl,sp  
0000:3A18 5E     ld e,(hl)  
0000:3A19 23     inc hl      
0000:3A1A 56     ld d,(hl)  
;;
0000:3A1B 210800 ld hl,0008  
0000:3A1E 39     add hl,sp  
0000:3A1F 73     ld (hl),e  
0000:3A20 23     inc hl      
0000:3A21 72     ld (hl),d   ;; box.x0 = x
;;
0000:3A22 211D00 ld hl,001D  ;; par4     (y)
0000:3A25 39     add hl,sp  
0000:3A26 5E     ld e,(hl)  
0000:3A27 23     inc hl      
0000:3A28 56     ld d,(hl)  
;;
0000:3A29 210A00 ld hl,000A  
0000:3A2C 39     add hl,sp  
0000:3A2D 73     ld (hl),e  
0000:3A2E 23     inc hl      
0000:3A2F 72     ld (hl),d   ;; box.y = y
;;
0000:3A30 211900 ld hl,0019  ;; par0
0000:3A33 39     add hl,sp  
0000:3A34 5E     ld e,(hl)  
0000:3A35 23     inc hl      
0000:3A36 56     ld d,(hl)  
;;
0000:3A37 211000 ld hl,0010  
0000:3A3A 19     add hl,de   ;; par0 + #0010
0000:3A3B 5E     ld e,(hl)  
0000:3A3C 23     inc hl      
0000:3A3D 56     ld d,(hl)   ;; par0.x1    (right edge of window)
;;
0000:3A3E 210C00 ld hl,000C  
0000:3A41 39     add hl,sp  
0000:3A42 73     ld (hl),e  
0000:3A43 23     inc hl      
0000:3A44 72     ld (hl),d   ;; box.x1 = par0.x1
;;
0000:3A45 211900 ld hl,0019  
0000:3A48 39     add hl,sp  
0000:3A49 5E     ld e,(hl)  
0000:3A4A 23     inc hl      
0000:3A4B 56     ld d,(hl)  
;;
0000:3A4C 211200 ld hl,0012  
0000:3A4F 19     add hl,de   ;; par0 +#0012
0000:3A50 5E     ld e,(hl)  
0000:3A51 23     inc hl      
0000:3A52 56     ld d,(hl)   ;; par0.y1    (bottom edge of window)
;;
0000:3A53 210E00 ld hl,000E  
0000:3A56 39     add hl,sp  
0000:3A57 73     ld (hl),e  
0000:3A58 23     inc hl      
0000:3A59 72     ld (hl),d   ;; box.y1 = par0.y1
;;
;;
0000:3A5A 211900 ld hl,0019  ;; de = par0
0000:3A5D 39     add hl,sp  
0000:3A5E 5E     ld e,(hl)  
0000:3A5F 23     inc hl      
0000:3A60 56     ld d,(hl)  
;;
0000:3A61 210A00 ld hl,000A  
0000:3A64 19     add hl,de   ;; par0.font
0000:3A65 5E     ld e,(hl)  
;;
0000:3A66 211000 ld hl,0010  
0000:3A69 39     add hl,sp  
0000:3A6A 73     ld (hl),e   ;; box.font ????????????
;;
0000:3A6B 212100 ld hl,0021  
0000:3A6E 39     add hl,sp  
0000:3A6F 5E     ld e,(hl)  
0000:3A70 1600   ld d,00    
0000:3A72 D5     push de     ;; [-2] sp0021  (n)
0000:3A73 2B     dec hl      
0000:3A74 56     ld d,(hl)  
0000:3A75 2B     dec hl      
0000:3A76 5E     ld e,(hl)  
0000:3A77 D5     push de     ;; [-4] sp001F   (string^)
0000:3A78 210C00 ld hl,000C  
0000:3A7B 39     add hl,sp  
0000:3A7C E5     push hl     ;; [-6] sp0008^  (box^)
0000:3A7D CD7A1E call drawstring_screenbox(box&font^, string^, n)  
0000:3A80 D1     pop de      
0000:3A81 D1     pop de      
0000:3A82 D1     pop de      
;;
;; HEY, this is pretty cool!!!  Now that I can label addresses, interesting
;; stuff is popping up all over the place!!!
;; This LCDbuff_dirty label tells me that this routine must be writing to
;; the lcd buffer, so at least I know it is display related.
0000:3A83 3E01   ld a,01    
0000:3A85 3230D6 ld (LCDbuff_dirty),a
0000:3A88 C9     ret        
;; End of one damn long routine



;; Picture of magicsector
;; nn  <-- num of recs
;; ??
;; ??  <--hex editor state
;; ??
;; xx xx xx xx xx xx  <-- data for 1st loaded app
;; xx xx xx xx xx xx  <-- data for 2nd loaded app
;; xx xx xx xx xx xx
;; xx xx xx xx xx xx
;; ...
;;    ^^          ^^
;;    ||          ||
;;   page         who




;; L = Scan_Magicsector(somebyte)    (magic sector a directory ???????)
;; result is used as a page# (or offset to add to page#) in the dataflash.
;; the "magicsector" is dataflash:08:00:xx.  
;; This is different than "lastsector" which was dataflash:1f:ff:xx
;;
;; This function is limited to one single 256 byte sector of the dataflash  
;; (dataflash:8:0:xx).  (page 08 : sector 00)
;;
;; Reads the first byte, dataflash:08:00:00, (maybe a "max" record number???)
;; Then, starting at offset #04, reads 6 byte records til par0 matches
;; last of six.  rets 2nd of that six in L.
;; If not matched before "max" record reached, returns #FF.
;;
;; this does NOT search much of the dataflash space,
;; just one fixed sector (256 bytes), maybe a dir of sorts???
;; I am calling it "magic" only 'coz I don't know what it really is,
;; just that it is special.
;;
          [0AD6] L = Scan_Magicsector(who)
0000:3A89 11F7FF ld de,FFF7  ;; local: sp0008-sp0010   ;; reserve 9 bytes on stack for local vars.  (fff7 = -9)
0000:3A8C CD6B05 call localize   ;;  par: sp0015   ;; LOCALIZE    (sp0008 - sp0010)
;;                                  ;; sp0008 (6 bytes) will hold read from dataflash
;;                                  ;; sp000e (byte) = #00 (init)         loop index
;;                                  ;; sp000f (byte) =  dataflash(8:0:0)  maxrec#
;;                                  ;; sp0010 (byte) = #04 (init)         sector offset
0000:3A8F 210F00 ld hl,000F  
0000:3A92 39     add hl,sp  
0000:3A93 E5     push hl     ;; push @sp000F (@where)    (where to put single byte)
;;
0000:3A94 210100 ld hl,0001  ;; push n     (just 1)
0000:3A97 E5     push hl    
;;
0000:3A98 6C     ld l,h      ;; push offset  (#0000)    (first byte of magic sector, a max rec#)
0000:3A99 E5     push hl    
;;
0000:3A9A 2602   ld h,02     ;; push pgsector (#0200)  (0000 0010 00:00 0000)  ;; fixed pgsector
0000:3A9C E5     push hl     ;;                        (        page:sector )
;;
;;  set spoof = first byte of sector   "max" record #
0000:3A9D CD0537 call Read_dataflash_sector(pgsector, offset, n, @where)   ;; Read_dataflash_sector(pgsector, offset, n, @where)
;;                                  ;; or, think of it as (page:sector:offset, n, @where)
;;                                  ;; or, think of it as              (8:0:0, 1, @sp000F
0000:3AA0 210800 ld hl,0008  
0000:3AA3 39     add hl,sp  
0000:3AA4 F9     ld sp,hl    ;; pop the above 4 pushes
;;
0000:3AA5 211000 ld hl,0010  
0000:3AA8 39     add hl,sp  
0000:3AA9 3604   ld (hl),04  ;; sp0010 = #04  (current_offset in magic, byte)
;;
0000:3AAB 2B     dec hl      
0000:3AAC 2B     dec hl      
0000:3AAD 3600   ld (hl),00  ;; sp000E = #00  (byte, loop index)
;;
0000:3AAF 1844   jr 3AF5     ;; skip ahead, test "while" condition, jp back up to next line if met.
;;
;; this is top of "while" loop
0000:3AB1 210800 ld hl,0008  ;;
0000:3AB4 39     add hl,sp  
0000:3AB5 E5     push hl     ;; [-2] push @sp0008 (@where = @sp0008)  beware of sp incrementing!!!!!
0000:3AB6 210600 ld hl,0006  
0000:3AB9 E5     push hl     ;; [-4] push #0006       (n = 6 bytes)
0000:3ABA 211400 ld hl,0014  
0000:3ABD 39     add hl,sp  
0000:3ABE 5E     ld e,(hl)  
0000:3ABF D5     push de     ;; [-6] push sp0010 [0014-4]  (offset = current_offset)                 [4 first time]
0000:3AC0 210002 ld hl,0200  
0000:3AC3 E5     push hl     ;; [-8] push #0200   (pgsector = #0200, fixed magic sector)
0000:3AC4 CD0537 call Read_dataflash_sector(pgsector, offset, n, @where)   ;; Read_dataflash_sector(magicsector, current_offset, n=6, @where=sp0008)     [offset 4]
0000:3AC7 210800 ld hl,0008  
0000:3ACA 39     add hl,sp  
0000:3ACB F9     ld sp,hl    ;; pop the above 4 pushes
;;
;; Now, sp0008-sp000d has the six bytes read from dataflash magic sector, current offset
;;
0000:3ACC 211500 ld hl,0015  
0000:3ACF 39     add hl,sp  
0000:3AD0 5E     ld e,(hl)  
0000:3AD1 1600   ld d,00    
0000:3AD3 D5     push de     ;; [-2] push par0
;;
0000:3AD4 210F00 ld hl,000F  ;; [sp000F-2, or sp000d]
0000:3AD7 39     add hl,sp  
0000:3AD8 5E     ld e,(hl)   ;; E = sp000D (6th byte of the six)
;;
0000:3AD9 E1     pop hl      
0000:3ADA 7D     ld a,l      ;; A = par0
0000:3ADB BB     cp e        ;; par0 == sp000D ?
0000:3ADC 2007   jr nz,3AE5  ;; jump if not equal
;;
;;   here if par equal byte 6
0000:3ADE 210900 ld hl,0009  ;; sp0009 is 2nd of six
0000:3AE1 39     add hl,sp  
0000:3AE2 5E     ld e,(hl)  
0000:3AE3 EB     ex de,hl    
0000:3AE4 C9     ret         ;; return L = 2nd of 6 , and were done.
;;
;;   here if par not not equal byte 6
0000:3AE5 211000 ld hl,0010  
0000:3AE8 39     add hl,sp  
0000:3AE9 7E     ld a,(hl)  
0000:3AEA C606   add a,06    
0000:3AEC 77     ld (hl),a   ;; current_offset = current_offset + #06
;;
;; inc index sp000e
0000:3AED 2B     dec hl      
0000:3AEE 2B     dec hl      
0000:3AEF E5     push hl     ;; push @sp000E
0000:3AF0 6E     ld l,(hl)   ;; L = sp000E
0000:3AF1 23     inc hl      
0000:3AF2 EB     ex de,hl    ;; DE = sp000E + 1
0000:3AF3 E1     pop hl      ;; HL = @sp000E
0000:3AF4 73     ld (hl),e   ;; sp000E = sp000E + 1
;;
;;   eval "while" condition
0000:3AF5 210F00 ld hl,000F  
0000:3AF8 39     add hl,sp  
0000:3AF9 5E     ld e,(hl)  
0000:3AFA 1600   ld d,00     ;; de = sp000f  (byte)  (1st byte of magic, maxrec#)
0000:3AFC D5     push de     ;; push max
;;
0000:3AFD 2B     dec hl      
0000:3AFE 5E     ld e,(hl)   ;; e = sp000e   (byte, loop index)
0000:3AFF E1     pop hl      
0000:3B00 7D     ld a,l      ;; a = max
0000:3B01 1C     inc e       ;; e = index + 1
0000:3B02 2803   jr z,3B07   ;; if index + 1 = 0 , then ret hl = #00ff  (i.e. 254 is last index val thru loop)
;;                                  ;;   BUT the current_offset will hit end of sector on 42nd loop??????
;;
0000:3B04 BB     cp e        ;; max - index+1, nc means max > index
0000:3B05 30AA   jr nc,3AB1  ;; if index < max , loop
;;
0000:3B07 21FF00 ld hl,00FF  
0000:3B0A C9     ret        



;; ********** NOTE!!! THESE ADDRESSES ARE DIFFERENT IN DIFFERENT VERSIONS!!!  this is important, coz I put debug here!!!
;; OK, as long as dc00-e2bf is inside callid buff.  ram init patched to skip dc00-e1ff, so won't clobber debug
;; 7 pointers, 260 (dec) bytes apart.  what to???  maybe/probably caller id info for 7 calls???
0000:3B0B A7DB   defw rxqueue   ;; assuming the last one runs 260 dec (104h) bytes, starting at #E1C0,
0000:3B0D ABDC   defw DCAB   ;; The address range is #DBA8 to #E2C3.
0000:3B0F AFDD   defw DDAF   ;; this represents a big chunk of ram that is not use if you don't have the
0000:3B11 B3DE   defw DEB3   ;; caller id function, or even the chip!!!  (71Ch bytes, or 1820 dec)
0000:3B13 B7DF   defw DFB7   ;; and the fact that it is not bank switched makes it a really good
0000:3B15 BBE0   defw E0BB   ;; place to locate the debugger code.  (don't forget to mod the init to not wipe)
0000:3B17 BFE1   defw E1BF  
;;          last is e1c0-e2c3, next byte after is e2c4
;; v2.22   callid buffer is #dba5-e2c0
;; v2.53yr callid buffer is #dba7-e2c2
;; v2.54   callid buffer is #dba8-e3c3


          caller_id_handler
;; called by isr 3.7
0000:3B19 DB02   in a,(02)   ; P2.2=1? -> Return
0000:3B1B CB57   bit 2,a     ;; p2.2 is callerid FSK DATA READY
0000:3B1D 2801   jr z,3B20   ;; zero means data ready
0000:3B1F C9     ret         ;; ret if not ready
;;
;; here if callerid data ready
0000:3B20 2A40E6 ld hl,(callidtime);; get timemark ("then")
0000:3B23 EB     ex de,hl    
0000:3B24 2A5ED4 ld hl,(time32);; HL = low 16 bits of time32 ("now")
0000:3B27 B7     or a        
0000:3B28 ED52   sbc hl,de   ;; HL = now - then   (diff of time32 and (#E641))
0000:3B2A B7     or a        
;;
0000:3B2B 111E00 ld de,001E  ;; 30 dec
0000:3B2E 013200 ld bc,0032  ;; 50 dec
0000:3B31 E5     push hl     ;; hl is elapsed time
0000:3B32 ED52   sbc hl,de   ;; cy if elapsed < 30 dec
0000:3B34 E1     pop hl      
0000:3B35 3808   jr c,3B3F   ;; if diff >= 30 ,
0000:3B37 3A49E6 ld a,(E649) ;;   then set E64A.0
0000:3B3A CBC7   set 0,a    
0000:3B3C 3249E6 ld (E649),a
;;
0000:3B3F B7     or a        ;; clr cy
0000:3B40 ED42   sbc hl,bc  
0000:3B42 3808   jr c,3B4C   ;; if diff >= 50 dec ,
0000:3B44 3A49E6 ld a,(E649) ;;   then set #E64A.7
0000:3B47 CBFF   set 7,a    
0000:3B49 3249E6 ld (E649),a
;;
0000:3B4C 2A5ED4 ld hl,(time32);; low 16 bits of time32
0000:3B4F 2240E6 ld (callidtime),hl;; set new timemark ("then = now")
;;
0000:3B52 3A38E6 ld a,(CID2) ;; not used???
0000:3B55 CD043D call 3D04   ;; B = Read_Callerid_serial_byte()
0000:3B58 3A3CE6 ld a,(CID6)
0000:3B5B FE05   cp 05       ;; skip leadin????? 5 pairs?????
0000:3B5D 3046   jr nc,3BA5  ;; if leadin >= 5 , jp 3ba5
;;
0000:3B5F 3A42E6 ld a,(E642)
0000:3B62 4F     ld c,a      ;; C = (#E643)      last???
0000:3B63 78     ld a,b      ;; A = cid byte
0000:3B64 3242E6 ld (E642),a ;; (#E643) = cid byte  next times last????
;;
0000:3B67 FE55   cp 55       ;; skip leadin????  sync'ing fsk detector???
0000:3B69 2808   jr z,3B73   ;; wait!!! char needs to be 55 or aa, or we clear and ret????
0000:3B6B FEAA   cp AA      
0000:3B6D 2804   jr z,3B73  
0000:3B6F CDCA3C call Clear_caller_id_vars   ;; clear vars E639  E63D  E63E  E64B  to 0
0000:3B72 C9     ret        
;;
0000:3B73 3A3CE6 ld a,(CID6) ;; first time only
0000:3B76 B7     or a        
0000:3B77 2010   jr nz,3B89  ;; skip ahead if not 0
0000:3B79 3C     inc a      
0000:3B7A 323CE6 ld (CID6),a ;; now it's 1
0000:3B7D 3E09   ld a,09    
0000:3B7F 3238E6 ld (CID2),a ;; and this is 9
0000:3B82 2A5ED4 ld hl,(time32)
0000:3B85 223EE6 ld (CID8),hl;; and this is time32
0000:3B88 C9     ret        
;;
0000:3B89 78     ld a,b      ;; A is new char
0000:3B8A B9     cp c        ;; C is last
0000:3B8B 2804   jr z,3B91   ; B!=C? -> 3B91 ;; jp if new same as last  (cid needs double chars?????)
;;******** this is nuts.  only 55 or aa get here, and only double 55 or double aa gets past here!!!!!!!! ****************
;;******** No it's not, I just was lookin at the callid spec, and the cid data
;;         starts with a preamble of 30 bytes "alternating 1's & 0's".
0000:3B8D CDCA3C call Clear_caller_id_vars   ;; clear vars E639  E63D  E63E  E64B  to 0 (start over???)
0000:3B90 C9     ret        
;;
;; got pair
0000:3B91 3A3CE6 ld a,(CID6) ; (E63D)++
0000:3B94 3C     inc a      
0000:3B95 323CE6 ld (CID6),a
0000:3B98 FE05   cp 05       ; !=5? -> Return
0000:3B9A C0     ret nz      
;;
;; got 4th pair
0000:3B9B AF     xor a      
0000:3B9C 3249E6 ld (E649),a ; (E64A)=0
0000:3B9F 3E28   ld a,28    
0000:3BA1 324AE6 ld (E64A),a ; (E63B)=28h
0000:3BA4 C9     ret        
;;
;; >= 5
0000:3BA5 3A3DE6 ld a,(CID7)
0000:3BA8 B7     or a        
0000:3BA9 280B   jr z,3BB6  
;;
0000:3BAB 3A49E6 ld a,(E649)
0000:3BAE CB7F   bit 7,a    
0000:3BB0 2879   jr z,3C2B  
0000:3BB2 AF     xor a      
0000:3BB3 323DE6 ld (CID7),a
;;
0000:3BB6 78     ld a,b      
0000:3BB7 FE04   cp 04      
0000:3BB9 2826   jr z,3BE1  
0000:3BBB FE06   cp 06      
0000:3BBD 2830   jr z,3BEF  
0000:3BBF FE80   cp 80      
0000:3BC1 281E   jr z,3BE1  
0000:3BC3 FE82   cp 82      
0000:3BC5 2828   jr z,3BEF  
;;
0000:3BC7 3A4AE6 ld a,(E64A)
0000:3BCA FE28   cp 28       ;; 40 dec
0000:3BCC 2007   jr nz,3BD5  
;;
0000:3BCE 78     ld a,b      
0000:3BCF FE55   cp 55      
0000:3BD1 C8     ret z      
0000:3BD2 FEAA   cp AA      
0000:3BD4 C8     ret z      
;;
0000:3BD5 3A4AE6 ld a,(E64A)
0000:3BD8 3D     dec a      
0000:3BD9 324AE6 ld (E64A),a
0000:3BDC C0     ret nz      
;;
0000:3BDD CDCA3C call Clear_caller_id_vars  
0000:3BE0 C9     ret        
;; #04 #80
0000:3BE1 3A49E6 ld a,(E649)
0000:3BE4 CB47   bit 0,a    
0000:3BE6 C8     ret z      
;;
0000:3BE7 AF     xor a      
0000:3BE8 3249E6 ld (E649),a
0000:3BEB 3E02   ld a,02    
0000:3BED 180C   jr 3BFB    
;; #06 #82
0000:3BEF 3A49E6 ld a,(E649)
0000:3BF2 CB47   bit 0,a    
0000:3BF4 C8     ret z      
;;
0000:3BF5 AF     xor a      
0000:3BF6 3249E6 ld (E649),a
0000:3BF9 3E01   ld a,01    
;;
0000:3BFB 3238E6 ld (CID2),a
0000:3BFE 3E01   ld a,01    
0000:3C00 323DE6 ld (CID7),a
0000:3C03 210B3B ld hl,3B0B  ;; HL points at table of 7 pointers
0000:3C06 3A39E6 ld a,(3bob_index_A) ;; 3bob index_A
0000:3C09 87     add a,a    
0000:3C0A 5F     ld e,a      
0000:3C0B 1600   ld d,00    
0000:3C0D 19     add hl,de   ;; HL points at indexed pointer in table.
0000:3C0E 5E     ld e,(hl)  
0000:3C0F 23     inc hl      
0000:3C10 56     ld d,(hl)  
0000:3C11 EB     ex de,hl    ;; HL = 3bob_pointer(index_A)
0000:3C12 3A38E6 ld a,(CID2)
0000:3C15 77     ld (hl),a   ;; 1st = 1 or 2
0000:3C16 23     inc hl      
0000:3C17 AF     xor a      
0000:3C18 77     ld (hl),a   ;; 2nd = 0
0000:3C19 23     inc hl      
0000:3C1A 70     ld (hl),b   ;; 3rd = recv'd byte
0000:3C1B 23     inc hl      
0000:3C1C 2243E6 ld (E643),hl;; save pointer in E644
0000:3C1F 78     ld a,b      
0000:3C20 3245E6 ld (E645),a ;; save byte in E646
0000:3C23 2A4DE6 ld hl,(E64D)
0000:3C26 23     inc hl      
0000:3C27 224DE6 ld (E64D),hl
0000:3C2A C9     ret        
;;
0000:3C2B 3A3DE6 ld a,(CID7)
0000:3C2E FE01   cp 01      
0000:3C30 202F   jr nz,3C61  
0000:3C32 B7     or a        
0000:3C33 280C   jr z,3C41  
0000:3C35 3A38E6 ld a,(CID2)
0000:3C38 FE01   cp 01      
0000:3C3A 78     ld a,b      
0000:3C3B 200D   jr nz,3C4A  
0000:3C3D FE03   cp 03      
0000:3C3F 2809   jr z,3C4A  
0000:3C41 3E02   ld a,02    
0000:3C43 323BE6 ld (CID5),a
0000:3C46 CDCA3C call Clear_caller_id_vars  
0000:3C49 C9     ret        
;;
0000:3C4A 3246E6 ld (E646),a
0000:3C4D 3E02   ld a,02    
0000:3C4F 323DE6 ld (CID7),a
0000:3C52 2A43E6 ld hl,(E643)
0000:3C55 70     ld (hl),b  
0000:3C56 23     inc hl      
0000:3C57 2243E6 ld (E643),hl
0000:3C5A 78     ld a,b      
0000:3C5B 2145E6 ld hl,E645  
0000:3C5E 86     add a,(hl)  
0000:3C5F 77     ld (hl),a  
0000:3C60 C9     ret        
;;
0000:3C61 3A46E6 ld a,(E646)
0000:3C64 B7     or a        
0000:3C65 2806   jr z,3C6D  
0000:3C67 3D     dec a      
0000:3C68 3246E6 ld (E646),a
0000:3C6B 18E5   jr 3C52    
0000:3C6D 2A43E6 ld hl,(E643)
0000:3C70 70     ld (hl),b  
0000:3C71 23     inc hl      
0000:3C72 2243E6 ld (E643),hl
0000:3C75 3A45E6 ld a,(E645)
0000:3C78 80     add a,b    
0000:3C79 B7     or a        
0000:3C7A 2809   jr z,3C85  
;;
0000:3C7C 3E02   ld a,02    
0000:3C7E 323BE6 ld (CID5),a
0000:3C81 CDCA3C call Clear_caller_id_vars  
0000:3C84 C9     ret        
;;
0000:3C85 2A4FE6 ld hl,(E64F)
0000:3C88 23     inc hl      
0000:3C89 224FE6 ld (E64F),hl
0000:3C8C 3A39E6 ld a,(3bob_index_A) ;; inc 3bob index_A
0000:3C8F 3C     inc a      
0000:3C90 FE07   cp 07       ;; rolls over to 0 every 7
0000:3C92 2001   jr nz,3C95  
0000:3C94 AF     xor a      
0000:3C95 3239E6 ld (3bob_index_A),a ;; 3bob index_A
0000:3C98 CDCA3C call Clear_caller_id_vars  
0000:3C9B C9     ret        
;; End of caller_id_handler.


;; not called iffp
0000:3C9C 3A38E6 ld a,(CID2)
0000:3C9F B7     or a        
0000:3CA0 C8     ret z      
;;
0000:3CA1 2A40E6 ld hl,(callidtime)
0000:3CA4 EB     ex de,hl    
0000:3CA5 2A5ED4 ld hl,(time32);; time32 (low 16)
0000:3CA8 B7     or a        
0000:3CA9 ED52   sbc hl,de   ;; time32 - (#E641)
0000:3CAB B7     or a        
0000:3CAC 11F401 ld de,01F4  ;; 500 dec
0000:3CAF ED52   sbc hl,de  
0000:3CB1 3011   jr nc,3CC4  ;; elapsed >= 500? , clear
0000:3CB3 2A3EE6 ld hl,(CID8)
0000:3CB6 EB     ex de,hl    
0000:3CB7 2A5ED4 ld hl,(time32);; time32
0000:3CBA B7     or a        
0000:3CBB ED52   sbc hl,de   ;; time32 - (#E63F)
0000:3CBD B7     or a        
0000:3CBE 11A00F ld de,0FA0  ;; 4000 dec
0000:3CC1 ED52   sbc hl,de  
0000:3CC3 D8     ret c       ;; elapsed >= 4000? , clear  (don't ret)
;;
0000:3CC4 F3     di          ;; non-interruptable clear
0000:3CC5 CDCA3C call Clear_caller_id_vars   ; Clear vars
0000:3CC8 FB     ei          
0000:3CC9 C9     ret        

          Clear_caller_id_vars
0000:3CCA AF     xor a       ; Clear vars
0000:3CCB 3238E6 ld (CID2),a
0000:3CCE 323CE6 ld (CID6),a
0000:3CD1 323DE6 ld (CID7),a
0000:3CD4 324AE6 ld (E64A),a
0000:3CD7 C9     ret        

0000:3CD8 AF     xor a       ; Clear even more vars
0000:3CD9 3238E6 ld (CID2),a
0000:3CDC 3239E6 ld (3bob_index_A),a ;; 3bob index_A
0000:3CDF 323AE6 ld (3b0b_index_B),a ;; 3bob index_B
0000:3CE2 323BE6 ld (CID5),a
0000:3CE5 323CE6 ld (CID6),a
0000:3CE8 323DE6 ld (CID7),a
0000:3CEB 324BE6 ld (E64B),a
0000:3CEE 3249E6 ld (E649),a
0000:3CF1 3237E6 ld (CID1),a
0000:3CF4 324CE6 ld (E64C),a
0000:3CF7 210000 ld hl,0000  
0000:3CFA 2247E6 ld (E647),hl
0000:3CFD 224DE6 ld (E64D),hl
0000:3D00 224FE6 ld (E64F),hl
0000:3D03 C9     ret        

;; B = Read_Callerid_serial_byte()
;; called frum callerid handler [#3B55]
;; pulses p28.2 8 times, reading p2.6, build a byte to ret in B  (maybe caller id?????) YES IT IS!!!!
0000:3D04 0608   ld b,08    
0000:3D06 3A9FDB ld a,(p28shadow)
0000:3D09 4F     ld c,a      ;; C = p28 shadow
0000:3D0A 1600   ld d,00     ;; bit accumulator = 0
;;
;; bitloop
0000:3D0C CB0A   rrc d       ;; shift bit accumulator
0000:3D0E 79     ld a,c      
0000:3D0F EE02   xor 02      
0000:3D11 4F     ld c,a      
0000:3D12 D328   out (28),a  ;; toggle callid data_clock (p28.2)  (cid chip pin 16)
0000:3D14 79     ld a,c      
0000:3D15 EE02   xor 02      
0000:3D17 4F     ld c,a      
0000:3D18 D328   out (28),a  ;; toggle callid data_clock
;;
0000:3D1A DB02   in a,(02)  
0000:3D1C E640   and 40      ;; keep just bit 6  (callid data)
0000:3D1E 17     rla         ;; A.7 = p2.6
0000:3D1F B2     or d        ;; add bit to accumulator
0000:3D20 57     ld d,a      
0000:3D21 10E9   djnz 3D0C   ; Loop 8x
;;
0000:3D23 42     ld b,d      
0000:3D24 C9     ret        


;; not called iffp
0000:3D25 CD9C3D call 3D9C   ;; HL = 3bob_pointer(index_B)
0000:3D28 C8     ret z       ;; ret err if index_A = index_B
;;
0000:3D29 7E     ld a,(hl)   ;; 1st byte
0000:3D2A 23     inc hl      
0000:3D2B 23     inc hl      
0000:3D2C FE01   cp 01      
0000:3D2E 2810   jr z,3D40   ;; if first = 1 , 3d40
0000:3D30 FE02   cp 02      
0000:3D32 2806   jr z,3D3A   ;; elseif first = 2 , ret 3
0000:3D34 210000 ld hl,0000  ;; else ret 0
0000:3D37 7C     ld a,h      
0000:3D38 B5     or l        
0000:3D39 C9     ret        
0000:3D3A 210300 ld hl,0003  
0000:3D3D 7C     ld a,h      
0000:3D3E B5     or l        
0000:3D3F C9     ret        
;;
;; first = 1
0000:3D40 7E     ld a,(hl)   ;; 3rd byte
0000:3D41 FE06   cp 06      
0000:3D43 202B   jr nz,3D70  ;; = 6?, then 3d70
;;
0000:3D45 23     inc hl      
0000:3D46 23     inc hl      
0000:3D47 0603   ld b,03    
0000:3D49 3E42   ld a,42    
0000:3D4B BE     cp (hl)    
0000:3D4C 2010   jr nz,3D5E  
;;
;; loop 1
0000:3D4E BE     cp (hl)    
0000:3D4F 23     inc hl      
0000:3D50 2038   jr nz,3D8A  
;;
0000:3D52 10FA   djnz 3D4E   ;; loop 1
;;
0000:3D54 210100 ld hl,0001  
0000:3D57 3E01   ld a,01    
0000:3D59 324BE6 ld (E64B),a
0000:3D5C 182F   jr 3D8D    
;;
0000:3D5E 3E6F   ld a,6F    
0000:3D60 BE     cp (hl)    
0000:3D61 23     inc hl      
0000:3D62 2026   jr nz,3D8A  
;;
0000:3D64 10FA   djnz 3D60   ;; loop 2
;;
0000:3D66 210200 ld hl,0002  
0000:3D69 3E00   ld a,00    
0000:3D6B 324BE6 ld (E64B),a
0000:3D6E 181D   jr 3D8D    
;;
;; 3rd = 6
0000:3D70 FE82   cp 82      
0000:3D72 2016   jr nz,3D8A  
;;
0000:3D74 23     inc hl      
0000:3D75 23     inc hl      
0000:3D76 7E     ld a,(hl)  
0000:3D77 FE0B   cp 0B      
0000:3D79 200F   jr nz,3D8A  
;;
0000:3D7B 23     inc hl      
0000:3D7C 7E     ld a,(hl)  
0000:3D7D FE01   cp 01      
0000:3D7F 2009   jr nz,3D8A  
;;
0000:3D81 23     inc hl      
0000:3D82 7E     ld a,(hl)  
0000:3D83 FEFF   cp FF      
0000:3D85 28CD   jr z,3D54  
;;
0000:3D87 B7     or a        
0000:3D88 28DC   jr z,3D66  
;;
0000:3D8A 210000 ld hl,0000  
;;
0000:3D8D 3A3AE6 ld a,(3b0b_index_B) ;; 3bob index_B
0000:3D90 3C     inc a      
0000:3D91 FE07   cp 07      
0000:3D93 2001   jr nz,3D96  
;;
0000:3D95 AF     xor a      
;;
0000:3D96 323AE6 ld (3b0b_index_B),a ;; 3bob index_B
0000:3D99 7C     ld a,h      
0000:3D9A B5     or l        
0000:3D9B C9     ret        

;; HL = 3bob_pointer(index_B)   called from above routine
0000:3D9C 3A3AE6 ld a,(3b0b_index_B) ;; 3bob index_B
0000:3D9F 47     ld b,a      
0000:3DA0 3A39E6 ld a,(3bob_index_A) ;; 3bob index_A
0000:3DA3 B8     cp b        
0000:3DA4 2006   jr nz,3DAC  ;; jp if not same
0000:3DA6 210000 ld hl,0000  
0000:3DA9 7C     ld a,h      
0000:3DAA B5     or l        
0000:3DAB C9     ret        
;;
0000:3DAC 210B3B ld hl,3B0B  ;; HL points at table of 7 pointers, 260 (dec) bytes apart.  what to???
0000:3DAF 3A3AE6 ld a,(3b0b_index_B) ;; 3bob index_B
0000:3DB2 87     add a,a    
0000:3DB3 5F     ld e,a      
0000:3DB4 1600   ld d,00    
0000:3DB6 19     add hl,de  
0000:3DB7 5E     ld e,(hl)  
0000:3DB8 23     inc hl      
0000:3DB9 56     ld d,(hl)  
0000:3DBA EB     ex de,hl    ;; ret hl = 3bob_pointer(index_B)
0000:3DBB 7C     ld a,h      
0000:3DBC B5     or l        
0000:3DBD C9     ret        

          callid_off
0000:3DBE 3AA2DB ld a,(p3shadow) ; P3.7=0  ;; disable int 3.7  (call id)
0000:3DC1 CBBF   res 7,a    
0000:3DC3 32A2DB ld (p3shadow),a
0000:3DC6 D303   out (03),a  
;;
0000:3DC8 DB29   in a,(29)   ; P29 |= 0x0C
0000:3DCA F60C   or 0C      
0000:3DCC D329   out (29),a  
;;
0000:3DCE 3A9FDB ld a,(p28shadow) ; P28.2=1, P28.3=0  ;; callid_data_clock=1, callid_reset=0 (cid chip awake mode)
0000:3DD1 CBD7   set 2,a     ;; callid_data_clock = 1
0000:3DD3 CB9F   res 3,a     ;; callid_reset = 0      (cid chip awake mode)
0000:3DD5 329FDB ld (p28shadow),a
0000:3DD8 D328   out (28),a  
;;
0000:3DDA AF     xor a       ; Clear vars
0000:3DDB 323AE6 ld (3b0b_index_B),a ;; 3bob index_B
0000:3DDE 3239E6 ld (3bob_index_A),a ;; 3bob index_A
0000:3DE1 324CE6 ld (E64C),a
0000:3DE4 3237E6 ld (CID1),a
0000:3DE7 C9     ret        

          callid_on
0000:3DE8 3A4CE6 ld a,(E64C)
0000:3DEB B7     or a        
0000:3DEC C0     ret nz      
;;
0000:3DED 3237E6 ld (CID1),a
;;
0000:3DF0 CD740A call Wall_Adaptor_detect  
0000:3DF3 C8     ret z       ;; ret if not detected
;;
0000:3DF4 3E0F   ld a,0F    
0000:3DF6 D329   out (29),a  
;;
0000:3DF8 3A9FDB ld a,(p28shadow) ; P28.2=0, P28.3=1  ;; callid_data_clock=0, callid_reset=1 (cid chip sleep mode)
0000:3DFB CB97   res 2,a    
0000:3DFD CBDF   set 3,a    
0000:3DFF 329FDB ld (p28shadow),a
0000:3E02 D328   out (28),a  
;;
0000:3E04 CDCA3C call Clear_caller_id_vars  
;;
0000:3E07 3E01   ld a,01    
0000:3E09 324CE6 ld (E64C),a
0000:3E0C 3237E6 ld (CID1),a
;;
0000:3E0F 3AA2DB ld a,(p3shadow) ; P3.7=1   ;; enable interrupt 3.7
0000:3E12 CBFF   set 7,a    
0000:3E14 32A2DB ld (p3shadow),a
0000:3E17 D303   out (03),a  
0000:3E19 C9     ret        


; Return((E654).2 == 0)
0000:3E1A 3A53E6 ld a,(E653)
0000:3E1D CB57   bit 2,a    
0000:3E1F 2806   jr z,3E27   ;
0000:3E21 210100 ld hl,0001  
0000:3E24 7C     ld a,h      
0000:3E25 B5     or l        
0000:3E26 C9     ret        
0000:3E27 210000 ld hl,0000  
0000:3E2A 7C     ld a,h      
0000:3E2B B5     or l        
0000:3E2C C9     ret        


; Return ((BYTE) (E64C))
          get_E64B
0000:3E2D 3A4BE6 ld a,(E64B)
0000:3E30 6F     ld l,a      
0000:3E31 2600   ld h,00    
0000:3E33 B4     or h        
0000:3E34 C9     ret        


;; not called in first 4 pages
;; I think this is testing if phone line in use,
;; but it won't work, coz chip is missing.
0000:3E35 3A53E6 ld a,(E653)
0000:3E38 E6FD   and FD      ;; 1111 1101
0000:3E3A 3253E6 ld (E653),a ;; reset bit 1 of (#E654)
0000:3E3D 4F     ld c,a      ;; save for now in C
;;
0000:3E3E E604   and 04      
0000:3E40 47     ld b,a      ;; just bit 2 in B
;;
0000:3E41 DB21   in a,(21)   ;; A = Parallel Port Status
0000:3E43 E604   and 04      ;; WHAT IS THIS BIT connected to?? U606, pin3, chip missing
0000:3E45 B8     cp b        ;; cp with bit 2 of (#E654)
0000:3E46 284C   jr z,3E94   ;; if matches, jp #3E94
;;
0000:3E48 B7     or a        
0000:3E49 281E   jr z,3E69   ;; if status bit 2 = 0 , jp #3e69
;;
;; status bit 2 = 1
0000:3E4B CB41   bit 0,c    
0000:3E4D CA863E jp z,3E86   ;; if bit 0 of (#E654) = 0 , jp #3E86
;;
0000:3E50 2A51E6 ld hl,(E651)
0000:3E53 EB     ex de,hl    
0000:3E54 2A5ED4 ld hl,(time32);; time32
0000:3E57 B7     or a        
0000:3E58 ED52   sbc hl,de  
0000:3E5A 11C800 ld de,00C8  
0000:3E5D B7     or a        
0000:3E5E ED52   sbc hl,de  
0000:3E60 3869   jr c,3ECB   ;; just returns
0000:3E62 3E06   ld a,06    
0000:3E64 3253E6 ld (E653),a
0000:3E67 1862   jr 3ECB     ;; just returns
;;
;; status bit 2 = 0
0000:3E69 CB41   bit 0,c    
0000:3E6B 2819   jr z,3E86   ;; if bit 0 of (#E654) = 0 , jp #3E86
;;
0000:3E6D 2A51E6 ld hl,(E651)
0000:3E70 EB     ex de,hl    
0000:3E71 2A5ED4 ld hl,(time32);; time32
0000:3E74 B7     or a        
0000:3E75 ED52   sbc hl,de  
0000:3E77 111A04 ld de,041A  
0000:3E7A B7     or a        
0000:3E7B ED52   sbc hl,de  
0000:3E7D 384C   jr c,3ECB   ;; just returns
0000:3E7F 3E02   ld a,02    
0000:3E81 3253E6 ld (E653),a
0000:3E84 1845   jr 3ECB     ;; just returns
;;
0000:3E86 79     ld a,c      
0000:3E87 F601   or 01      
0000:3E89 3253E6 ld (E653),a
0000:3E8C 2A5ED4 ld hl,(time32);; time32
0000:3E8F 2251E6 ld (E651),hl
0000:3E92 1837   jr 3ECB     ;; just returns
;;
;; bits match
0000:3E94 79     ld a,c      
0000:3E95 CB57   bit 2,a    
0000:3E97 2826   jr z,3EBF  
0000:3E99 0E06   ld c,06    
0000:3E9B CB47   bit 0,a    
0000:3E9D 2820   jr z,3EBF  
0000:3E9F 3A38E6 ld a,(CID2)
0000:3EA2 FE04   cp 04      
0000:3EA4 2819   jr z,3EBF  
0000:3EA6 2A51E6 ld hl,(E651)
0000:3EA9 EB     ex de,hl    
0000:3EAA 2A5ED4 ld hl,(time32);; time32
0000:3EAD AF     xor a      
0000:3EAE ED52   sbc hl,de  
0000:3EB0 112C01 ld de,012C  
0000:3EB3 AF     xor a      
0000:3EB4 ED52   sbc hl,de  
0000:3EB6 3807   jr c,3EBF  
0000:3EB8 79     ld a,c      
0000:3EB9 F608   or 08      
0000:3EBB 3253E6 ld (E653),a
0000:3EBE C9     ret        
;; two jumps to here, from right above
0000:3EBF 79     ld a,c      
0000:3EC0 E6F4   and F4      
0000:3EC2 3253E6 ld (E653),a
0000:3EC5 2A5ED4 ld hl,(time32);; time32
0000:3EC8 2251E6 ld (E651),hl
0000:3ECB C9     ret        




;; all zero to end of page, 308 dec bytes.
0000:3ECC 00000000 ....
0000:3ED0 00000000000000000000000000000000 ................
0000:3EE0 00000000000000000000000000000000 ................
0000:3EF0 00000000000000000000000000000000 ................
0000:3F00 00000000000000000000000000000000 ................
0000:3F10 00000000000000000000000000000000 ................
0000:3F20 00000000000000000000000000000000 ................
0000:3F30 00000000000000000000000000000000 ................
0000:3F40 00000000000000000000000000000000 ................
0000:3F50 00000000000000000000000000000000 ................
0000:3F60 00000000000000000000000000000000 ................
0000:3F70 00000000000000000000000000000000 ................
0000:3F80 00000000000000000000000000000000 ................
0000:3F90 00000000000000000000000000000000 ................
0000:3FA0 00000000000000000000000000000000 ................
0000:3FB0 00000000000000000000000000000000 ................
0000:3FC0 00000000000000000000000000000000 ................
0000:3FD0 00000000000000000000000000000000 ................
0000:3FE0 00000000000000000000000000000000 ................
0000:3FF0 00000000000000000000000000000000 ................
